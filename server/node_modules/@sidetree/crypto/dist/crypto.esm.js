import { Ed25519KeyPair } from '@transmute/did-key-ed25519';
import * as didKeyEd25519 from '@transmute/did-key-ed25519';
export { didKeyEd25519 as ed25519 };
import { Secp256k1KeyPair } from '@transmute/did-key-secp256k1';
import * as didKeySecp256k1 from '@transmute/did-key-secp256k1';
export { didKeySecp256k1 as secp256k1 };
import { generateMnemonic as generateMnemonic$1, mnemonicToSeed } from 'bip39';
import hdkey from 'hdkey';
import base64url from 'base64url';
import canonicalize from 'canonicalize';

/*
 * Copyright 2020 - Transmute Industries Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var generateMnemonic = function generateMnemonic() {
  try {
    return Promise.resolve(generateMnemonic$1());
  } catch (e) {
    return Promise.reject(e);
  }
};

// A type of promise-like that resolves synchronously and supports only one observer
const _Pact = /*#__PURE__*/(function() {
	function _Pact() {}
	_Pact.prototype.then = function(onFulfilled, onRejected) {
		const result = new _Pact();
		const state = this.s;
		if (state) {
			const callback = state & 1 ? onFulfilled : onRejected;
			if (callback) {
				try {
					_settle(result, 1, callback(this.v));
				} catch (e) {
					_settle(result, 2, e);
				}
				return result;
			} else {
				return this;
			}
		}
		this.o = function(_this) {
			try {
				const value = _this.v;
				if (_this.s & 1) {
					_settle(result, 1, onFulfilled ? onFulfilled(value) : value);
				} else if (onRejected) {
					_settle(result, 1, onRejected(value));
				} else {
					_settle(result, 2, value);
				}
			} catch (e) {
				_settle(result, 2, e);
			}
		};
		return result;
	};
	return _Pact;
})();

// Settles a pact synchronously
function _settle(pact, state, value) {
	if (!pact.s) {
		if (value instanceof _Pact) {
			if (value.s) {
				if (state & 1) {
					state = value.s;
				}
				value = value.v;
			} else {
				value.o = _settle.bind(null, pact, state);
				return;
			}
		}
		if (value && value.then) {
			value.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));
			return;
		}
		pact.s = state;
		pact.v = value;
		const observer = pact.o;
		if (observer) {
			observer(pact);
		}
	}
}

const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== "undefined" ? (Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator"))) : "@@iterator";

const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== "undefined" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol("Symbol.asyncIterator"))) : "@@asyncIterator";

// Asynchronously implement a switch statement
function _switch(discriminant, cases) {
	var dispatchIndex = -1;
	var awaitBody;
	outer: {
		for (var i = 0; i < cases.length; i++) {
			var test = cases[i][0];
			if (test) {
				var testValue = test();
				if (testValue && testValue.then) {
					break outer;
				}
				if (testValue === discriminant) {
					dispatchIndex = i;
					break;
				}
			} else {
				// Found the default case, set it as the pending dispatch case
				dispatchIndex = i;
			}
		}
		if (dispatchIndex !== -1) {
			do {
				var body = cases[dispatchIndex][1];
				while (!body) {
					dispatchIndex++;
					body = cases[dispatchIndex][1];
				}
				var result = body();
				if (result && result.then) {
					awaitBody = true;
					break outer;
				}
				var fallthroughCheck = cases[dispatchIndex][2];
				dispatchIndex++;
			} while (fallthroughCheck && !fallthroughCheck());
			return result;
		}
	}
	const pact = new _Pact();
	const reject = _settle.bind(null, pact, 2);
	(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);
	return pact;
	function _resumeAfterTest(value) {
		for (;;) {
			if (value === discriminant) {
				dispatchIndex = i;
				break;
			}
			if (++i === cases.length) {
				if (dispatchIndex !== -1) {
					break;
				} else {
					_settle(pact, 1, result);
					return;
				}
			}
			test = cases[i][0];
			if (test) {
				value = test();
				if (value && value.then) {
					value.then(_resumeAfterTest).then(void 0, reject);
					return;
				}
			} else {
				dispatchIndex = i;
			}
		}
		do {
			var body = cases[dispatchIndex][1];
			while (!body) {
				dispatchIndex++;
				body = cases[dispatchIndex][1];
			}
			var result = body();
			if (result && result.then) {
				result.then(_resumeAfterBody).then(void 0, reject);
				return;
			}
			var fallthroughCheck = cases[dispatchIndex][2];
			dispatchIndex++;
		} while (fallthroughCheck && !fallthroughCheck());
		_settle(pact, 1, result);
	}
	function _resumeAfterBody(result) {
		for (;;) {
			var fallthroughCheck = cases[dispatchIndex][2];
			if (!fallthroughCheck || fallthroughCheck()) {
				break;
			}
			dispatchIndex++;
			var body = cases[dispatchIndex][1];
			while (!body) {
				dispatchIndex++;
				body = cases[dispatchIndex][1];
			}
			result = body();
			if (result && result.then) {
				result.then(_resumeAfterBody).then(void 0, reject);
				return;
			}
		}
		_settle(pact, 1, result);
	}
}

/*
 * Copyright 2020 - Transmute Industries Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// https://github.com/satoshilabs/slips/blob/master/slip-0044.md
// '0' === Bitcoin... possible default.
// '1' === Test Net (all coins)
var SIDETREE_BIP44_COIN_TYPE = '1';
var crvToJwsAlg = {
  secp256k1: 'ES256K',
  Ed25519: 'EdDSA'
};

var toKeyPair = function toKeyPair(mnemonic, index, type) {
  if (type === void 0) {
    type = 'Ed25519';
  }

  try {
    return Promise.resolve(mnemonicToSeed(mnemonic)).then(function (seed) {
      var root = hdkey.fromMasterSeed(seed);
      var hdPath = "m/44'/" + SIDETREE_BIP44_COIN_TYPE + "'/0'/0/" + index;
      var addrNode = root.derive(hdPath);
      var keypair;

      var _temp = _switch(type, [[function () {
        return 'secp256k1';
      }, function () {
        {
          return Promise.resolve(Secp256k1KeyPair.generate({
            secureRandom: function secureRandom() {
              return addrNode._privateKey;
            }
          })).then(function (_Secp256k1KeyPair$gen) {
            keypair = _Secp256k1KeyPair$gen;
          });
        }
      }], [function () {
        return 'X25519';
      }, function () {
        {
          return Promise.resolve(Ed25519KeyPair.generate({
            secureRandom: function secureRandom() {
              return addrNode._privateKey;
            }
          })).then(function (_Ed25519KeyPair$gener) {
            keypair = _Ed25519KeyPair$gener;
            keypair = keypair.toX25519KeyPair(true);
          });
        }
      }], [function () {
        return 'Ed25519';
      }], [void 0, function () {
        {
          return Promise.resolve(Ed25519KeyPair.generate({
            secureRandom: function secureRandom() {
              return addrNode._privateKey;
            }
          })).then(function (_Ed25519KeyPair$gener2) {
            keypair = _Ed25519KeyPair$gener2;
          });
        }
      }]]);

      return _temp && _temp.then ? _temp.then(function () {
        return keypair;
      }) : keypair;
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

var createSigner = function createSigner(privateKeyJwk) {
  try {
    var _temp3 = function _temp3() {
      if (!key) {
        throw new Error('Unsupported crv ' + privateKeyJwk.crv);
      }

      var signer = key.signer();
      return {
        sign: function sign(data) {
          return signer.sign({
            data: data
          });
        }
      };
    };

    var _interrupt2 = false;
    var key;

    var _temp4 = _switch(privateKeyJwk.crv, [[function () {
      return 'Ed25519';
    }, function () {
      {
        return Promise.resolve(Ed25519KeyPair.from({
          publicKeyJwk: privateKeyJwk,
          privateKeyJwk: privateKeyJwk
        })).then(function (_Ed25519KeyPair$from) {
          key = _Ed25519KeyPair$from;
          _interrupt2 = true;
        });
      }
    }], [function () {
      return 'secp256k1';
    }, function () {
      {
        return Promise.resolve(Secp256k1KeyPair.from({
          publicKeyJwk: privateKeyJwk,
          privateKeyJwk: privateKeyJwk
        })).then(function (_Secp256k1KeyPair$fro) {
          key = _Secp256k1KeyPair$fro;
          _interrupt2 = true;
        });
      }
    }]]);

    return Promise.resolve(_temp4 && _temp4.then ? _temp4.then(_temp3) : _temp3(_temp4));
  } catch (e) {
    return Promise.reject(e);
  }
};

/*
 * Copyright 2020 - Transmute Industries Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var createJws = function createJws(signer, payload, header) {
  try {
    var encodedHeader = base64url.encode(canonicalize(header));
    var encodedPayload = base64url.encode(canonicalize(payload));
    var toBeSigned = encodedHeader + "." + encodedPayload;
    return Promise.resolve(signer.sign(Buffer.from(toBeSigned))).then(function (signature) {
      return toBeSigned + "." + base64url.encode(Buffer.from(signature));
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

/*
 * Copyright 2020 - Transmute Industries Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var createJwsSigner = function createJwsSigner(privateKeyJwk) {
  try {
    return Promise.resolve(createSigner(privateKeyJwk)).then(function (signer) {
      var alg = crvToJwsAlg[privateKeyJwk.crv];
      return {
        sign: function (data) {
          try {
            return Promise.resolve(createJws(signer, data, {
              alg: alg
            }));
          } catch (e) {
            return Promise.reject(e);
          }
        }
      };
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

var createVerifier = function createVerifier(publicKeyJwk) {
  try {
    var _temp3 = function _temp3() {
      if (!key) {
        throw new Error('Unsupported crv ' + publicKeyJwk.crv);
      }

      var verifier = key.verifier();
      return {
        verify: function verify(data, signature) {
          return verifier.verify({
            data: data,
            signature: signature
          });
        }
      };
    };

    var _interrupt2 = false;
    var key;

    var _temp4 = _switch(publicKeyJwk.crv, [[function () {
      return 'Ed25519';
    }, function () {
      {
        return Promise.resolve(Ed25519KeyPair.from({
          publicKeyJwk: publicKeyJwk
        })).then(function (_Ed25519KeyPair$from) {
          key = _Ed25519KeyPair$from;
          _interrupt2 = true;
        });
      }
    }], [function () {
      return 'secp256k1';
    }, function () {
      {
        return Promise.resolve(Secp256k1KeyPair.from({
          publicKeyJwk: publicKeyJwk
        })).then(function (_Secp256k1KeyPair$fro) {
          key = _Secp256k1KeyPair$fro;
          _interrupt2 = true;
        });
      }
    }]]);

    return Promise.resolve(_temp4 && _temp4.then ? _temp4.then(_temp3) : _temp3(_temp4));
  } catch (e) {
    return Promise.reject(e);
  }
};

/*
 * Copyright 2020 - Transmute Industries Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var verifyJws = function verifyJws(verifier, jws) {
  try {
    var _jws$split = jws.split('.'),
        header = _jws$split[0],
        payload = _jws$split[1],
        signature = _jws$split[2];

    var toBeVerified = header + "." + payload;
    return Promise.resolve(verifier.verify(Buffer.from(toBeVerified), base64url.toBuffer(signature)));
  } catch (e) {
    return Promise.reject(e);
  }
};

/*
 * Copyright 2020 - Transmute Industries Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var createJwsVerifier = function createJwsVerifier(publicKeyJwk) {
  try {
    return Promise.resolve(createVerifier(publicKeyJwk)).then(function (verifier) {
      return {
        verify: function (jws) {
          try {
            return Promise.resolve(verifyJws(verifier, jws));
          } catch (e) {
            return Promise.reject(e);
          }
        }
      };
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

export { createJwsSigner, createJwsVerifier, generateMnemonic, toKeyPair };
//# sourceMappingURL=crypto.esm.js.map
