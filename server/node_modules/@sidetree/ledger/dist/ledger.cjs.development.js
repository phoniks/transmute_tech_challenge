'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var testVectors = require('@sidetree/test-vectors');

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

/*
 * Copyright 2020 - Transmute Industries Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var _require = /*#__PURE__*/require('../package.json'),
    version = _require.version;
/**
 * Mock Blockchain class for testing.
 */


var MockLedger = /*#__PURE__*/function () {
  function MockLedger() {
    var _this = this;

    /** Stores each hash given in write() method. */
    this.hashes = [];
    this.latestTime = {
      time: 0,
      hash: ''
    };

    this.getLatestTime = function () {
      _this.latestTime = {
        time: 500000,
        hash: 'dummyHash'
      };
      return Promise.resolve(_this.latestTime);
    };
  }

  var _proto = MockLedger.prototype;

  _proto.getServiceVersion = function getServiceVersion() {
    try {
      return Promise.resolve({
        name: 'mock-ledger',
        version: version
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.initialize = function initialize() {
    return Promise.resolve();
  };

  _proto.getFee = function getFee(_transactionTime) {
    throw new Error('Method not implemented.');
  };

  _proto.getValueTimeLock = function getValueTimeLock(_lockIdentifier) {
    throw new Error('Method not implemented.');
  };

  _proto.getWriterValueTimeLock = function getWriterValueTimeLock() {
    throw new Error('Method not implemented.');
  };

  _proto.write = function write(anchorString, _fee) {

    try {
      var _this3 = this;

      _this3.hashes.push([anchorString]);

      return Promise.resolve();
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.read = function read(sinceTransactionNumber, _transactionTimeHash) {
    try {
      var _this5 = this;

      var transactions = _this5.hashes.map(function (hash, index) {
        return {
          transactionNumber: index,
          transactionTime: index,
          transactionHash: hash[0],
          transactionTimeHash: hash[0],
          anchorString: hash[0],
          writer: 'writer',
          transactionFeePaid: 0,
          normalizedTransactionFee: 0
        };
      });

      if (sinceTransactionNumber) {
        transactions = transactions.filter(function (t) {
          return t.transactionNumber >= sinceTransactionNumber;
        });
      } else if (_transactionTimeHash) {
        transactions = transactions.filter(function (t) {
          return t.transactionTimeHash === _transactionTimeHash;
        });
      }

      return Promise.resolve({
        moreTransactions: false,
        transactions: transactions
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.getFirstValidTransaction = function getFirstValidTransaction(_transactions) {
    return Promise.resolve(undefined);
  };

  /**
   * Hardcodes the latest time to be returned.
   */
  _proto.setLatestTime = function setLatestTime(time) {
    this.latestTime = time;
  };

  _createClass(MockLedger, [{
    key: "approximateTime",
    get: function get() {
      return this.latestTime;
    }
  }]);

  return MockLedger;
}();

/*
 * Copyright 2020 - Transmute Industries Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var _filesystem$anchorFil = testVectors.filesystem.anchorFile,
    anchorString = _filesystem$anchorFil.anchorString,
    anchorString2 = _filesystem$anchorFil.anchorString2,
    anchorString3 = _filesystem$anchorFil.anchorString3;
jest.setTimeout(10 * 1000);

var testSuite = function testSuite(ledger) {
  describe(ledger.constructor.name, function () {
    beforeAll(function () {
      try {
        return Promise.resolve(ledger.initialize()).then(function () {});
      } catch (e) {
        return Promise.reject(e);
      }
    });
    describe('getServiceVersion', function () {
      it('should get service version', function () {
        try {
          return Promise.resolve(ledger.getServiceVersion()).then(function (serviceVersion) {
            expect(serviceVersion).toBeDefined();
            expect(serviceVersion.name).toBeDefined();
            expect(serviceVersion.version).toBeDefined();
          });
        } catch (e) {
          return Promise.reject(e);
        }
      });
    });
    describe('write', function () {
      it('should write to the ledger', function () {
        try {
          return Promise.resolve(ledger.write(anchorString, 0)).then(function () {});
        } catch (e) {
          return Promise.reject(e);
        }
      });
    });
    describe('getApproximateTime', function () {
      it('should get latest cached blockchain time', function () {
        try {
          return Promise.resolve(ledger.getLatestTime()).then(function (realTime) {
            return Promise.resolve(ledger.approximateTime).then(function (cachedTime) {
              expect(cachedTime.time).toBe(realTime.time);
              expect(cachedTime.hash).toBe(realTime.hash);
            });
          });
        } catch (e) {
          return Promise.reject(e);
        }
      });
    });
    describe('read', function () {
      var transactionTimeHash;
      var sinceTransactionNumber;
      it('should get all transactions', function () {
        try {
          return Promise.resolve(ledger.read()).then(function (readResult) {
            expect(readResult.moreTransactions).toBeFalsy();
            expect(readResult.transactions).toHaveLength(1);
            expect(readResult.transactions[0].transactionNumber).toBe(0);
            expect(readResult.transactions[0].transactionTime).toBeDefined();
            expect(readResult.transactions[0].transactionTimeHash).toBeDefined();
            expect(readResult.transactions[0].anchorString).toBe(anchorString);
            expect(readResult.transactions[0].writer).toBeDefined();
            transactionTimeHash = readResult.transactions[0].transactionTimeHash;
            return Promise.resolve(ledger.write(anchorString2, 0)).then(function () {
              return Promise.resolve(ledger.read()).then(function (readResult2) {
                expect(readResult2.moreTransactions).toBeFalsy();
                expect(readResult2.transactions).toHaveLength(2);
                expect(readResult2.transactions[0].anchorString).toBe(anchorString);
                expect(readResult2.transactions[1].anchorString).toBe(anchorString2);
                sinceTransactionNumber = readResult2.transactions[1].transactionNumber;
              });
            });
          });
        } catch (e) {
          return Promise.reject(e);
        }
      });
      it('should get a specific transaction', function () {
        try {
          return Promise.resolve(ledger.read(undefined, transactionTimeHash)).then(function (readResult) {
            expect(readResult.moreTransactions).toBeFalsy();
            expect(readResult.transactions).toHaveLength(1);
            expect(readResult.transactions[0].transactionTimeHash).toBe(transactionTimeHash);
            expect(readResult.transactions[0].anchorString).toBe(anchorString);
          });
        } catch (e) {
          return Promise.reject(e);
        }
      });
      it('should get all transactions since a block', function () {
        try {
          return Promise.resolve(ledger.write(anchorString3, 0)).then(function () {
            return Promise.resolve(ledger.read(sinceTransactionNumber)).then(function (readResult) {
              expect(readResult.moreTransactions).toBeFalsy();
              expect(readResult.transactions).toHaveLength(2);
              expect(readResult.transactions[0].transactionNumber).toBe(sinceTransactionNumber);
              expect(readResult.transactions[1].transactionNumber).toBe(sinceTransactionNumber + 1);
              expect(readResult.transactions[0].anchorString).toBe(anchorString2);
              expect(readResult.transactions[1].anchorString).toBe(anchorString3);
            });
          });
        } catch (e) {
          return Promise.reject(e);
        }
      });
      it('should return no transaction if the requested transactionNumber doesnt exist', function () {
        try {
          return Promise.resolve(ledger.read(3)).then(function (readResult) {
            expect(readResult.moreTransactions).toBeFalsy();
            expect(readResult.transactions).toHaveLength(0);
          });
        } catch (e) {
          return Promise.reject(e);
        }
      });
      it('should return no transaction if the requested transactionTimeHash doesnt exist', function () {
        try {
          return Promise.resolve(ledger.read(undefined, '0x123')).then(function (readResult) {
            expect(readResult.moreTransactions).toBeFalsy();
            expect(readResult.transactions).toHaveLength(0);
          });
        } catch (e) {
          return Promise.reject(e);
        }
      });
    });
  });
}; // eslint-disable-next-line jest/no-export

exports.MockLedger = MockLedger;
exports.testSuite = testSuite;
//# sourceMappingURL=ledger.cjs.development.js.map
