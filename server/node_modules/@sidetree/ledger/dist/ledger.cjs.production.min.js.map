{"version":3,"file":"ledger.cjs.production.min.js","sources":["../src/MockLedger.ts","../src/__tests__/testSuite.ts"],"sourcesContent":["/*\n * Copyright 2020 - Transmute Industries Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\nimport {\n  BlockchainTimeModel,\n  IBlockchain,\n  ServiceVersionModel,\n  TransactionModel,\n  ValueTimeLockModel,\n} from '@sidetree/common';\nconst { version } = require('../package.json');\n\n/**\n * Mock Blockchain class for testing.\n */\nexport default class MockLedger implements IBlockchain {\n  async getServiceVersion(): Promise<ServiceVersionModel> {\n    return {\n      name: 'mock-ledger',\n      version,\n    };\n  }\n  initialize(): Promise<void> {\n    return Promise.resolve();\n  }\n  getFee(_transactionTime: number): Promise<number> {\n    throw new Error('Method not implemented.');\n  }\n\n  getValueTimeLock(\n    _lockIdentifier: string\n  ): Promise<ValueTimeLockModel | undefined> {\n    throw new Error('Method not implemented.');\n  }\n\n  getWriterValueTimeLock(): Promise<ValueTimeLockModel | undefined> {\n    throw new Error('Method not implemented.');\n  }\n\n  /** Stores each hash given in write() method. */\n  hashes: [string][] = [];\n\n  public async write(anchorString: string, _fee = 0): Promise<void> {\n    this.hashes.push([anchorString]);\n  }\n\n  public async read(\n    sinceTransactionNumber?: number,\n    _transactionTimeHash?: string\n  ): Promise<{ moreTransactions: boolean; transactions: TransactionModel[] }> {\n    let transactions: TransactionModel[] = this.hashes.map((hash, index) => ({\n      transactionNumber: index,\n      transactionTime: index,\n      transactionHash: hash[0],\n      transactionTimeHash: hash[0],\n      anchorString: hash[0],\n      writer: 'writer',\n      transactionFeePaid: 0,\n      normalizedTransactionFee: 0,\n    }));\n    if (sinceTransactionNumber) {\n      transactions = transactions.filter(\n        (t) => t.transactionNumber >= sinceTransactionNumber\n      );\n    } else if (_transactionTimeHash) {\n      transactions = transactions.filter(\n        (t) => t.transactionTimeHash === _transactionTimeHash\n      );\n    }\n\n    return {\n      moreTransactions: false,\n      transactions: transactions,\n    };\n  }\n\n  public async getFirstValidTransaction(\n    _transactions: TransactionModel[]\n  ): Promise<TransactionModel | undefined> {\n    return undefined;\n  }\n\n  private latestTime?: BlockchainTimeModel = {\n    time: 0,\n    hash: '',\n  };\n\n  public getLatestTime = (): Promise<BlockchainTimeModel> => {\n    this.latestTime = {\n      time: 500000,\n      hash: 'dummyHash',\n    };\n    return Promise.resolve(this.latestTime);\n  };\n\n  public get approximateTime(): BlockchainTimeModel {\n    return this.latestTime!;\n  }\n  /**\n   * Hardcodes the latest time to be returned.\n   */\n  public setLatestTime(time: BlockchainTimeModel): void {\n    this.latestTime = time;\n  }\n}\n","/*\n * Copyright 2020 - Transmute Industries Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { IBlockchain } from '@sidetree/common';\nimport { filesystem } from '@sidetree/test-vectors';\n\nconst { anchorString, anchorString2, anchorString3 } = filesystem.anchorFile;\n\njest.setTimeout(10 * 1000);\n\nconst testSuite = (ledger: IBlockchain): void => {\n  describe(ledger.constructor.name, () => {\n    beforeAll(async () => {\n      await ledger.initialize();\n    });\n\n    describe('getServiceVersion', () => {\n      it('should get service version', async () => {\n        const serviceVersion = await ledger.getServiceVersion();\n        expect(serviceVersion).toBeDefined();\n        expect(serviceVersion.name).toBeDefined();\n        expect(serviceVersion.version).toBeDefined();\n      });\n    });\n\n    describe('write', () => {\n      it('should write to the ledger', async () => {\n        await ledger.write(anchorString, 0);\n      });\n    });\n\n    describe('getApproximateTime', () => {\n      it('should get latest cached blockchain time', async () => {\n        const realTime = await (ledger as any).getLatestTime();\n        const cachedTime = await ledger.approximateTime;\n        expect(cachedTime.time).toBe(realTime.time);\n        expect(cachedTime.hash).toBe(realTime.hash);\n      });\n    });\n\n    describe('read', () => {\n      let transactionTimeHash: string;\n      let sinceTransactionNumber: number;\n\n      it('should get all transactions', async () => {\n        const readResult = await ledger.read();\n        expect(readResult.moreTransactions).toBeFalsy();\n        expect(readResult.transactions).toHaveLength(1);\n        expect(readResult.transactions[0].transactionNumber).toBe(0);\n        expect(readResult.transactions[0].transactionTime).toBeDefined();\n        expect(readResult.transactions[0].transactionTimeHash).toBeDefined();\n        expect(readResult.transactions[0].anchorString).toBe(anchorString);\n        expect(readResult.transactions[0].writer).toBeDefined();\n        transactionTimeHash = readResult.transactions[0].transactionTimeHash;\n\n        await ledger.write(anchorString2, 0);\n        const readResult2 = await ledger.read();\n        expect(readResult2.moreTransactions).toBeFalsy();\n        expect(readResult2.transactions).toHaveLength(2);\n        expect(readResult2.transactions[0].anchorString).toBe(anchorString);\n        expect(readResult2.transactions[1].anchorString).toBe(anchorString2);\n        sinceTransactionNumber = readResult2.transactions[1].transactionNumber;\n      });\n\n      it('should get a specific transaction', async () => {\n        const readResult = await ledger.read(undefined, transactionTimeHash);\n        expect(readResult.moreTransactions).toBeFalsy();\n        expect(readResult.transactions).toHaveLength(1);\n        expect(readResult.transactions[0].transactionTimeHash).toBe(\n          transactionTimeHash\n        );\n        expect(readResult.transactions[0].anchorString).toBe(anchorString);\n      });\n\n      it('should get all transactions since a block', async () => {\n        await ledger.write(anchorString3, 0);\n        const readResult = await ledger.read(sinceTransactionNumber);\n        expect(readResult.moreTransactions).toBeFalsy();\n        expect(readResult.transactions).toHaveLength(2);\n        expect(readResult.transactions[0].transactionNumber).toBe(\n          sinceTransactionNumber\n        );\n        expect(readResult.transactions[1].transactionNumber).toBe(\n          sinceTransactionNumber + 1\n        );\n        expect(readResult.transactions[0].anchorString).toBe(anchorString2);\n        expect(readResult.transactions[1].anchorString).toBe(anchorString3);\n      });\n\n      it('should return no transaction if the requested transactionNumber doesnt exist', async () => {\n        const readResult = await ledger.read(3);\n        expect(readResult.moreTransactions).toBeFalsy();\n        expect(readResult.transactions).toHaveLength(0);\n      });\n\n      it('should return no transaction if the requested transactionTimeHash doesnt exist', async () => {\n        const readResult = await ledger.read(undefined, '0x123');\n        expect(readResult.moreTransactions).toBeFalsy();\n        expect(readResult.transactions).toHaveLength(0);\n      });\n    });\n  });\n};\n\n// eslint-disable-next-line jest/no-export\nexport default testSuite;\n"],"names":["version","require","MockLedger","time","hash","_this","latestTime","Promise","resolve","getServiceVersion","name","initialize","getFee","_transactionTime","Error","getValueTimeLock","_lockIdentifier","getWriterValueTimeLock","write","anchorString","_fee","this","hashes","push","read","sinceTransactionNumber","_transactionTimeHash","transactions","map","index","transactionNumber","transactionTime","transactionHash","transactionTimeHash","writer","transactionFeePaid","normalizedTransactionFee","filter","t","moreTransactions","getFirstValidTransaction","_transactions","undefined","setLatestTime","filesystem","anchorFile","anchorString2","anchorString3","jest","setTimeout","ledger","describe","constructor","beforeAll","it","serviceVersion","expect","toBeDefined","getLatestTime","realTime","approximateTime","cachedTime","toBe","readResult","toBeFalsy","toHaveLength","readResult2"],"mappings":"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"}