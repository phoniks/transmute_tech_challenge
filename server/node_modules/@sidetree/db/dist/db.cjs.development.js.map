{"version":3,"file":"db.cjs.development.js","sources":["../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../src/MongoDb.ts","../src/MongoDbBase.ts","../src/MongoDbCasCache.ts","../src/MongoDbOperationQueue.ts","../src/MongoDbTransactionStore.ts","../src/MongoDbUnresolvableTransactionStore.ts","../src/entity/Operation.ts","../src/OperationStore.ts"],"sourcesContent":["// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","/*\n * The code in this file originated from\n * @see https://github.com/decentralized-identity/sidetree\n * For the list of changes that was made to the original code\n * @see https://github.com/transmute-industries/sidetree.js/blob/master/reference-implementation-changes.md\n *\n * Copyright 2020 - Transmute Industries Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Collection, MongoClient, Db } from 'mongodb';\n\n/**\n * MongoDB related operations.\n */\nexport default class MongoDb {\n  /**\n   * Test if a MongoDB service is running at the specified url.\n   */\n  public static async isServerAvailable(serverUrl: string): Promise<boolean> {\n    try {\n      const client = await MongoClient.connect(serverUrl, {\n        useUnifiedTopology: true,\n        useNewUrlParser: true,\n      });\n      await client.close();\n    } catch (error) {\n      console.log('Mongoclient connect error: ' + error);\n      return false;\n    }\n    return true;\n  }\n\n  public static async resetDatabase(\n    serverUrl: string,\n    databaseName: string\n  ): Promise<boolean> {\n    try {\n      const client = await MongoClient.connect(serverUrl, {\n        useUnifiedTopology: true,\n        useNewUrlParser: true,\n      });\n      const db = await client.db(databaseName);\n      const res = await db.dropDatabase();\n      await client.close();\n      return res;\n    } catch (error) {\n      console.log('Mongoclient connect error: ' + error);\n      return false;\n    }\n  }\n\n  public static async createCollectionIfNotExist(\n    db: Db,\n    collectionName: string\n  ): Promise<Collection<any>> {\n    // Get the names of existing collections.\n    const collections = await db.collections();\n    const collectionNames = collections.map(\n      (collection) => collection.collectionName\n    );\n    const collectionExists = collectionNames.find((c) => c === collectionName);\n\n    // If the collection exists, use it; else create it then use it.\n    let collection;\n    if (collectionExists) {\n      console.info(`Reusing existing collection ${collectionName}`);\n      collection = db.collection(collectionName);\n    } else {\n      console.info(`Creating new collection ${collectionName}`);\n      collection = await db.createCollection(collectionName);\n    }\n    return collection;\n  }\n}\n","/*\n * The code in this file originated from\n * @see https://github.com/decentralized-identity/sidetree\n * For the list of changes that was made to the original code\n * @see https://github.com/transmute-industries/sidetree.js/blob/master/reference-implementation-changes.md\n *\n * Copyright 2020 - Transmute Industries Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Collection, MongoClient, Db } from 'mongodb';\nimport MongoDb from './MongoDb';\n\nexport default abstract class MongoDbBase {\n  abstract collectionName: string;\n  private serverUrl: string;\n  public databaseName: string;\n  private client: MongoClient | undefined;\n  protected db: Db | undefined;\n  protected collection: Collection<any> | undefined;\n\n  constructor(serverUrl: string, databaseName: string) {\n    this.serverUrl = serverUrl;\n    this.databaseName = databaseName;\n  }\n\n  public async close(): Promise<void> {\n    return this.client!.close();\n  }\n\n  public async clearCollection(): Promise<void> {\n    await this.collection!.deleteMany({});\n  }\n\n  public async initialize(): Promise<void> {\n    this.client =\n      this.client ||\n      (await MongoClient.connect(this.serverUrl, {\n        useUnifiedTopology: true,\n        useNewUrlParser: true,\n      })); // `useNewUrlParser` addresses nodejs's URL parser deprecation warning.\n    this.db = this.client.db(this.databaseName);\n    this.collection = await MongoDb.createCollectionIfNotExist(\n      this.db!,\n      this.collectionName\n    );\n  }\n}\n","/*\n * The code in this file originated from\n * @see https://github.com/decentralized-identity/sidetree\n * For the list of changes that was made to the original code\n * @see https://github.com/transmute-industries/sidetree.js/blob/master/reference-implementation-changes.md\n *\n * Copyright 2020 - Transmute Industries Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { FetchResult, FetchResultCode } from '@sidetree/common';\nimport MongoDbBase from './MongoDbBase';\n\nexport default class MongoDbCasCache extends MongoDbBase {\n  readonly collectionName = 'cas-cache';\n\n  public async initialize(): Promise<void> {\n    await super.initialize();\n    await this.collection!.createIndex({ hash: 1 }, { unique: true });\n  }\n\n  async read(hash: string): Promise<FetchResult> {\n    const operations = await this.collection!.find({ hash })\n      .limit(1)\n      .toArray();\n    if (operations.length === 1) {\n      const operation = operations.pop();\n      return {\n        code: FetchResultCode.Success,\n        content: operation!.content.buffer as Buffer,\n      };\n    }\n    return {\n      code: FetchResultCode.NotFound,\n    };\n  }\n\n  async write(hash: string, content: Buffer): Promise<void> {\n    try {\n      await this.collection!.insertOne({ hash, content });\n    } catch (error) {\n      // Duplicate insert errors (error code 11000).\n      if (error.code !== 11000) {\n        throw error;\n      }\n    }\n  }\n}\n","/*\n * The code in this file originated from\n * @see https://github.com/decentralized-identity/sidetree\n * For the list of changes that was made to the original code\n * @see https://github.com/transmute-industries/sidetree.js/blob/master/reference-implementation-changes.md\n *\n * Copyright 2020 - Transmute Industries Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  ErrorCode,\n  IOperationQueue,\n  SidetreeError,\n  QueuedOperationModel,\n} from '@sidetree/common';\nimport { Binary, ObjectId } from 'mongodb';\nimport MongoDbBase from './MongoDbBase';\n\n/**\n * Sidetree operation stored in MongoDb.\n * Note: we use the shorter property name \"opIndex\" instead of \"operationIndex\" due to a constraint imposed by CosmosDB/MongoDB:\n * the sum of property names of a unique index keys need to be less than 40 characters.\n * Note: We represent opIndex, transactionNumber, and transactionTime as long instead of number (double) to avoid some floating\n * point comparison quirks.\n */\ninterface IMongoQueuedOperation {\n  _id?: ObjectId;\n  didUniqueSuffix: string;\n  operationBufferBsonBinary: Binary;\n}\n\n/**\n * Operation queue used by the Batch Writer implemented using MongoDB.\n */\nexport default class MongoDbOperationQueue extends MongoDbBase\n  implements IOperationQueue {\n  readonly collectionName = 'queued-operations';\n\n  public async initialize(): Promise<void> {\n    await super.initialize();\n    await this.collection!.createIndex(\n      { didUniqueSuffix: 1 },\n      { unique: true }\n    );\n  }\n\n  async enqueue(\n    didUniqueSuffix: string,\n    operationBuffer: Buffer\n  ): Promise<void> {\n    try {\n      const queuedOperation: IMongoQueuedOperation = {\n        didUniqueSuffix,\n        operationBufferBsonBinary: new Binary(operationBuffer),\n      };\n\n      await this.collection!.insertOne(queuedOperation);\n    } catch (error) {\n      // Duplicate insert errors (error code 11000).\n      if (error.code === 11000) {\n        throw new SidetreeError(ErrorCode.BatchWriterAlreadyHasOperationForDid);\n      }\n\n      throw error;\n    }\n  }\n\n  async dequeue(count: number): Promise<QueuedOperationModel[]> {\n    if (count <= 0) {\n      return [];\n    }\n\n    const queuedOperations = await this.collection!.find()\n      .sort({ _id: 1 })\n      .limit(count)\n      .toArray();\n    const lastOperation = queuedOperations[queuedOperations.length - 1];\n    await this.collection!.deleteMany({ _id: { $lte: lastOperation._id } });\n\n    return queuedOperations.map((operation) =>\n      MongoDbOperationQueue.convertToQueuedOperationModel(operation)\n    );\n  }\n\n  async peek(count: number): Promise<QueuedOperationModel[]> {\n    if (count <= 0) {\n      return [];\n    }\n\n    // NOTE: `_id` is the default index that is sorted based by create time.\n    const queuedOperations = await this.collection!.find()\n      .sort({ _id: 1 })\n      .limit(count)\n      .toArray();\n\n    return queuedOperations.map((operation) =>\n      MongoDbOperationQueue.convertToQueuedOperationModel(operation)\n    );\n  }\n\n  /**\n   * Checks to see if the queue already contains an operation for the given DID unique suffix.\n   */\n  async contains(didUniqueSuffix: string): Promise<boolean> {\n    const operations = await this.collection!.find({ didUniqueSuffix })\n      .limit(1)\n      .toArray();\n    return operations.length > 0;\n  }\n\n  private static convertToQueuedOperationModel(\n    mongoQueuedOperation: IMongoQueuedOperation\n  ): QueuedOperationModel {\n    return {\n      didUniqueSuffix: mongoQueuedOperation.didUniqueSuffix,\n      operationBuffer: mongoQueuedOperation.operationBufferBsonBinary.buffer,\n    };\n  }\n}\n","/*\n * The code in this file originated from\n * @see https://github.com/decentralized-identity/sidetree\n * For the list of changes that was made to the original code\n * @see https://github.com/transmute-industries/sidetree.js/blob/master/reference-implementation-changes.md\n *\n * Copyright 2020 - Transmute Industries Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ITransactionStore, TransactionModel } from '@sidetree/common';\nimport { Cursor, Long } from 'mongodb';\nimport MongoDbBase from './MongoDbBase';\n\n/**\n * Implementation of ITransactionStore that stores the transaction data in a MongoDB database.\n */\nexport default class MongoDbTransactionStore extends MongoDbBase\n  implements ITransactionStore {\n  readonly collectionName = 'transactions';\n\n  public async initialize(): Promise<void> {\n    await super.initialize();\n    await this.collection!.createIndex(\n      { transactionNumber: 1 },\n      { unique: true }\n    );\n  }\n\n  /**\n   * Returns the number of transactions in the store.\n   * Mainly used by tests.\n   */\n  public async getTransactionsCount(): Promise<number> {\n    const transactionCount = await this.collection!.countDocuments();\n    return transactionCount;\n  }\n\n  public async getTransaction(\n    transactionNumber: number\n  ): Promise<TransactionModel | undefined> {\n    const transactions = await this.collection!.find({\n      transactionNumber: Long.fromNumber(transactionNumber),\n    }).toArray();\n    if (transactions.length === 0) {\n      return undefined;\n    }\n\n    const transaction = transactions[0];\n    return transaction;\n  }\n\n  public async getTransactionsLaterThan(\n    transactionNumber: number | undefined,\n    max: number | undefined\n  ): Promise<TransactionModel[]> {\n    let transactions = [];\n\n    try {\n      let dbCursor: Cursor<any>;\n\n      // If given `undefined`, return transactions from the start.\n      if (transactionNumber === undefined) {\n        dbCursor = this.collection!.find();\n      } else {\n        dbCursor = this.collection!.find({\n          transactionNumber: { $gt: Long.fromNumber(transactionNumber) },\n        });\n      }\n\n      // If a limit is defined then set it.\n      if (max) {\n        dbCursor = dbCursor.limit(max);\n      }\n\n      // Sort the output\n      dbCursor = dbCursor.sort({ transactionNumber: 1 });\n\n      // Fetch the transactions\n      transactions = await dbCursor.toArray();\n    } catch (error) {\n      console.error(error);\n    }\n\n    return transactions;\n  }\n\n  async addTransaction(transaction: TransactionModel): Promise<void> {\n    try {\n      const transactionInMongoDb = {\n        anchorString: transaction.anchorString,\n        // NOTE: MUST force `transactionNumber` to be Int64 in MongoDB.\n        transactionNumber: Long.fromNumber(transaction.transactionNumber),\n        transactionTime: transaction.transactionTime,\n        transactionTimeHash: transaction.transactionTimeHash,\n        transactionFeePaid: transaction.transactionFeePaid,\n        normalizedTransactionFee: transaction.normalizedTransactionFee,\n        writer: transaction.writer,\n      };\n      await this.collection!.insertOne(transactionInMongoDb);\n    } catch (error) {\n      // Swallow duplicate insert errors (error code 11000) as no-op; rethrow others\n      if (error.code !== 11000) {\n        throw error;\n      }\n    }\n  }\n\n  async getLastTransaction(): Promise<TransactionModel | undefined> {\n    const lastTransactions = await this.collection!.find()\n      .limit(1)\n      .sort({ transactionNumber: -1 })\n      .toArray();\n    if (lastTransactions.length === 0) {\n      return undefined;\n    }\n\n    const lastProcessedTransaction = lastTransactions[0];\n    return lastProcessedTransaction;\n  }\n\n  async getExponentiallySpacedTransactions(): Promise<TransactionModel[]> {\n    const exponentiallySpacedTransactions: TransactionModel[] = [];\n    const allTransactions = await this.collection!.find()\n      .sort({ transactionNumber: 1 })\n      .toArray();\n\n    let index = allTransactions.length - 1;\n    let distance = 1;\n    while (index >= 0) {\n      exponentiallySpacedTransactions.push(allTransactions[index]);\n      index -= distance;\n      distance *= 2;\n    }\n    return exponentiallySpacedTransactions;\n  }\n\n  async removeTransactionsLaterThan(transactionNumber?: number): Promise<void> {\n    // If given `undefined`, remove all transactions.\n    if (transactionNumber === undefined) {\n      await this.clearCollection();\n      return;\n    }\n\n    await this.collection!.deleteMany({\n      transactionNumber: { $gt: Long.fromNumber(transactionNumber) },\n    });\n  }\n\n  /**\n   * Gets the list of processed transactions.\n   * Mainly used for test purposes.\n   */\n  public async getTransactions(): Promise<TransactionModel[]> {\n    const transactions = await this.collection!.find()\n      .sort({ transactionNumber: 1 })\n      .toArray();\n    return transactions;\n  }\n\n  /**\n   * Gets a list of transactions between the bounds of transaction time. The smaller value will be inclusive while the bigger be exclusive\n   * @param inclusiveBeginTransactionTime The first transaction time to begin querying for\n   * @param exclusiveEndTransactionTime The transaction time to stop querying for\n   */\n  public async getTransactionsStartingFrom(\n    inclusiveBeginTransactionTime: number,\n    exclusiveEndTransactionTime: number\n  ): Promise<TransactionModel[]> {\n    let cursor: Cursor<any>;\n    if (inclusiveBeginTransactionTime === exclusiveEndTransactionTime) {\n      // if begin === end, query for 1 transaction time\n      cursor = this.collection!.find({\n        transactionTime: {\n          $eq: Long.fromNumber(inclusiveBeginTransactionTime),\n        },\n      });\n    } else {\n      cursor = this.collection!.find({\n        $and: [\n          {\n            transactionTime: {\n              $gte: Long.fromNumber(inclusiveBeginTransactionTime),\n            },\n          },\n          {\n            transactionTime: {\n              $lt: Long.fromNumber(exclusiveEndTransactionTime),\n            },\n          },\n        ],\n      });\n    }\n\n    const transactions: TransactionModel[] = await cursor\n      .sort({ transactionNumber: 1 })\n      .toArray();\n    return transactions;\n  }\n}\n","/*\n * The code in this file originated from\n * @see https://github.com/decentralized-identity/sidetree\n * For the list of changes that was made to the original code\n * @see https://github.com/transmute-industries/sidetree.js/blob/master/reference-implementation-changes.md\n *\n * Copyright 2020 - Transmute Industries Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  IUnresolvableTransactionStore,\n  TransactionModel,\n} from '@sidetree/common';\nimport { Long } from 'mongodb';\nimport MongoDbBase from './MongoDbBase';\n\ninterface IUnresolvableTransaction extends TransactionModel {\n  firstFetchTime: number;\n  retryAttempts: number;\n  nextRetryTime: number;\n}\n\n/**\n * Implementation of `IIUnresolvableTransactionStore` that stores the transaction data in a MongoDB database.\n */\n\nexport default class MongoDbUnresolvableTransactionStore extends MongoDbBase\n  implements IUnresolvableTransactionStore {\n  public readonly collectionName: string = 'unresolvable-transactions';\n\n  private exponentialDelayFactorInMilliseconds = 60000;\n  private maximumUnresolvableTransactionReturnCount = 100;\n\n  /**\n   * Constructs a `MongoDbUnresolvableTransactionStore`;\n   * @param retryExponentialDelayFactor\n   *   The exponential delay factor in milliseconds for retries of unresolvable transactions.\n   *   e.g. if it is set to 1 seconds, then the delays for retries will be 1 second, 2 seconds, 4 seconds... until the transaction can be resolved.\n   */\n  constructor(\n    serverUrl: string,\n    databaseName: string,\n    retryExponentialDelayFactor?: number\n  ) {\n    super(serverUrl, databaseName);\n\n    if (retryExponentialDelayFactor !== undefined) {\n      this.exponentialDelayFactorInMilliseconds = retryExponentialDelayFactor;\n    }\n  }\n\n  public async initialize(): Promise<void> {\n    await super.initialize();\n    await this.collection!.createIndex(\n      { transactionTime: 1, transactionNumber: 1 },\n      { unique: true }\n    );\n    await this.collection!.createIndex({\n      nextRetryTime: 1,\n    });\n  }\n\n  async recordUnresolvableTransactionFetchAttempt(\n    transaction: TransactionModel\n  ): Promise<void> {\n    // Try to get the unresolvable transaction from store.\n    const transactionTime = transaction.transactionTime;\n    const transactionNumber = transaction.transactionNumber;\n    const searchFilter = {\n      transactionTime,\n      transactionNumber: Long.fromNumber(transactionNumber),\n    };\n    const findResults = await this.collection!.find(searchFilter).toArray();\n    let unresolvableTransaction: IUnresolvableTransaction | undefined;\n    if (findResults && findResults.length > 0) {\n      unresolvableTransaction = findResults[0];\n    }\n\n    // If unresolvable transaction not found in store, insert a new one; else update the info on retry attempts.\n    if (unresolvableTransaction === undefined) {\n      const newUnresolvableTransaction = {\n        transactionTime,\n        transactionNumber: Long.fromNumber(transactionNumber),\n        anchorString: transaction.anchorString,\n        transactionTimeHash: transaction.transactionTimeHash,\n        firstFetchTime: Date.now(),\n        retryAttempts: 0,\n        nextRetryTime: Date.now(),\n      };\n\n      await this.collection!.insertOne(newUnresolvableTransaction);\n    } else {\n      const retryAttempts = unresolvableTransaction.retryAttempts + 1;\n\n      // Exponentially delay the retry the more attempts are done in the past.\n      const anchorString = transaction.anchorString;\n      const requiredElapsedTimeSinceFirstFetchBeforeNextRetry =\n        Math.pow(2, unresolvableTransaction.retryAttempts) *\n        this.exponentialDelayFactorInMilliseconds;\n      const requiredElapsedTimeInSeconds =\n        requiredElapsedTimeSinceFirstFetchBeforeNextRetry / 1000;\n      console.info(\n        `Record transaction ${transactionNumber} with anchor string ${anchorString} to retry after ${requiredElapsedTimeInSeconds} seconds.`\n      );\n      const nextRetryTime =\n        unresolvableTransaction.firstFetchTime +\n        requiredElapsedTimeSinceFirstFetchBeforeNextRetry;\n\n      const searchFilter = {\n        transactionTime,\n        transactionNumber: Long.fromNumber(transactionNumber),\n      };\n      await this.collection!.updateOne(searchFilter, {\n        $set: { retryAttempts, nextRetryTime },\n      });\n    }\n  }\n\n  async removeUnresolvableTransaction(\n    transaction: TransactionModel\n  ): Promise<void> {\n    const transactionTime = transaction.transactionTime;\n    const transactionNumber = transaction.transactionNumber;\n    await this.collection!.deleteOne({\n      transactionTime,\n      transactionNumber: Long.fromNumber(transactionNumber),\n    });\n  }\n\n  async getUnresolvableTransactionsDueForRetry(\n    maximumReturnCount?: number\n  ): Promise<TransactionModel[]> {\n    // Override the return count if it is specified.\n    let returnCount = this.maximumUnresolvableTransactionReturnCount;\n    if (maximumReturnCount !== undefined) {\n      returnCount = maximumReturnCount;\n    }\n\n    const now = Date.now();\n    const unresolvableTransactionsToRetry = await this.collection!.find({\n      nextRetryTime: { $lte: now },\n    })\n      .sort({ nextRetryTime: 1 })\n      .limit(returnCount)\n      .toArray();\n\n    return unresolvableTransactionsToRetry;\n  }\n\n  async removeUnresolvableTransactionsLaterThan(\n    transactionNumber?: number\n  ): Promise<void> {\n    // If given `undefined`, remove all transactions.\n    if (transactionNumber === undefined) {\n      await this.clearCollection();\n      return;\n    }\n\n    await this.collection!.deleteMany({\n      transactionNumber: { $gt: Long.fromNumber(transactionNumber) },\n    });\n  }\n\n  /**\n   * Gets the list of unresolvable transactions.\n   * Mainly used for test purposes.\n   */\n  public async getUnresolvableTransactions(): Promise<\n    IUnresolvableTransaction[]\n  > {\n    const transactions = await this.collection!.find()\n      .sort({ transactionTime: 1, transactionNumber: 1 })\n      .toArray();\n    return transactions;\n  }\n}\n","/*\n * The code in this file originated from\n * @see https://github.com/decentralized-identity/sidetree\n * For the list of changes that was made to the original code\n * @see https://github.com/transmute-industries/sidetree.js/blob/master/reference-implementation-changes.md\n *\n * Copyright 2020 - Transmute Industries Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Entity, Column, PrimaryColumn, ObjectIdColumn } from 'typeorm';\nimport { OperationType } from '@sidetree/common';\n\n@Entity()\nexport default class Operation {\n  @PrimaryColumn()\n  @ObjectIdColumn()\n  _id?: string;\n\n  @Column()\n  didUniqueSuffix: string;\n\n  @Column()\n  type: OperationType;\n\n  @Column()\n  operationBuffer: Buffer;\n\n  @Column()\n  transactionTime: number;\n\n  @Column()\n  transactionNumber: number;\n\n  @Column()\n  operationIndex: number;\n\n  constructor(\n    didUniqueSuffix: string,\n    type: OperationType,\n    operationBuffer: Buffer,\n    transactionTime: number,\n    transactionNumber: number,\n    operationIndex: number\n  ) {\n    this.didUniqueSuffix = didUniqueSuffix;\n    this.type = type;\n    this.operationBuffer = operationBuffer;\n    this.transactionTime = transactionTime;\n    this.transactionNumber = transactionNumber;\n    this.operationIndex = operationIndex;\n  }\n}\n","/*\n * The code in this file originated from\n * @see https://github.com/decentralized-identity/sidetree\n * For the list of changes that was made to the original code\n * @see https://github.com/transmute-industries/sidetree.js/blob/master/reference-implementation-changes.md\n *\n * Copyright 2020 - Transmute Industries Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  IOperationStore,\n  AnchoredOperationModel,\n  OperationType,\n} from '@sidetree/common';\nimport { createConnection, MongoRepository, Connection } from 'typeorm';\nimport Operation from './entity/Operation';\n\nexport default class OperationStore implements IOperationStore {\n  private connection: Connection | undefined;\n  private repo: MongoRepository<Operation> | undefined;\n\n  private readonly databaseName: string;\n\n  constructor(private serverUrl: string, databaseName?: string) {\n    this.databaseName = databaseName ? databaseName : 'sidetree';\n  }\n\n  public async initialize(): Promise<void> {\n    const connection = await createConnection({\n      // Typeorm does not allow two connections to have the same name\n      // So we use a different name everytime in order to have parallel connections\n      name: `${Date.now()}`,\n      type: 'mongodb',\n      useNewUrlParser: true,\n      useUnifiedTopology: true,\n      url: `${this.serverUrl}${this.databaseName}`,\n      entities: [Operation],\n    });\n    this.connection = connection;\n    this.repo = connection.getMongoRepository(Operation);\n  }\n  public async close(): Promise<void> {\n    return this.connection!.close();\n  }\n\n  public async put(operations: AnchoredOperationModel[]): Promise<void> {\n    // Remove duplicates (same operationIndex) from the operations array\n    const operationsWithoutDuplicates = operations.reduce(\n      (opsWithoutDuplicates: AnchoredOperationModel[], operation) => {\n        const exists = opsWithoutDuplicates.find(\n          (op) => op.operationIndex === operation.operationIndex\n        );\n        if (exists) {\n          return opsWithoutDuplicates;\n        } else {\n          return [...opsWithoutDuplicates, operation];\n        }\n      },\n      []\n    );\n    // Only insert new elements\n    const onlyNewElements: AnchoredOperationModel[] = [];\n    for (const operation of operationsWithoutDuplicates) {\n      const anchoredOperation: AnchoredOperationModel = operation;\n      const res = await this.get(anchoredOperation.didUniqueSuffix);\n      const isDuplicated = res.find(\n        (op) =>\n          op.operationIndex === anchoredOperation.operationIndex &&\n          op.transactionNumber === anchoredOperation.transactionNumber\n      );\n      if (!isDuplicated) {\n        onlyNewElements.push(anchoredOperation);\n      }\n    }\n    if (onlyNewElements.length > 0) {\n      await this.repo!.insertMany(onlyNewElements);\n    }\n  }\n\n  public async get(didUniqueSuffix: string): Promise<AnchoredOperationModel[]> {\n    const results = await this.repo!.find({ didUniqueSuffix });\n    // Ensure operations are sorted by increasing order of operationIndex\n    results.sort((op1, op2) => op1.operationIndex - op2.operationIndex);\n    return results;\n  }\n\n  public async delete(transactionNumber?: number): Promise<void> {\n    if (transactionNumber) {\n      await this.repo!.deleteMany({\n        transactionNumber: { $gt: transactionNumber },\n      });\n    } else {\n      await this.repo!.deleteMany({});\n    }\n  }\n\n  public async deleteUpdatesEarlierThan(\n    didUniqueSuffix: string,\n    transactionNumber: number,\n    operationIndex: number\n  ): Promise<void> {\n    await this.repo!.deleteMany({\n      $or: [\n        {\n          didUniqueSuffix,\n          transactionNumber: { $lt: transactionNumber },\n          type: OperationType.Update,\n        },\n        {\n          didUniqueSuffix,\n          transactionNumber,\n          operationIndex: { $lt: operationIndex },\n          type: OperationType.Update,\n        },\n      ],\n    });\n  }\n}\n"],"names":["MongoDb","isServerAvailable","serverUrl","MongoClient","connect","useUnifiedTopology","useNewUrlParser","client","close","error","console","log","resetDatabase","databaseName","db","dropDatabase","res","createCollectionIfNotExist","collectionName","collections","collectionNames","map","collection","collectionExists","find","c","info","createCollection","MongoDbBase","clearCollection","deleteMany","initialize","MongoDbCasCache","createIndex","hash","unique","read","limit","toArray","operations","length","operation","pop","code","FetchResultCode","Success","content","buffer","NotFound","write","insertOne","MongoDbOperationQueue","didUniqueSuffix","enqueue","operationBuffer","queuedOperation","operationBufferBsonBinary","Binary","SidetreeError","ErrorCode","BatchWriterAlreadyHasOperationForDid","dequeue","count","sort","_id","queuedOperations","lastOperation","$lte","convertToQueuedOperationModel","peek","contains","mongoQueuedOperation","MongoDbTransactionStore","transactionNumber","getTransactionsCount","countDocuments","getTransaction","Long","fromNumber","transactions","undefined","transaction","getTransactionsLaterThan","max","dbCursor","$gt","addTransaction","transactionInMongoDb","anchorString","transactionTime","transactionTimeHash","transactionFeePaid","normalizedTransactionFee","writer","getLastTransaction","lastTransactions","lastProcessedTransaction","getExponentiallySpacedTransactions","exponentiallySpacedTransactions","allTransactions","index","distance","push","removeTransactionsLaterThan","getTransactions","getTransactionsStartingFrom","inclusiveBeginTransactionTime","exclusiveEndTransactionTime","cursor","$eq","$and","$gte","$lt","MongoDbUnresolvableTransactionStore","retryExponentialDelayFactor","exponentialDelayFactorInMilliseconds","nextRetryTime","recordUnresolvableTransactionFetchAttempt","searchFilter","findResults","unresolvableTransaction","newUnresolvableTransaction","firstFetchTime","Date","now","retryAttempts","requiredElapsedTimeSinceFirstFetchBeforeNextRetry","Math","pow","requiredElapsedTimeInSeconds","updateOne","$set","removeUnresolvableTransaction","deleteOne","getUnresolvableTransactionsDueForRetry","maximumReturnCount","returnCount","maximumUnresolvableTransactionReturnCount","removeUnresolvableTransactionsLaterThan","getUnresolvableTransactions","Operation","type","operationIndex","__decorate","PrimaryColumn","ObjectIdColumn","Column","Buffer","Entity","OperationStore","createConnection","name","url","entities","connection","repo","getMongoRepository","put","onlyNewElements","insertMany","operationsWithoutDuplicates","reduce","opsWithoutDuplicates","exists","op","anchoredOperation","get","isDuplicated","results","op1","op2","deleteUpdatesEarlierThan","$or","OperationType","Update"],"mappings":"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"}