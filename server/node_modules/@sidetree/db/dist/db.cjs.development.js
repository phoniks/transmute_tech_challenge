'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var mongodb = require('mongodb');
var common = require('@sidetree/common');
var typeorm = require('typeorm');
var tslib = require('tslib');

// A type of promise-like that resolves synchronously and supports only one observer
const _Pact = /*#__PURE__*/(function() {
	function _Pact() {}
	_Pact.prototype.then = function(onFulfilled, onRejected) {
		const result = new _Pact();
		const state = this.s;
		if (state) {
			const callback = state & 1 ? onFulfilled : onRejected;
			if (callback) {
				try {
					_settle(result, 1, callback(this.v));
				} catch (e) {
					_settle(result, 2, e);
				}
				return result;
			} else {
				return this;
			}
		}
		this.o = function(_this) {
			try {
				const value = _this.v;
				if (_this.s & 1) {
					_settle(result, 1, onFulfilled ? onFulfilled(value) : value);
				} else if (onRejected) {
					_settle(result, 1, onRejected(value));
				} else {
					_settle(result, 2, value);
				}
			} catch (e) {
				_settle(result, 2, e);
			}
		};
		return result;
	};
	return _Pact;
})();

// Settles a pact synchronously
function _settle(pact, state, value) {
	if (!pact.s) {
		if (value instanceof _Pact) {
			if (value.s) {
				if (state & 1) {
					state = value.s;
				}
				value = value.v;
			} else {
				value.o = _settle.bind(null, pact, state);
				return;
			}
		}
		if (value && value.then) {
			value.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));
			return;
		}
		pact.s = state;
		pact.v = value;
		const observer = pact.o;
		if (observer) {
			observer(pact);
		}
	}
}

function _isSettledPact(thenable) {
	return thenable instanceof _Pact && thenable.s & 1;
}

// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)
function _forTo(array, body, check) {
	var i = -1, pact, reject;
	function _cycle(result) {
		try {
			while (++i < array.length && (!check || !check())) {
				result = body(i);
				if (result && result.then) {
					if (_isSettledPact(result)) {
						result = result.v;
					} else {
						result.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));
						return;
					}
				}
			}
			if (pact) {
				_settle(pact, 1, result);
			} else {
				pact = result;
			}
		} catch (e) {
			_settle(pact || (pact = new _Pact()), 2, e);
		}
	}
	_cycle();
	return pact;
}

const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== "undefined" ? (Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator"))) : "@@iterator";

// Asynchronously iterate through an object's values
// Uses for...of if the runtime supports it, otherwise iterates until length on a copy
function _forOf(target, body, check) {
	if (typeof target[_iteratorSymbol] === "function") {
		var iterator = target[_iteratorSymbol](), step, pact, reject;
		function _cycle(result) {
			try {
				while (!(step = iterator.next()).done && (!check || !check())) {
					result = body(step.value);
					if (result && result.then) {
						if (_isSettledPact(result)) {
							result = result.v;
						} else {
							result.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));
							return;
						}
					}
				}
				if (pact) {
					_settle(pact, 1, result);
				} else {
					pact = result;
				}
			} catch (e) {
				_settle(pact || (pact = new _Pact()), 2, e);
			}
		}
		_cycle();
		if (iterator.return) {
			var _fixup = function(value) {
				try {
					if (!step.done) {
						iterator.return();
					}
				} catch(e) {
				}
				return value;
			};
			if (pact && pact.then) {
				return pact.then(_fixup, function(e) {
					throw _fixup(e);
				});
			}
			_fixup();
		}
		return pact;
	}
	// No support for Symbol.iterator
	if (!("length" in target)) {
		throw new TypeError("Object is not iterable");
	}
	// Handle live collections properly
	var values = [];
	for (var i = 0; i < target.length; i++) {
		values.push(target[i]);
	}
	return _forTo(values, function(i) { return body(values[i]); }, check);
}

const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== "undefined" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol("Symbol.asyncIterator"))) : "@@asyncIterator";

// Asynchronously call a function and send errors to recovery continuation
function _catch(body, recover) {
	try {
		var result = body();
	} catch(e) {
		return recover(e);
	}
	if (result && result.then) {
		return result.then(void 0, recover);
	}
	return result;
}

/**
 * MongoDB related operations.
 */

var MongoDb = /*#__PURE__*/function () {
  function MongoDb() {}

  /**
   * Test if a MongoDB service is running at the specified url.
   */
  MongoDb.isServerAvailable = function isServerAvailable(serverUrl) {
    try {
      var _exit2 = false;

      var _temp2 = _catch(function () {
        return Promise.resolve(mongodb.MongoClient.connect(serverUrl, {
          useUnifiedTopology: true,
          useNewUrlParser: true
        })).then(function (client) {
          return Promise.resolve(client.close()).then(function () {});
        });
      }, function (error) {
        console.log('Mongoclient connect error: ' + error);
        _exit2 = true;
        return false;
      });

      return Promise.resolve(_temp2 && _temp2.then ? _temp2.then(function (_result) {
        return _exit2 ? _result : true;
      }) : _exit2 ? _temp2 : true);
    } catch (e) {
      return Promise.reject(e);
    }
  };

  MongoDb.resetDatabase = function resetDatabase(serverUrl, databaseName) {
    try {
      return Promise.resolve(_catch(function () {
        return Promise.resolve(mongodb.MongoClient.connect(serverUrl, {
          useUnifiedTopology: true,
          useNewUrlParser: true
        })).then(function (client) {
          return Promise.resolve(client.db(databaseName)).then(function (db) {
            return Promise.resolve(db.dropDatabase()).then(function (res) {
              return Promise.resolve(client.close()).then(function () {
                return res;
              });
            });
          });
        });
      }, function (error) {
        console.log('Mongoclient connect error: ' + error);
        return false;
      }));
    } catch (e) {
      return Promise.reject(e);
    }
  };

  MongoDb.createCollectionIfNotExist = function createCollectionIfNotExist(db, collectionName) {
    try {
      // Get the names of existing collections.
      return Promise.resolve(db.collections()).then(function (collections) {
        var collectionNames = collections.map(function (collection) {
          return collection.collectionName;
        });
        var collectionExists = collectionNames.find(function (c) {
          return c === collectionName;
        }); // If the collection exists, use it; else create it then use it.

        var collection;

        var _temp3 = function () {
          if (collectionExists) {
            console.info("Reusing existing collection " + collectionName);
            collection = db.collection(collectionName);
          } else {
            console.info("Creating new collection " + collectionName);
            return Promise.resolve(db.createCollection(collectionName)).then(function (_db$createCollection) {
              collection = _db$createCollection;
            });
          }
        }();

        return _temp3 && _temp3.then ? _temp3.then(function () {
          return collection;
        }) : collection;
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  return MongoDb;
}();

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

/*
 * The code in this file originated from
 * @see https://github.com/decentralized-identity/sidetree
 * For the list of changes that was made to the original code
 * @see https://github.com/transmute-industries/sidetree.js/blob/master/reference-implementation-changes.md
 *
 * Copyright 2020 - Transmute Industries Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var MongoDbBase = /*#__PURE__*/function () {
  function MongoDbBase(serverUrl, databaseName) {
    this.serverUrl = serverUrl;
    this.databaseName = databaseName;
  }

  var _proto = MongoDbBase.prototype;

  _proto.close = function close() {
    try {
      var _this2 = this;

      return Promise.resolve(_this2.client.close());
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.clearCollection = function clearCollection() {
    try {
      var _this4 = this;

      return Promise.resolve(_this4.collection.deleteMany({})).then(function () {});
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.initialize = function initialize() {
    try {
      var _temp2 = function _temp2(_MongoClient$connect) {
        _this6.client = _MongoClient$connect;
        // `useNewUrlParser` addresses nodejs's URL parser deprecation warning.
        _this6.db = _this6.client.db(_this6.databaseName);
        return Promise.resolve(MongoDb.createCollectionIfNotExist(_this6.db, _this6.collectionName)).then(function (_MongoDb$createCollec) {
          _this6.collection = _MongoDb$createCollec;
        });
      };

      var _this6 = this;

      var _this5$client2 = _this6.client;
      return Promise.resolve(_this5$client2 ? _temp2(_this5$client2) : Promise.resolve(mongodb.MongoClient.connect(_this6.serverUrl, {
        useUnifiedTopology: true,
        useNewUrlParser: true
      })).then(_temp2));
    } catch (e) {
      return Promise.reject(e);
    }
  };

  return MongoDbBase;
}();

var MongoDbCasCache = /*#__PURE__*/function (_MongoDbBase) {
  _inheritsLoose(MongoDbCasCache, _MongoDbBase);

  function MongoDbCasCache() {
    var _this;

    _this = _MongoDbBase.apply(this, arguments) || this;
    _this.collectionName = 'cas-cache';
    return _this;
  }

  var _proto = MongoDbCasCache.prototype;

  _proto.initialize = function initialize() {
    try {
      var _this3 = this;

      return Promise.resolve(_MongoDbBase.prototype.initialize.call(_this3)).then(function () {
        return Promise.resolve(_this3.collection.createIndex({
          hash: 1
        }, {
          unique: true
        })).then(function () {});
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.read = function read(hash) {
    try {
      var _this5 = this;

      return Promise.resolve(_this5.collection.find({
        hash: hash
      }).limit(1).toArray()).then(function (operations) {
        if (operations.length === 1) {
          var operation = operations.pop();
          return {
            code: common.FetchResultCode.Success,
            content: operation.content.buffer
          };
        }

        return {
          code: common.FetchResultCode.NotFound
        };
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.write = function write(hash, content) {
    try {
      var _this7 = this;

      return Promise.resolve(_catch(function () {
        return Promise.resolve(_this7.collection.insertOne({
          hash: hash,
          content: content
        })).then(function () {});
      }, function (error) {
        if (error.code !== 11000) {
          throw error;
        }
      }));
    } catch (e) {
      return Promise.reject(e);
    }
  };

  return MongoDbCasCache;
}(MongoDbBase);

/**
 * Operation queue used by the Batch Writer implemented using MongoDB.
 */

var MongoDbOperationQueue = /*#__PURE__*/function (_MongoDbBase) {
  _inheritsLoose(MongoDbOperationQueue, _MongoDbBase);

  function MongoDbOperationQueue() {
    var _this;

    _this = _MongoDbBase.apply(this, arguments) || this;
    _this.collectionName = 'queued-operations';
    return _this;
  }

  var _proto = MongoDbOperationQueue.prototype;

  _proto.initialize = function initialize() {
    try {
      var _this3 = this;

      return Promise.resolve(_MongoDbBase.prototype.initialize.call(_this3)).then(function () {
        return Promise.resolve(_this3.collection.createIndex({
          didUniqueSuffix: 1
        }, {
          unique: true
        })).then(function () {});
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.enqueue = function enqueue(didUniqueSuffix, operationBuffer) {
    try {
      var _this5 = this;

      return Promise.resolve(_catch(function () {
        var queuedOperation = {
          didUniqueSuffix: didUniqueSuffix,
          operationBufferBsonBinary: new mongodb.Binary(operationBuffer)
        };
        return Promise.resolve(_this5.collection.insertOne(queuedOperation)).then(function () {});
      }, function (error) {
        // Duplicate insert errors (error code 11000).
        if (error.code === 11000) {
          throw new common.SidetreeError(common.ErrorCode.BatchWriterAlreadyHasOperationForDid);
        }

        throw error;
      }));
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.dequeue = function dequeue(count) {
    try {
      var _this7 = this;

      if (count <= 0) {
        return Promise.resolve([]);
      }

      return Promise.resolve(_this7.collection.find().sort({
        _id: 1
      }).limit(count).toArray()).then(function (queuedOperations) {
        var lastOperation = queuedOperations[queuedOperations.length - 1];
        return Promise.resolve(_this7.collection.deleteMany({
          _id: {
            $lte: lastOperation._id
          }
        })).then(function () {
          return queuedOperations.map(function (operation) {
            return MongoDbOperationQueue.convertToQueuedOperationModel(operation);
          });
        });
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.peek = function peek(count) {
    try {
      var _this9 = this;

      if (count <= 0) {
        return Promise.resolve([]);
      } // NOTE: `_id` is the default index that is sorted based by create time.


      return Promise.resolve(_this9.collection.find().sort({
        _id: 1
      }).limit(count).toArray()).then(function (queuedOperations) {
        return queuedOperations.map(function (operation) {
          return MongoDbOperationQueue.convertToQueuedOperationModel(operation);
        });
      });
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * Checks to see if the queue already contains an operation for the given DID unique suffix.
   */
  ;

  _proto.contains = function contains(didUniqueSuffix) {
    try {
      var _this11 = this;

      return Promise.resolve(_this11.collection.find({
        didUniqueSuffix: didUniqueSuffix
      }).limit(1).toArray()).then(function (operations) {
        return operations.length > 0;
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  MongoDbOperationQueue.convertToQueuedOperationModel = function convertToQueuedOperationModel(mongoQueuedOperation) {
    return {
      didUniqueSuffix: mongoQueuedOperation.didUniqueSuffix,
      operationBuffer: mongoQueuedOperation.operationBufferBsonBinary.buffer
    };
  };

  return MongoDbOperationQueue;
}(MongoDbBase);

/**
 * Implementation of ITransactionStore that stores the transaction data in a MongoDB database.
 */

var MongoDbTransactionStore = /*#__PURE__*/function (_MongoDbBase) {
  _inheritsLoose(MongoDbTransactionStore, _MongoDbBase);

  function MongoDbTransactionStore() {
    var _this;

    _this = _MongoDbBase.apply(this, arguments) || this;
    _this.collectionName = 'transactions';
    return _this;
  }

  var _proto = MongoDbTransactionStore.prototype;

  _proto.initialize = function initialize() {
    try {
      var _this3 = this;

      return Promise.resolve(_MongoDbBase.prototype.initialize.call(_this3)).then(function () {
        return Promise.resolve(_this3.collection.createIndex({
          transactionNumber: 1
        }, {
          unique: true
        })).then(function () {});
      });
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * Returns the number of transactions in the store.
   * Mainly used by tests.
   */
  ;

  _proto.getTransactionsCount = function getTransactionsCount() {
    try {
      var _this5 = this;

      return Promise.resolve(_this5.collection.countDocuments());
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.getTransaction = function getTransaction(transactionNumber) {
    try {
      var _this7 = this;

      return Promise.resolve(_this7.collection.find({
        transactionNumber: mongodb.Long.fromNumber(transactionNumber)
      }).toArray()).then(function (transactions) {
        if (transactions.length === 0) {
          return undefined;
        }

        var transaction = transactions[0];
        return transaction;
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.getTransactionsLaterThan = function getTransactionsLaterThan(transactionNumber, max) {
    try {
      var _this9 = this;

      var transactions = [];

      var _temp2 = _catch(function () {
        var dbCursor; // If given `undefined`, return transactions from the start.

        if (transactionNumber === undefined) {
          dbCursor = _this9.collection.find();
        } else {
          dbCursor = _this9.collection.find({
            transactionNumber: {
              $gt: mongodb.Long.fromNumber(transactionNumber)
            }
          });
        } // If a limit is defined then set it.


        if (max) {
          dbCursor = dbCursor.limit(max);
        } // Sort the output


        dbCursor = dbCursor.sort({
          transactionNumber: 1
        }); // Fetch the transactions

        return Promise.resolve(dbCursor.toArray()).then(function (_dbCursor$toArray) {
          transactions = _dbCursor$toArray;
        });
      }, function (error) {
        console.error(error);
      });

      return Promise.resolve(_temp2 && _temp2.then ? _temp2.then(function () {
        return transactions;
      }) : transactions);
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.addTransaction = function addTransaction(transaction) {
    try {
      var _this11 = this;

      return Promise.resolve(_catch(function () {
        var transactionInMongoDb = {
          anchorString: transaction.anchorString,
          // NOTE: MUST force `transactionNumber` to be Int64 in MongoDB.
          transactionNumber: mongodb.Long.fromNumber(transaction.transactionNumber),
          transactionTime: transaction.transactionTime,
          transactionTimeHash: transaction.transactionTimeHash,
          transactionFeePaid: transaction.transactionFeePaid,
          normalizedTransactionFee: transaction.normalizedTransactionFee,
          writer: transaction.writer
        };
        return Promise.resolve(_this11.collection.insertOne(transactionInMongoDb)).then(function () {});
      }, function (error) {
        if (error.code !== 11000) {
          throw error;
        }
      }));
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.getLastTransaction = function getLastTransaction() {
    try {
      var _this13 = this;

      return Promise.resolve(_this13.collection.find().limit(1).sort({
        transactionNumber: -1
      }).toArray()).then(function (lastTransactions) {
        if (lastTransactions.length === 0) {
          return undefined;
        }

        var lastProcessedTransaction = lastTransactions[0];
        return lastProcessedTransaction;
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.getExponentiallySpacedTransactions = function getExponentiallySpacedTransactions() {
    try {
      var _this15 = this;

      var exponentiallySpacedTransactions = [];
      return Promise.resolve(_this15.collection.find().sort({
        transactionNumber: 1
      }).toArray()).then(function (allTransactions) {
        var index = allTransactions.length - 1;
        var distance = 1;

        while (index >= 0) {
          exponentiallySpacedTransactions.push(allTransactions[index]);
          index -= distance;
          distance *= 2;
        }

        return exponentiallySpacedTransactions;
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.removeTransactionsLaterThan = function removeTransactionsLaterThan(transactionNumber) {
    try {
      var _temp5 = function _temp5(_result2) {
        return _exit2 ? _result2 : Promise.resolve(_this17.collection.deleteMany({
          transactionNumber: {
            $gt: mongodb.Long.fromNumber(transactionNumber)
          }
        })).then(function () {});
      };

      var _exit2 = false;

      var _this17 = this;

      var _temp6 = function () {
        if (transactionNumber === undefined) {
          return Promise.resolve(_this17.clearCollection()).then(function () {
            _exit2 = true;
          });
        }
      }();

      // If given `undefined`, remove all transactions.
      return Promise.resolve(_temp6 && _temp6.then ? _temp6.then(_temp5) : _temp5(_temp6));
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * Gets the list of processed transactions.
   * Mainly used for test purposes.
   */
  ;

  _proto.getTransactions = function getTransactions() {
    try {
      var _this19 = this;

      return Promise.resolve(_this19.collection.find().sort({
        transactionNumber: 1
      }).toArray());
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * Gets a list of transactions between the bounds of transaction time. The smaller value will be inclusive while the bigger be exclusive
   * @param inclusiveBeginTransactionTime The first transaction time to begin querying for
   * @param exclusiveEndTransactionTime The transaction time to stop querying for
   */
  ;

  _proto.getTransactionsStartingFrom = function getTransactionsStartingFrom(inclusiveBeginTransactionTime, exclusiveEndTransactionTime) {
    try {
      var _this21 = this;

      var cursor;

      if (inclusiveBeginTransactionTime === exclusiveEndTransactionTime) {
        // if begin === end, query for 1 transaction time
        cursor = _this21.collection.find({
          transactionTime: {
            $eq: mongodb.Long.fromNumber(inclusiveBeginTransactionTime)
          }
        });
      } else {
        cursor = _this21.collection.find({
          $and: [{
            transactionTime: {
              $gte: mongodb.Long.fromNumber(inclusiveBeginTransactionTime)
            }
          }, {
            transactionTime: {
              $lt: mongodb.Long.fromNumber(exclusiveEndTransactionTime)
            }
          }]
        });
      }

      return Promise.resolve(cursor.sort({
        transactionNumber: 1
      }).toArray());
    } catch (e) {
      return Promise.reject(e);
    }
  };

  return MongoDbTransactionStore;
}(MongoDbBase);

/**
 * Implementation of `IIUnresolvableTransactionStore` that stores the transaction data in a MongoDB database.
 */

var MongoDbUnresolvableTransactionStore = /*#__PURE__*/function (_MongoDbBase) {
  _inheritsLoose(MongoDbUnresolvableTransactionStore, _MongoDbBase);

  /**
   * Constructs a `MongoDbUnresolvableTransactionStore`;
   * @param retryExponentialDelayFactor
   *   The exponential delay factor in milliseconds for retries of unresolvable transactions.
   *   e.g. if it is set to 1 seconds, then the delays for retries will be 1 second, 2 seconds, 4 seconds... until the transaction can be resolved.
   */
  function MongoDbUnresolvableTransactionStore(serverUrl, databaseName, retryExponentialDelayFactor) {
    var _this;

    _this = _MongoDbBase.call(this, serverUrl, databaseName) || this;
    _this.collectionName = 'unresolvable-transactions';
    _this.exponentialDelayFactorInMilliseconds = 60000;
    _this.maximumUnresolvableTransactionReturnCount = 100;

    if (retryExponentialDelayFactor !== undefined) {
      _this.exponentialDelayFactorInMilliseconds = retryExponentialDelayFactor;
    }

    return _this;
  }

  var _proto = MongoDbUnresolvableTransactionStore.prototype;

  _proto.initialize = function initialize() {
    try {
      var _this3 = this;

      return Promise.resolve(_MongoDbBase.prototype.initialize.call(_this3)).then(function () {
        return Promise.resolve(_this3.collection.createIndex({
          transactionTime: 1,
          transactionNumber: 1
        }, {
          unique: true
        })).then(function () {
          return Promise.resolve(_this3.collection.createIndex({
            nextRetryTime: 1
          })).then(function () {});
        });
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.recordUnresolvableTransactionFetchAttempt = function recordUnresolvableTransactionFetchAttempt(transaction) {
    try {
      var _this5 = this;

      // Try to get the unresolvable transaction from store.
      var transactionTime = transaction.transactionTime;
      var transactionNumber = transaction.transactionNumber;
      var searchFilter = {
        transactionTime: transactionTime,
        transactionNumber: mongodb.Long.fromNumber(transactionNumber)
      };
      return Promise.resolve(_this5.collection.find(searchFilter).toArray()).then(function (findResults) {
        var unresolvableTransaction;

        if (findResults && findResults.length > 0) {
          unresolvableTransaction = findResults[0];
        } // If unresolvable transaction not found in store, insert a new one; else update the info on retry attempts.


        var _temp = function () {
          if (unresolvableTransaction === undefined) {
            var newUnresolvableTransaction = {
              transactionTime: transactionTime,
              transactionNumber: mongodb.Long.fromNumber(transactionNumber),
              anchorString: transaction.anchorString,
              transactionTimeHash: transaction.transactionTimeHash,
              firstFetchTime: Date.now(),
              retryAttempts: 0,
              nextRetryTime: Date.now()
            };
            return Promise.resolve(_this5.collection.insertOne(newUnresolvableTransaction)).then(function () {});
          } else {
            var retryAttempts = unresolvableTransaction.retryAttempts + 1; // Exponentially delay the retry the more attempts are done in the past.

            var anchorString = transaction.anchorString;

            var requiredElapsedTimeSinceFirstFetchBeforeNextRetry = Math.pow(2, unresolvableTransaction.retryAttempts) * _this5.exponentialDelayFactorInMilliseconds;

            var requiredElapsedTimeInSeconds = requiredElapsedTimeSinceFirstFetchBeforeNextRetry / 1000;
            console.info("Record transaction " + transactionNumber + " with anchor string " + anchorString + " to retry after " + requiredElapsedTimeInSeconds + " seconds.");
            var nextRetryTime = unresolvableTransaction.firstFetchTime + requiredElapsedTimeSinceFirstFetchBeforeNextRetry;
            var _searchFilter = {
              transactionTime: transactionTime,
              transactionNumber: mongodb.Long.fromNumber(transactionNumber)
            };
            return Promise.resolve(_this5.collection.updateOne(_searchFilter, {
              $set: {
                retryAttempts: retryAttempts,
                nextRetryTime: nextRetryTime
              }
            })).then(function () {});
          }
        }();

        if (_temp && _temp.then) return _temp.then(function () {});
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.removeUnresolvableTransaction = function removeUnresolvableTransaction(transaction) {
    try {
      var _this7 = this;

      var transactionTime = transaction.transactionTime;
      var transactionNumber = transaction.transactionNumber;
      return Promise.resolve(_this7.collection.deleteOne({
        transactionTime: transactionTime,
        transactionNumber: mongodb.Long.fromNumber(transactionNumber)
      })).then(function () {});
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.getUnresolvableTransactionsDueForRetry = function getUnresolvableTransactionsDueForRetry(maximumReturnCount) {
    try {
      var _this9 = this;

      // Override the return count if it is specified.
      var returnCount = _this9.maximumUnresolvableTransactionReturnCount;

      if (maximumReturnCount !== undefined) {
        returnCount = maximumReturnCount;
      }

      var now = Date.now();
      return Promise.resolve(_this9.collection.find({
        nextRetryTime: {
          $lte: now
        }
      }).sort({
        nextRetryTime: 1
      }).limit(returnCount).toArray());
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.removeUnresolvableTransactionsLaterThan = function removeUnresolvableTransactionsLaterThan(transactionNumber) {
    try {
      var _temp4 = function _temp4(_result) {
        return _exit2 ? _result : Promise.resolve(_this11.collection.deleteMany({
          transactionNumber: {
            $gt: mongodb.Long.fromNumber(transactionNumber)
          }
        })).then(function () {});
      };

      var _exit2 = false;

      var _this11 = this;

      var _temp5 = function () {
        if (transactionNumber === undefined) {
          return Promise.resolve(_this11.clearCollection()).then(function () {
            _exit2 = true;
          });
        }
      }();

      // If given `undefined`, remove all transactions.
      return Promise.resolve(_temp5 && _temp5.then ? _temp5.then(_temp4) : _temp4(_temp5));
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * Gets the list of unresolvable transactions.
   * Mainly used for test purposes.
   */
  ;

  _proto.getUnresolvableTransactions = function getUnresolvableTransactions() {
    try {
      var _this13 = this;

      return Promise.resolve(_this13.collection.find().sort({
        transactionTime: 1,
        transactionNumber: 1
      }).toArray());
    } catch (e) {
      return Promise.reject(e);
    }
  };

  return MongoDbUnresolvableTransactionStore;
}(MongoDbBase);

/*
 * The code in this file originated from
 * @see https://github.com/decentralized-identity/sidetree
 * For the list of changes that was made to the original code
 * @see https://github.com/transmute-industries/sidetree.js/blob/master/reference-implementation-changes.md
 *
 * Copyright 2020 - Transmute Industries Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var Operation = function Operation(didUniqueSuffix, type, operationBuffer, transactionTime, transactionNumber, operationIndex) {
  this.didUniqueSuffix = didUniqueSuffix;
  this.type = type;
  this.operationBuffer = operationBuffer;
  this.transactionTime = transactionTime;
  this.transactionNumber = transactionNumber;
  this.operationIndex = operationIndex;
};

tslib.__decorate([typeorm.PrimaryColumn(), typeorm.ObjectIdColumn(), tslib.__metadata("design:type", String)], Operation.prototype, "_id", void 0);

tslib.__decorate([typeorm.Column(), tslib.__metadata("design:type", String)], Operation.prototype, "didUniqueSuffix", void 0);

tslib.__decorate([typeorm.Column(), tslib.__metadata("design:type", String)], Operation.prototype, "type", void 0);

tslib.__decorate([typeorm.Column(), tslib.__metadata("design:type", Buffer)], Operation.prototype, "operationBuffer", void 0);

tslib.__decorate([typeorm.Column(), tslib.__metadata("design:type", Number)], Operation.prototype, "transactionTime", void 0);

tslib.__decorate([typeorm.Column(), tslib.__metadata("design:type", Number)], Operation.prototype, "transactionNumber", void 0);

tslib.__decorate([typeorm.Column(), tslib.__metadata("design:type", Number)], Operation.prototype, "operationIndex", void 0);

Operation = /*#__PURE__*/tslib.__decorate([/*#__PURE__*/typeorm.Entity(), /*#__PURE__*/tslib.__metadata("design:paramtypes", [String, String, Buffer, Number, Number, Number])], Operation);
var Operation$1 = Operation;

var OperationStore = /*#__PURE__*/function () {
  function OperationStore(serverUrl, databaseName) {
    this.serverUrl = serverUrl;
    this.databaseName = databaseName ? databaseName : 'sidetree';
  }

  var _proto = OperationStore.prototype;

  _proto.initialize = function initialize() {
    try {
      var _this2 = this;

      return Promise.resolve(typeorm.createConnection({
        // Typeorm does not allow two connections to have the same name
        // So we use a different name everytime in order to have parallel connections
        name: "" + Date.now(),
        type: 'mongodb',
        useNewUrlParser: true,
        useUnifiedTopology: true,
        url: "" + _this2.serverUrl + _this2.databaseName,
        entities: [Operation$1]
      })).then(function (connection) {
        _this2.connection = connection;
        _this2.repo = connection.getMongoRepository(Operation$1);
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.close = function close() {
    try {
      var _this4 = this;

      return Promise.resolve(_this4.connection.close());
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.put = function put(operations) {
    try {
      var _temp4 = function _temp4() {
        var _temp = function () {
          if (onlyNewElements.length > 0) {
            return Promise.resolve(_this6.repo.insertMany(onlyNewElements)).then(function () {});
          }
        }();

        if (_temp && _temp.then) return _temp.then(function () {});
      };

      var _this6 = this;

      // Remove duplicates (same operationIndex) from the operations array
      var operationsWithoutDuplicates = operations.reduce(function (opsWithoutDuplicates, operation) {
        var exists = opsWithoutDuplicates.find(function (op) {
          return op.operationIndex === operation.operationIndex;
        });

        if (exists) {
          return opsWithoutDuplicates;
        } else {
          return [].concat(opsWithoutDuplicates, [operation]);
        }
      }, []); // Only insert new elements

      var onlyNewElements = [];

      var _temp5 = _forOf(operationsWithoutDuplicates, function (operation) {
        var anchoredOperation = operation;
        return Promise.resolve(_this6.get(anchoredOperation.didUniqueSuffix)).then(function (res) {
          var isDuplicated = res.find(function (op) {
            return op.operationIndex === anchoredOperation.operationIndex && op.transactionNumber === anchoredOperation.transactionNumber;
          });

          if (!isDuplicated) {
            onlyNewElements.push(anchoredOperation);
          }
        });
      });

      return Promise.resolve(_temp5 && _temp5.then ? _temp5.then(_temp4) : _temp4(_temp5));
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.get = function get(didUniqueSuffix) {
    try {
      var _this8 = this;

      return Promise.resolve(_this8.repo.find({
        didUniqueSuffix: didUniqueSuffix
      })).then(function (results) {
        // Ensure operations are sorted by increasing order of operationIndex
        results.sort(function (op1, op2) {
          return op1.operationIndex - op2.operationIndex;
        });
        return results;
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto["delete"] = function _delete(transactionNumber) {
    try {
      var _this10 = this;

      var _temp7 = function () {
        if (transactionNumber) {
          return Promise.resolve(_this10.repo.deleteMany({
            transactionNumber: {
              $gt: transactionNumber
            }
          })).then(function () {});
        } else {
          return Promise.resolve(_this10.repo.deleteMany({})).then(function () {});
        }
      }();

      return Promise.resolve(_temp7 && _temp7.then ? _temp7.then(function () {}) : void 0);
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.deleteUpdatesEarlierThan = function deleteUpdatesEarlierThan(didUniqueSuffix, transactionNumber, operationIndex) {
    try {
      var _this12 = this;

      return Promise.resolve(_this12.repo.deleteMany({
        $or: [{
          didUniqueSuffix: didUniqueSuffix,
          transactionNumber: {
            $lt: transactionNumber
          },
          type: common.OperationType.Update
        }, {
          didUniqueSuffix: didUniqueSuffix,
          transactionNumber: transactionNumber,
          operationIndex: {
            $lt: operationIndex
          },
          type: common.OperationType.Update
        }]
      })).then(function () {});
    } catch (e) {
      return Promise.reject(e);
    }
  };

  return OperationStore;
}();

exports.MongoDb = MongoDb;
exports.MongoDbCasCache = MongoDbCasCache;
exports.MongoDbOperationQueue = MongoDbOperationQueue;
exports.MongoDbTransactionStore = MongoDbTransactionStore;
exports.MongoDbUnresolvableTransactionStore = MongoDbUnresolvableTransactionStore;
exports.OperationStore = OperationStore;
//# sourceMappingURL=db.cjs.development.js.map
