'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var common = require('@sidetree/common');
var core = require('@sidetree/core');
var cas = require('@sidetree/cas');
var db = require('@sidetree/db');

/*
 * Copyright 2020 - Transmute Industries Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * The core class that is instantiated when running a Sidetree node.
 */

var DidMethod = /*#__PURE__*/function () {
  function DidMethod(config, protocolVersions, blockchain) {
    var _this = this;

    /**
     * The function that starts periodically anchoring operation batches to blockchain.
     */
    this.startPeriodicCachedBlockchainTimeRefresh = function () {
      setInterval(function () {
        try {
          return Promise.resolve(_this.blockchain.getLatestTime());
        } catch (e) {
          return Promise.reject(e);
        }
      }, DidMethod.cachedBlockchainTimeRefreshInSeconds * 1000);
    }; // Component dependency construction & injection.


    this.versionManager = new core.VersionManager(config, protocolVersions); // `VersionManager` is first constructed component.

    this.operationStore = new db.OperationStore(config.mongoDbConnectionString, config.databaseName);
    this.blockchain = blockchain;
    this.cas = new cas.IpfsCasWithCache(config.contentAddressableStoreServiceUri, config.mongoDbConnectionString, config.databaseName);
    this.downloadManager = new core.DownloadManager(config.maxConcurrentDownloads, this.cas);
    this.resolver = new core.Resolver(this.versionManager, this.operationStore);
    this.batchScheduler = new core.BatchScheduler(this.versionManager, this.blockchain, config.batchingIntervalInSeconds);
    this.transactionStore = new db.MongoDbTransactionStore(config.mongoDbConnectionString, config.databaseName);
    this.unresolvableTransactionStore = new db.MongoDbUnresolvableTransactionStore(config.mongoDbConnectionString, config.databaseName);
    this.observer = new core.Observer(this.versionManager, this.blockchain, config.maxConcurrentDownloads, this.operationStore, this.transactionStore, this.unresolvableTransactionStore, config.observingIntervalInSeconds);
    this.serviceInfo = new core.ServiceInfo('core');
  }
  /**
   * The initialization method that must be called before consumption of this core object.
   * The method starts the Observer and Batch Writer.
   */


  var _proto = DidMethod.prototype;

  _proto.initialize = function initialize(startObserver, startBatchWriter) {
    if (startObserver === void 0) {
      startObserver = true;
    }

    if (startBatchWriter === void 0) {
      startBatchWriter = true;
    }

    try {
      var _this3 = this;

      return Promise.resolve(_this3.transactionStore.initialize()).then(function () {
        return Promise.resolve(_this3.unresolvableTransactionStore.initialize()).then(function () {
          return Promise.resolve(_this3.operationStore.initialize()).then(function () {
            return Promise.resolve(_this3.blockchain.initialize()).then(function () {
              return Promise.resolve(_this3.cas.initialize()).then(function () {
                return Promise.resolve(_this3.versionManager.initialize(_this3.blockchain, _this3.cas, _this3.downloadManager, _this3.operationStore, _this3.resolver, _this3.transactionStore)).then(function () {
                  function _temp2() {
                    if (startBatchWriter) {
                      _this3.batchScheduler.startPeriodicBatchWriting();
                    }

                    _this3.startPeriodicCachedBlockchainTimeRefresh();

                    _this3.downloadManager.start();
                  }

                  var _temp = function () {
                    if (startObserver) {
                      return Promise.resolve(_this3.observer.startPeriodicProcessing()).then(function () {});
                    }
                  }();

                  // `VersionManager` is last initialized component.
                  return _temp && _temp.then ? _temp.then(_temp2) : _temp2(_temp);
                });
              });
            });
          });
        });
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.triggerBatchWriting = function triggerBatchWriting() {
    try {
      var _this5 = this;

      return Promise.resolve(_this5.batchScheduler.writeOperationBatch()).then(function () {});
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.triggerProcessTransactions = function triggerProcessTransactions() {
    try {
      var _this7 = this;

      // By passing true, we force the observer to wait for all transactions
      // to be downloaded before returning. We need that for testing
      return Promise.resolve(_this7.observer.refreshLastKnownTransaction()).then(function () {
        return Promise.resolve(_this7.observer.processTransactions(true)).then(function () {});
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.triggerBatchAndObserve = function triggerBatchAndObserve() {
    try {
      var _this9 = this;

      return Promise.resolve(_this9.triggerBatchWriting()).then(function () {
        return Promise.resolve(_this9.triggerProcessTransactions()).then(function () {});
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.close = function close() {
    try {
      var _temp5 = function _temp5() {
        return Promise.resolve(_this11.transactionStore.close()).then(function () {
          return Promise.resolve(_this11.unresolvableTransactionStore.close()).then(function () {
            return Promise.resolve(_this11.operationStore.close()).then(function () {
              return Promise.resolve(_this11.observer.stopPeriodicProcessing()).then(function () {
                return Promise.resolve(_this11.cas.close()).then(function () {
                  _this11.batchScheduler.stopPeriodicBatchWriting();
                });
              });
            });
          });
        });
      };

      var _this11 = this;

      var currentTime = _this11.blockchain.approximateTime;

      var operationQueue = _this11.versionManager.getOperationQueue(currentTime.time);

      var _temp6 = function () {
        if (operationQueue) {
          return Promise.resolve(operationQueue.close()).then(function () {});
        }
      }();

      return Promise.resolve(_temp6 && _temp6.then ? _temp6.then(_temp5) : _temp5(_temp6));
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * Handles an operation request.
   */
  ;

  _proto.handleOperationRequest = function handleOperationRequest(request) {
    try {
      var _this13 = this;

      var currentTime = _this13.blockchain.approximateTime;

      var requestHandler = _this13.versionManager.getRequestHandler(currentTime.time);

      var response = requestHandler.handleOperationRequest(request);
      return Promise.resolve(response);
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * Handles resolve operation.
   * @param didOrDidDocument Can either be:
   *   1. Fully qualified DID. e.g. 'did:sidetree:abc' or
   *   2. An encoded DID Document prefixed by the DID method name. e.g. 'did:sidetree:<encoded-DID-Document>'.
   */
  ;

  _proto.handleResolveRequest = function handleResolveRequest(didOrDidDocument) {
    try {
      var _this15 = this;

      var currentTime = _this15.blockchain.approximateTime;

      var requestHandler = _this15.versionManager.getRequestHandler(currentTime.time);

      var response = requestHandler.handleResolveRequest(didOrDidDocument);
      return Promise.resolve(response);
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * Handles the get version request. It gets the versions from the dependent services
   * as well.
   */
  ;

  _proto.handleGetVersionRequest = function handleGetVersionRequest() {
    try {
      var _this17 = this;

      var _this16$serviceInfo$g2 = _this17.serviceInfo.getServiceVersion();

      return Promise.resolve(_this17.blockchain.getServiceVersion()).then(function (_this16$blockchain$ge) {
        return Promise.resolve(_this17.cas.getServiceVersion()).then(function (_this16$cas$getServic) {
          var responses = [_this16$serviceInfo$g2, _this16$blockchain$ge, _this16$cas$getServic];
          return {
            status: common.ResponseStatus.Succeeded,
            body: JSON.stringify(responses)
          };
        });
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  return DidMethod;
}();
DidMethod.cachedBlockchainTimeRefreshInSeconds = 60;

exports.DidMethod = DidMethod;
//# sourceMappingURL=did-method.cjs.development.js.map
