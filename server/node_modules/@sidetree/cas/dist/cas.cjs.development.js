'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var common = require('@sidetree/common');
var ipfsClient = _interopDefault(require('ipfs-http-client'));
var concat = _interopDefault(require('it-concat'));
var db = require('@sidetree/db');
var Unixfs = _interopDefault(require('ipfs-unixfs'));
var ipldDagPb = require('ipld-dag-pb');

// A type of promise-like that resolves synchronously and supports only one observer

const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== "undefined" ? (Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator"))) : "@@iterator";

const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== "undefined" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol("Symbol.asyncIterator"))) : "@@asyncIterator";

// Asynchronously call a function and send errors to recovery continuation
function _catch(body, recover) {
	try {
		var result = body();
	} catch(e) {
		return recover(e);
	}
	if (result && result.then) {
		return result.then(void 0, recover);
	}
	return result;
}

var _require = /*#__PURE__*/require('../package.json'),
    version = _require.version;

var CasIpfs = /*#__PURE__*/function () {
  function CasIpfs(multiaddr) {
    this.getServiceVersion = function () {
      return {
        name: 'ipfs',
        version: version
      };
    };

    var parts = multiaddr.split('/');

    if (parts[1] === 'ip4') {
      this.ipfs = ipfsClient({
        host: parts[2],
        port: parts[4]
      });
    }

    if (parts[1] === 'dns4') {
      this.ipfs = ipfsClient({
        host: parts[2],
        port: parts[4],
        protocol: parts[5]
      });
    }
  }

  var _proto = CasIpfs.prototype;

  _proto.initialize = function initialize() {
    return Promise.resolve();
  };

  _proto.close = function close() {
    return Promise.resolve();
  };

  _proto.write = function write(content) {
    try {
      var _this2 = this;

      return Promise.resolve(_this2.ipfs.add(content)).then(function (source) {
        return Promise.resolve(source.next()).then(function (file) {
          return file.value.path;
        });
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.read = function read(address) {
    try {
      var _this4 = this;

      return Promise.resolve(_catch(function () {
        var source = _this4.ipfs.get(address, {
          timeout: 2000
        });

        return Promise.resolve(source.next()).then(function (file) {
          return Promise.resolve(concat(file.value.content)).then(function (bufferList) {
            var content = bufferList.copy();
            return content ? {
              code: common.FetchResultCode.Success,
              content: content
            } : {
              code: common.FetchResultCode.NotFound
            };
          });
        });
      }, function (e) {
        if (e.name === 'TimeoutError') {
          return {
            code: common.FetchResultCode.NotFound
          };
        } else {
          throw e;
        }
      }));
    } catch (e) {
      return Promise.reject(e);
    }
  };

  return CasIpfs;
}();

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

var _require$1 = /*#__PURE__*/require('../package.json'),
    version$1 = _require$1.version;

var IpfsCasWithCache = /*#__PURE__*/function (_IpfsCas) {
  _inheritsLoose(IpfsCasWithCache, _IpfsCas);

  function IpfsCasWithCache(casUrl, dbUrl, dbName) {
    var _this;

    _this = _IpfsCas.call(this, casUrl) || this;

    _this.getServiceVersion = function () {
      return {
        name: 'ipfs-with-cache',
        version: version$1
      };
    };

    _this.cache = new db.MongoDbCasCache(dbUrl, dbName);
    return _this;
  }

  var _proto = IpfsCasWithCache.prototype;

  _proto.initialize = function initialize() {
    try {
      var _this3 = this;

      return Promise.resolve(_this3.cache.initialize()).then(function () {});
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.close = function close() {
    try {
      var _this5 = this;

      return Promise.resolve(_this5.cache.close()).then(function () {});
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.write = function write(content) {
    try {
      var _this7 = this;

      return Promise.resolve(_IpfsCas.prototype.write.call(_this7, content)).then(function (hash) {
        return Promise.resolve(_this7.cache.write(hash, content)).then(function () {
          return hash;
        });
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.read = function read(address) {
    try {
      var _this9 = this;

      return Promise.resolve(_this9.cache.read(address)).then(function (cachedResult) {
        if (cachedResult.code === common.FetchResultCode.Success) {
          console.info("Returning cached content for address " + address);
          return cachedResult;
        }

        return Promise.resolve(_IpfsCas.prototype.read.call(_this9, address)).then(function (result) {
          var _temp = function () {
            if (result.code === common.FetchResultCode.Success) {
              console.info("Caching read result for " + address);
              return Promise.resolve(_this9.cache.write(address, result.content)).then(function () {});
            }
          }();

          return _temp && _temp.then ? _temp.then(function () {
            return result;
          }) : result;
        });
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  return IpfsCasWithCache;
}(CasIpfs);

/*
 * The code in this file originated from
 * @see https://github.com/decentralized-identity/sidetree
 * For the list of changes that was made to the original code
 * @see https://github.com/transmute-industries/sidetree.js/blob/master/reference-implementation-changes.md
 *
 * Copyright 2020 - Transmute Industries Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var _require$2 = /*#__PURE__*/require('../package.json'),
    version$2 = _require$2.version;
/**
 * Implementation of a CAS class for testing.
 * Simply using a hash map to store all the content by hash.
 */


var MockCas = /*#__PURE__*/function () {
  function MockCas(mockSecondsTakenForEachCasFetch) {
    /** A Map that stores the given content. */
    this.storage = new Map();
    /** Time taken in seconds for each mock fetch. */

    this.mockSecondsTakenForEachCasFetch = 0;

    if (mockSecondsTakenForEachCasFetch !== undefined) {
      this.mockSecondsTakenForEachCasFetch = mockSecondsTakenForEachCasFetch;
    }
  }

  var _proto = MockCas.prototype;

  _proto.getServiceVersion = function getServiceVersion() {
    try {
      return Promise.resolve({
        name: 'mock-cas',
        version: version$2
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.initialize = function initialize() {
    return Promise.resolve();
  };

  _proto.close = function close() {
    return Promise.resolve();
  }
  /**
   * Gets the address that can be used to access the given content.
   */
  ;

  MockCas.getAddress = function getAddress(content) {
    try {
      var unixFs = new Unixfs('file', content);
      var marshaled = unixFs.marshal();
      var dagNode = new ipldDagPb.DAGNode(marshaled);
      return Promise.resolve(dagNode.toDAGLink({
        cidVersion: 0
      })).then(function (dagLink) {
        return dagLink.Hash.toString();
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.write = function write(content) {
    try {
      var _this2 = this;

      return Promise.resolve(MockCas.getAddress(content)).then(function (encodedHash) {
        _this2.storage.set(encodedHash, content);

        return encodedHash;
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.read = function read(address) {
    try {
      var _this4 = this;

      // Wait for configured time before returning.
      return Promise.resolve(new Promise(function (resolve) {
        return setTimeout(resolve, _this4.mockSecondsTakenForEachCasFetch * 1000);
      })).then(function () {
        var content = _this4.storage.get(address);

        return content === undefined ? {
          code: common.FetchResultCode.NotFound
        } : {
          code: common.FetchResultCode.Success,
          content: content
        };
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  return MockCas;
}();

exports.IpfsCas = CasIpfs;
exports.IpfsCasWithCache = IpfsCasWithCache;
exports.MockCas = MockCas;
//# sourceMappingURL=cas.cjs.development.js.map
