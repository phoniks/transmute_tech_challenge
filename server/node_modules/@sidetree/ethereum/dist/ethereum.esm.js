import { AnchoredDataSerializer } from '@sidetree/common';
import multihashes from 'multihashes';

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

// A type of promise-like that resolves synchronously and supports only one observer

const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== "undefined" ? (Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator"))) : "@@iterator";

const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== "undefined" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol("Symbol.asyncIterator"))) : "@@asyncIterator";

// Asynchronously call a function and send errors to recovery continuation
function _catch(body, recover) {
	try {
		var result = body();
	} catch(e) {
		return recover(e);
	}
	if (result && result.then) {
		return result.then(void 0, recover);
	}
	return result;
}

var getAccounts = function getAccounts(web3) {
  return new Promise(function (resolve, reject) {
    web3.eth.getAccounts(function (err, accounts) {
      if (err) {
        reject(err);
      }

      resolve(accounts);
    });
  });
};

var bytes32EnodedMultihashToBase58EncodedMultihash = function bytes32EnodedMultihashToBase58EncodedMultihash(bytes32EncodedMultihash) {
  return multihashes.toB58String(multihashes.fromHexString("1220" + bytes32EncodedMultihash.replace('0x', '')));
};

var base58EncodedMultihashToBytes32 = function base58EncodedMultihashToBytes32(base58EncodedMultihash) {
  return "0x" + multihashes.toHexString(multihashes.fromB58String(base58EncodedMultihash)).substring(4);
};

var eventLogToSidetreeTransaction = function eventLogToSidetreeTransaction(log) {
  var anchoredData = {
    anchorFileHash: bytes32EnodedMultihashToBase58EncodedMultihash(log.args.anchorFileHash),
    numberOfOperations: Number.parseInt(log.args.numberOfOperations)
  };
  var anchorString = AnchoredDataSerializer.serialize(anchoredData);
  return {
    transactionNumber: log.args.transactionNumber.toNumber(),
    transactionTime: log.blockNumber,
    transactionHash: log.transactionHash,
    transactionTimeHash: log.blockHash,
    anchorString: anchorString,
    transactionFeePaid: 0,
    normalizedTransactionFee: 0,
    writer: 'writer'
  };
};

var getBlock = function getBlock(web3, blockHashOrBlockNumber) {
  try {
    return Promise.resolve(new Promise(function (resolve, reject) {
      web3.eth.getBlock(blockHashOrBlockNumber, function (err, b) {
        if (err) {
          reject(err);
        }

        resolve(b);
      });
    }));
  } catch (e) {
    return Promise.reject(e);
  }
};

var getBlockchainTime = function getBlockchainTime(web3, blockHashOrBlockNumber) {
  try {
    return Promise.resolve(getBlock(web3, blockHashOrBlockNumber)).then(function (block) {
      return block ? block.timestamp : null;
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

var extendSidetreeTransactionWithTimestamp = function extendSidetreeTransactionWithTimestamp(web3, txns) {
  try {
    return Promise.all(txns.map(function (txn) {
      try {
        return Promise.resolve(getBlockchainTime(web3, txn.transactionTime)).then(function (timestamp) {
          return typeof timestamp === 'number' ? _extends({}, txn, {
            transactionTimestamp: timestamp
          }) : txn;
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }));
  } catch (e) {
    return Promise.reject(e);
  }
};

var utils = {
  base58EncodedMultihashToBytes32: base58EncodedMultihashToBytes32,
  bytes32EnodedMultihashToBase58EncodedMultihash: bytes32EnodedMultihashToBase58EncodedMultihash,
  eventLogToSidetreeTransaction: eventLogToSidetreeTransaction,
  extendSidetreeTransactionWithTimestamp: extendSidetreeTransactionWithTimestamp,
  getAccounts: getAccounts,
  getBlock: getBlock,
  getBlockchainTime: getBlockchainTime
};

var _require = /*#__PURE__*/require('../package.json'),
    version = _require.version;

var contract = /*#__PURE__*/require('@truffle/contract');

var anchorContractArtifact = /*#__PURE__*/require('../build/contracts/SimpleSidetreeAnchor.json');

var EthereumLedger = /*#__PURE__*/function () {
  function EthereumLedger(web3, contractAddress, logger) {
    var _this = this,
        _this2 = this,
        _this3 = this;

    this.web3 = web3;
    this.contractAddress = contractAddress;
    this.cachedBlockchainTime = {
      hash: '',
      time: 0
    };

    this.getServiceVersion = function () {
      return {
        name: 'ethereum',
        version: version
      };
    };

    this._getTransactions = function (fromBlock, toBlock, options) {
      try {
        return Promise.resolve(_this.getInstance()).then(function (instance) {
          return Promise.resolve(instance.getPastEvents('Anchor', {
            fromBlock: fromBlock,
            toBlock: toBlock || 'latest',
            filter: options && options.filter || undefined
          })).then(function (logs) {
            var txns = logs.map(function (log) {
              return utils.eventLogToSidetreeTransaction(log);
            });
            return options && options.omitTimestamp ? txns : utils.extendSidetreeTransactionWithTimestamp(_this.web3, txns);
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    };

    this.extendSidetreeTransactionWithTimestamp = function (transactions) {
      try {
        return Promise.resolve(utils.extendSidetreeTransactionWithTimestamp(_this2.web3, transactions));
      } catch (e) {
        return Promise.reject(e);
      }
    }; // eslint-disable-next-line @typescript-eslint/no-unused-vars


    this.write = function (anchorString, _fee) {

      try {
        return Promise.resolve(utils.getAccounts(_this3.web3)).then(function (_ref) {
          var from = _ref[0];

          var instance = _this3.getInstance();

          var _AnchoredDataSerializ = AnchoredDataSerializer.deserialize(anchorString),
              anchorFileHash = _AnchoredDataSerializ.anchorFileHash,
              numberOfOperations = _AnchoredDataSerializ.numberOfOperations;

          var bytes32AnchorFileHash = utils.base58EncodedMultihashToBytes32(anchorFileHash);

          var _temp = _catch(function () {
            return Promise.resolve(instance.anchorHash(bytes32AnchorFileHash, numberOfOperations, {
              from: from
            })).then(function (txn) {
              _this3.logger.info("Ethereum transaction successful: https://ropsten.etherscan.io/tx/" + txn.tx);
            });
          }, function (err) {
            _this3.logger.error(err.message);
          });

          if (_temp && _temp.then) return _temp.then(function () {});
        });
      } catch (e) {
        return Promise.reject(e);
      }
    };

    this.logger = logger || console;
    this.anchorContract = contract(anchorContractArtifact);
    this.anchorContract.setProvider(this.web3.currentProvider);
    this.anchorContract.defaults({
      gasPrice: '100000000000'
    });
  }

  var _proto = EthereumLedger.prototype;

  _proto.initialize = function initialize() {
    try {
      var _this5 = this;

      // Set primary address
      return Promise.resolve(utils.getAccounts(_this5.web3)).then(function (_ref2) {
        var primaryAddress = _ref2[0];

        function _temp3() {
          return Promise.resolve(_this5.anchorContract.at(_this5.contractAddress)).then(function (_this4$anchorContract2) {
            _this5.instance = _this4$anchorContract2;
            // Refresh cached block time
            return Promise.resolve(_this5.getLatestTime()).then(function () {});
          });
        }

        var _temp2 = function () {
          if (!_this5.contractAddress) {
            return Promise.resolve(_this5.anchorContract["new"]({
              from: primaryAddress
            })).then(function (_this4$anchorContract) {
              _this5.instance = _this4$anchorContract;
              _this5.contractAddress = _this5.instance.address;

              _this5.logger.info("Creating new Element contract at address " + _this5.contractAddress);
            });
          } else {
            _this5.logger.info("Using Element contract at address " + _this5.contractAddress);
          }
        }();

        // Set instance
        return _temp2 && _temp2.then ? _temp2.then(_temp3) : _temp3(_temp2);
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.getInstance = function getInstance() {
    if (!this.instance) {
      throw new Error('Contract instance is undefined. Call .initialize() first');
    }

    return this.instance;
  };

  _proto.read = function read(sinceTransactionNumber, transactionTimeHash) {
    try {
      var _temp9 = function _temp9() {
        return {
          moreTransactions: false,
          transactions: transactions
        };
      };

      var _this7 = this;

      var options = {
        omitTimestamp: true
      };
      var transactions; // if(sinceTransactionNumber) does not work because 0 evaluates to false
      // but 0 is a valid value of sinceTransactionNumber...

      var _temp10 = function () {
        if (sinceTransactionNumber !== undefined) {
          return Promise.resolve(_this7._getTransactions(0, 'latest', _extends({}, options, {
            filter: {
              transactionNumber: [sinceTransactionNumber]
            }
          }))).then(function (sinceTransaction) {
            var _temp4 = function () {
              if (sinceTransaction.length === 1) {
                return Promise.resolve(_this7._getTransactions(sinceTransaction[0].transactionTime, 'latest', options)).then(function (_this6$_getTransactio) {
                  transactions = _this6$_getTransactio;
                });
              } else {
                transactions = [];
              }
            }();

            if (_temp4 && _temp4.then) return _temp4.then(function () {});
          });
        } else {
          var _temp11 = function () {
            if (transactionTimeHash) {
              return Promise.resolve(utils.getBlock(_this7.web3, transactionTimeHash)).then(function (block) {
                var _temp5 = function () {
                  if (block && block.number) {
                    return Promise.resolve(_this7._getTransactions(block.number, block.number, options)).then(function (_this6$_getTransactio2) {
                      transactions = _this6$_getTransactio2;
                    });
                  } else {
                    transactions = [];
                  }
                }();

                if (_temp5 && _temp5.then) return _temp5.then(function () {});
              });
            } else {
              return Promise.resolve(_this7._getTransactions(0, 'latest', options)).then(function (_this6$_getTransactio3) {
                transactions = _this6$_getTransactio3;
              });
            }
          }();

          if (_temp11 && _temp11.then) return _temp11.then(function () {});
        }
      }();

      return Promise.resolve(_temp10 && _temp10.then ? _temp10.then(_temp9) : _temp9(_temp10));
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.getLatestTime = function getLatestTime() {
    try {
      var _this9 = this;

      return Promise.resolve(utils.getBlock(_this9.web3, 'latest')).then(function (block) {
        var blockchainTime = {
          time: block.number,
          hash: block.hash
        };
        _this9.cachedBlockchainTime = blockchainTime;
        return blockchainTime;
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.getFirstValidTransaction = function getFirstValidTransaction( // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _transactions) {
    try {
      return Promise.resolve(undefined);
    } catch (e) {
      return Promise.reject(e);
    }
  } // eslint-disable-next-line @typescript-eslint/no-unused-vars
  ;

  _proto.getFee = function getFee(_transactionTime) {
    return Promise.resolve(0);
  };

  _proto.getValueTimeLock = function getValueTimeLock( // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _lockIdentifier) {
    return Promise.resolve(undefined);
  };

  _proto.getWriterValueTimeLock = function getWriterValueTimeLock() {
    return Promise.resolve(undefined);
  };

  _createClass(EthereumLedger, [{
    key: "approximateTime",
    get: function get() {
      return this.cachedBlockchainTime;
    }
  }]);

  return EthereumLedger;
}();

export { EthereumLedger };
//# sourceMappingURL=ethereum.esm.js.map
