import { SidetreeError, ErrorCode, protocolParameters } from '@sidetree/common';

/*
 * The code in this file originated from
 * @see https://github.com/decentralized-identity/sidetree
 * For the list of changes that was made to the original code
 * @see https://github.com/transmute-industries/sidetree.js/blob/master/reference-implementation-changes.md
 *
 * Copyright 2020 - Transmute Industries Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Encapsulates the functionality to calculate and verify the blockchain transaction fees.
 */

var FeeManager = /*#__PURE__*/function () {
  function FeeManager() {}

  /**
   * Converts the normalized fee (returned by the blockchain) into the transaction fee to be paid when writing
   * the current transaction.
   *
   * @param normalizedFee The normalized fee for the current transaction.
   * @param numberOfOperations The number of operations to write.
   * @param feeMarkupFactor Markup to be added to the calculated fee.
   *
   * @throws if the number of operations are <= 0.
   */
  FeeManager.computeMinimumTransactionFee = function computeMinimumTransactionFee(normalizedFee, numberOfOperations) {
    if (numberOfOperations <= 0) {
      throw new SidetreeError(ErrorCode.OperationCountLessThanZero, "Fee cannot be calculated for the given number of operations: " + numberOfOperations);
    }

    var feePerOperation = normalizedFee * protocolParameters.normalizedFeeToPerOperationFeeMultiplier;
    var feeForAllOperations = feePerOperation * numberOfOperations; // If our calculated-fee is lower than the normalized fee (which can happen if the number of operations is
    // very low) then the calculated-fee will be ignored by the blockchain miners ... so make sure that we
    // return at-least the normalized fee.

    var transactionFee = Math.max(feeForAllOperations, normalizedFee);
    return transactionFee;
  }
  /**
   * Verifies that the fee paid for the given transaction is valid; throws if it is not valid.
   *
   * @param transactionFeePaid The actual fee paid for that transaction.
   * @param numberOfOperations The number of operations written.
   * @param normalizedFee The normalized fee for that transaction.
   *
   * @throws if the number of operations is <= 0; if the feepaid is invalid.
   */
  ;

  FeeManager.verifyTransactionFeeAndThrowOnError = function verifyTransactionFeeAndThrowOnError(transactionFeePaid, numberOfOperations, normalizedFee) {
    // If there are no operations written then someone wrote incorrect data and we are going to throw
    if (numberOfOperations <= 0) {
      throw new SidetreeError(ErrorCode.OperationCountLessThanZero, "The number of operations: " + numberOfOperations + " must be greater than 0");
    }

    if (transactionFeePaid < normalizedFee) {
      throw new SidetreeError(ErrorCode.TransactionFeePaidLessThanNormalizedFee, "The actual fee paid: " + transactionFeePaid + " should be greater than or equal to the normalized fee: " + normalizedFee);
    }

    var actualFeePerOperation = transactionFeePaid / numberOfOperations;
    var expectedFeePerOperation = normalizedFee * protocolParameters.normalizedFeeToPerOperationFeeMultiplier;

    if (actualFeePerOperation < expectedFeePerOperation) {
      throw new SidetreeError(ErrorCode.TransactionFeePaidInvalid, "The actual fee paid: " + transactionFeePaid + " per number of operations: " + numberOfOperations + " should be at least " + expectedFeePerOperation + ".");
    }
  };

  return FeeManager;
}();

/*
 * The code in this file originated from
 * @see https://github.com/decentralized-identity/sidetree
 * For the list of changes that was made to the original code
 * @see https://github.com/transmute-industries/sidetree.js/blob/master/reference-implementation-changes.md
 *
 * Copyright 2020 - Transmute Industries Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Encapsulates the functionality to compute and verify the value time lock amounts.
 */

var ValueTimeLockVerifier = /*#__PURE__*/function () {
  function ValueTimeLockVerifier() {}

  /**
   * Calculates the maximum number of operations allowed to be written for the given lock information. If
   * there is no lock then it returns the number of operations which do not require a lock.
   *
   * @param valueTimeLock The lock object if exists
   * @param versionMetadataFetcher The mapper from transaction time to version metadata
   */
  ValueTimeLockVerifier.calculateMaxNumberOfOperationsAllowed = function calculateMaxNumberOfOperationsAllowed(valueTimeLock, versionMetadataFetcher) {
    if (valueTimeLock === undefined) {
      return protocolParameters.maxNumberOfOperationsForNoValueTimeLock;
    }

    var versionMetadata = versionMetadataFetcher.getVersionMetadata(valueTimeLock.lockTransactionTime);
    var normalizedFeeToPerOperationFeeMultiplier = versionMetadata.normalizedFeeToPerOperationFeeMultiplier;
    var valueTimeLockAmountMultiplier = versionMetadata.valueTimeLockAmountMultiplier; // Using the following formula:
    //  requiredLockAmount = normalizedfee * normalizedFeeMultipier * numberOfOps * valueTimeLockMultiplier
    //
    // We are going to find the numberOfOps given the requiredLockAmount

    var feePerOperation = valueTimeLock.normalizedFee * normalizedFeeToPerOperationFeeMultiplier;
    var numberOfOpsAllowed = valueTimeLock.amountLocked / (feePerOperation * valueTimeLockAmountMultiplier); // Make sure that we are returning an integer; rounding down to make sure that we are not going above
    // the max limit.

    var numberOfOpsAllowedInt = Math.floor(numberOfOpsAllowed); // Return at least the 'free' operations

    return Math.max(numberOfOpsAllowedInt, protocolParameters.maxNumberOfOperationsForNoValueTimeLock);
  }
  /**
   * Verifies that the value lock object (amount, transaction time range) is correct for the specified number
   * of operations.
   *
   * @param valueTimeLock The value time lock object used for verificiation.
   * @param numberOfOperations The target number of operations.
   * @param sidetreeTransactionTime The transaction time where the operations were written.
   * @param sidetreeTransactionWriter The writer of the transaction.
   * @param versionMetadataFetcher The mapper from transaction time to version metadata
   */
  ;

  ValueTimeLockVerifier.verifyLockAmountAndThrowOnError = function verifyLockAmountAndThrowOnError(valueTimeLock, numberOfOperations, sidetreeTransactionTime, sidetreeTransactionWriter, versionMetadataFetcher) {
    // If the number of written operations were under the free limit then there's nothing to check
    if (numberOfOperations <= protocolParameters.maxNumberOfOperationsForNoValueTimeLock) {
      return;
    }

    if (valueTimeLock) {
      // Check the lock owner
      if (valueTimeLock.owner !== sidetreeTransactionWriter) {
        throw new SidetreeError(ErrorCode.ValueTimeLockVerifierTransactionWriterLockOwnerMismatch, "Sidetree transaction writer: " + sidetreeTransactionWriter + " - Lock owner: " + valueTimeLock.owner);
      } // Check the lock duration


      if (sidetreeTransactionTime < valueTimeLock.lockTransactionTime || sidetreeTransactionTime >= valueTimeLock.unlockTransactionTime) {
        throw new SidetreeError(ErrorCode.ValueTimeLockVerifierTransactionTimeOutsideLockRange, // tslint:disable-next-line: max-line-length
        "Sidetree transaction block: " + sidetreeTransactionTime + "; lock start time: " + valueTimeLock.lockTransactionTime + "; unlock time: " + valueTimeLock.unlockTransactionTime);
      }
    }

    var maxNumberOfOpsAllowed = this.calculateMaxNumberOfOperationsAllowed(valueTimeLock, versionMetadataFetcher);

    if (numberOfOperations > maxNumberOfOpsAllowed) {
      throw new SidetreeError(ErrorCode.ValueTimeLockVerifierInvalidNumberOfOperations, "Max number of ops allowed: " + maxNumberOfOpsAllowed + "; actual number of ops: " + numberOfOperations);
    }
  };

  return ValueTimeLockVerifier;
}();

export { FeeManager as F, ValueTimeLockVerifier as V };
//# sourceMappingURL=ValueTimeLockVerifier-ce5b08d2.js.map
