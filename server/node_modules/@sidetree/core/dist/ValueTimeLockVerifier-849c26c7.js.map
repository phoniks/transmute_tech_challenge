{"version":3,"file":"ValueTimeLockVerifier-849c26c7.js","sources":["../src/FeeManager.ts","../src/ValueTimeLockVerifier.ts"],"sourcesContent":["/*\n * The code in this file originated from\n * @see https://github.com/decentralized-identity/sidetree\n * For the list of changes that was made to the original code\n * @see https://github.com/transmute-industries/sidetree.js/blob/master/reference-implementation-changes.md\n *\n * Copyright 2020 - Transmute Industries Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ErrorCode, protocolParameters, SidetreeError } from '@sidetree/common';\n\n/**\n * Encapsulates the functionality to calculate and verify the blockchain transaction fees.\n */\nexport default class FeeManager {\n  /**\n   * Converts the normalized fee (returned by the blockchain) into the transaction fee to be paid when writing\n   * the current transaction.\n   *\n   * @param normalizedFee The normalized fee for the current transaction.\n   * @param numberOfOperations The number of operations to write.\n   * @param feeMarkupFactor Markup to be added to the calculated fee.\n   *\n   * @throws if the number of operations are <= 0.\n   */\n  public static computeMinimumTransactionFee(\n    normalizedFee: number,\n    numberOfOperations: number\n  ): number {\n    if (numberOfOperations <= 0) {\n      throw new SidetreeError(\n        ErrorCode.OperationCountLessThanZero,\n        `Fee cannot be calculated for the given number of operations: ${numberOfOperations}`\n      );\n    }\n\n    const feePerOperation =\n      normalizedFee *\n      protocolParameters.normalizedFeeToPerOperationFeeMultiplier;\n    const feeForAllOperations = feePerOperation * numberOfOperations;\n\n    // If our calculated-fee is lower than the normalized fee (which can happen if the number of operations is\n    // very low) then the calculated-fee will be ignored by the blockchain miners ... so make sure that we\n    // return at-least the normalized fee.\n    const transactionFee = Math.max(feeForAllOperations, normalizedFee);\n\n    return transactionFee;\n  }\n\n  /**\n   * Verifies that the fee paid for the given transaction is valid; throws if it is not valid.\n   *\n   * @param transactionFeePaid The actual fee paid for that transaction.\n   * @param numberOfOperations The number of operations written.\n   * @param normalizedFee The normalized fee for that transaction.\n   *\n   * @throws if the number of operations is <= 0; if the feepaid is invalid.\n   */\n  public static verifyTransactionFeeAndThrowOnError(\n    transactionFeePaid: number,\n    numberOfOperations: number,\n    normalizedFee: number\n  ): void {\n    // If there are no operations written then someone wrote incorrect data and we are going to throw\n    if (numberOfOperations <= 0) {\n      throw new SidetreeError(\n        ErrorCode.OperationCountLessThanZero,\n        `The number of operations: ${numberOfOperations} must be greater than 0`\n      );\n    }\n\n    if (transactionFeePaid < normalizedFee) {\n      throw new SidetreeError(\n        ErrorCode.TransactionFeePaidLessThanNormalizedFee,\n        `The actual fee paid: ${transactionFeePaid} should be greater than or equal to the normalized fee: ${normalizedFee}`\n      );\n    }\n\n    const actualFeePerOperation = transactionFeePaid / numberOfOperations;\n    const expectedFeePerOperation =\n      normalizedFee *\n      protocolParameters.normalizedFeeToPerOperationFeeMultiplier;\n\n    if (actualFeePerOperation < expectedFeePerOperation) {\n      throw new SidetreeError(\n        ErrorCode.TransactionFeePaidInvalid,\n        `The actual fee paid: ${transactionFeePaid} per number of operations: ${numberOfOperations} should be at least ${expectedFeePerOperation}.`\n      );\n    }\n  }\n}\n","/*\n * The code in this file originated from\n * @see https://github.com/decentralized-identity/sidetree\n * For the list of changes that was made to the original code\n * @see https://github.com/transmute-industries/sidetree.js/blob/master/reference-implementation-changes.md\n *\n * Copyright 2020 - Transmute Industries Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  ErrorCode,\n  IVersionMetadataFetcher,\n  protocolParameters,\n  SidetreeError,\n  ValueTimeLockModel,\n} from '@sidetree/common';\n\n/**\n * Encapsulates the functionality to compute and verify the value time lock amounts.\n */\nexport default class ValueTimeLockVerifier {\n  /**\n   * Calculates the maximum number of operations allowed to be written for the given lock information. If\n   * there is no lock then it returns the number of operations which do not require a lock.\n   *\n   * @param valueTimeLock The lock object if exists\n   * @param versionMetadataFetcher The mapper from transaction time to version metadata\n   */\n  public static calculateMaxNumberOfOperationsAllowed(\n    valueTimeLock: ValueTimeLockModel | undefined,\n    versionMetadataFetcher: IVersionMetadataFetcher\n  ) {\n    if (valueTimeLock === undefined) {\n      return protocolParameters.maxNumberOfOperationsForNoValueTimeLock;\n    }\n\n    const versionMetadata = versionMetadataFetcher.getVersionMetadata(\n      valueTimeLock.lockTransactionTime\n    );\n    const normalizedFeeToPerOperationFeeMultiplier =\n      versionMetadata.normalizedFeeToPerOperationFeeMultiplier;\n    const valueTimeLockAmountMultiplier =\n      versionMetadata.valueTimeLockAmountMultiplier;\n\n    // Using the following formula:\n    //  requiredLockAmount = normalizedfee * normalizedFeeMultipier * numberOfOps * valueTimeLockMultiplier\n    //\n    // We are going to find the numberOfOps given the requiredLockAmount\n    const feePerOperation =\n      valueTimeLock.normalizedFee * normalizedFeeToPerOperationFeeMultiplier;\n    const numberOfOpsAllowed =\n      valueTimeLock.amountLocked /\n      (feePerOperation * valueTimeLockAmountMultiplier);\n\n    // Make sure that we are returning an integer; rounding down to make sure that we are not going above\n    // the max limit.\n    const numberOfOpsAllowedInt = Math.floor(numberOfOpsAllowed);\n\n    // Return at least the 'free' operations\n    return Math.max(\n      numberOfOpsAllowedInt,\n      protocolParameters.maxNumberOfOperationsForNoValueTimeLock\n    );\n  }\n\n  /**\n   * Verifies that the value lock object (amount, transaction time range) is correct for the specified number\n   * of operations.\n   *\n   * @param valueTimeLock The value time lock object used for verificiation.\n   * @param numberOfOperations The target number of operations.\n   * @param sidetreeTransactionTime The transaction time where the operations were written.\n   * @param sidetreeTransactionWriter The writer of the transaction.\n   * @param versionMetadataFetcher The mapper from transaction time to version metadata\n   */\n  public static verifyLockAmountAndThrowOnError(\n    valueTimeLock: ValueTimeLockModel | undefined,\n    numberOfOperations: number,\n    sidetreeTransactionTime: number,\n    sidetreeTransactionWriter: string,\n    versionMetadataFetcher: IVersionMetadataFetcher\n  ): void {\n    // If the number of written operations were under the free limit then there's nothing to check\n    if (\n      numberOfOperations <=\n      protocolParameters.maxNumberOfOperationsForNoValueTimeLock\n    ) {\n      return;\n    }\n\n    if (valueTimeLock) {\n      // Check the lock owner\n      if (valueTimeLock.owner !== sidetreeTransactionWriter) {\n        throw new SidetreeError(\n          ErrorCode.ValueTimeLockVerifierTransactionWriterLockOwnerMismatch,\n          `Sidetree transaction writer: ${sidetreeTransactionWriter} - Lock owner: ${valueTimeLock.owner}`\n        );\n      }\n\n      // Check the lock duration\n      if (\n        sidetreeTransactionTime < valueTimeLock.lockTransactionTime ||\n        sidetreeTransactionTime >= valueTimeLock.unlockTransactionTime\n      ) {\n        throw new SidetreeError(\n          ErrorCode.ValueTimeLockVerifierTransactionTimeOutsideLockRange,\n          // tslint:disable-next-line: max-line-length\n          `Sidetree transaction block: ${sidetreeTransactionTime}; lock start time: ${valueTimeLock.lockTransactionTime}; unlock time: ${valueTimeLock.unlockTransactionTime}`\n        );\n      }\n    }\n\n    const maxNumberOfOpsAllowed = this.calculateMaxNumberOfOperationsAllowed(\n      valueTimeLock,\n      versionMetadataFetcher\n    );\n\n    if (numberOfOperations > maxNumberOfOpsAllowed) {\n      throw new SidetreeError(\n        ErrorCode.ValueTimeLockVerifierInvalidNumberOfOperations,\n        `Max number of ops allowed: ${maxNumberOfOpsAllowed}; actual number of ops: ${numberOfOperations}`\n      );\n    }\n  }\n}\n"],"names":["FeeManager","computeMinimumTransactionFee","normalizedFee","numberOfOperations","SidetreeError","ErrorCode","OperationCountLessThanZero","Math","max","protocolParameters","normalizedFeeToPerOperationFeeMultiplier","verifyTransactionFeeAndThrowOnError","transactionFeePaid","TransactionFeePaidLessThanNormalizedFee","expectedFeePerOperation","TransactionFeePaidInvalid","ValueTimeLockVerifier","calculateMaxNumberOfOperationsAllowed","valueTimeLock","versionMetadataFetcher","undefined","maxNumberOfOperationsForNoValueTimeLock","versionMetadata","getVersionMetadata","lockTransactionTime","numberOfOpsAllowedInt","floor","amountLocked","valueTimeLockAmountMultiplier","verifyLockAmountAndThrowOnError","sidetreeTransactionTime","sidetreeTransactionWriter","owner","ValueTimeLockVerifierTransactionWriterLockOwnerMismatch","unlockTransactionTime","ValueTimeLockVerifierTransactionTimeOutsideLockRange","maxNumberOfOpsAllowed","this","ValueTimeLockVerifierInvalidNumberOfOperations"],"mappings":"+CAwBqBA,oCAWLC,6BAAP,SACLC,EACAC,MAEIA,GAAsB,QAClB,IAAIC,gBACRC,YAAUC,2FACsDH,UAY7CI,KAAKC,IAP1BN,EACAO,qBAAmBC,yCACyBP,EAKOD,MAczCS,oCAAP,SACLC,EACAT,EACAD,MAGIC,GAAsB,QAClB,IAAIC,gBACRC,YAAUC,wDACmBH,gCAI7BS,EAAqBV,QACjB,IAAIE,gBACRC,YAAUQ,gEACcD,6DAA6EV,OAKnGY,EACJZ,EACAO,qBAAmBC,4CAHSE,EAAqBT,EAKvBW,QACpB,IAAIV,gBACRC,YAAUU,kDACcH,gCAAgDT,yBAAyCW,aClEpGE,oCAQLC,sCAAP,SACLC,EACAC,WAEsBC,IAAlBF,SACKT,qBAAmBY,4CAGtBC,EAAkBH,EAAuBI,mBAC7CL,EAAcM,qBAmBVC,EAAwBlB,KAAKmB,MALjCR,EAAcS,cAFdT,EAAchB,cATdoB,EAAgBZ,yCAEhBY,EAAgBM,uCAiBXrB,KAAKC,IACViB,EACAhB,qBAAmBY,4CAcTQ,gCAAP,SACLX,EACAf,EACA2B,EACAC,EACAZ,QAIEhB,GACAM,qBAAmBY,6CAKjBH,EAAe,IAEbA,EAAcc,QAAUD,QACpB,IAAI3B,gBACRC,YAAU4B,wFACsBF,oBAA2Cb,EAAcc,UAM3FF,EAA0BZ,EAAcM,qBACxCM,GAA2BZ,EAAcgB,4BAEnC,IAAI9B,gBACRC,YAAU8B,oFAEqBL,wBAA6CZ,EAAcM,sCAAqCN,EAAcgB,2BAK7IE,EAAwBC,KAAKpB,sCACjCC,EACAC,MAGEhB,EAAqBiC,QACjB,IAAIhC,gBACRC,YAAUiC,6EACoBF,6BAAgDjC"}