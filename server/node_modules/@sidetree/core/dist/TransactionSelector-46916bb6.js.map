{"version":3,"file":"TransactionSelector-46916bb6.js","sources":["../src/TransactionSelector.ts"],"sourcesContent":["/*\n * The code in this file originated from\n * @see https://github.com/decentralized-identity/sidetree\n * For the list of changes that was made to the original code\n * @see https://github.com/transmute-industries/sidetree.js/blob/master/reference-implementation-changes.md\n *\n * Copyright 2020 - Transmute Industries Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  AnchoredDataSerializer,\n  ErrorCode,\n  ITransactionSelector,\n  ITransactionStore,\n  SidetreeError,\n  TransactionModel,\n  protocolParameters,\n} from '@sidetree/common';\nimport PriorityQueue from 'priorityqueue';\n\n/**\n * rate limits how many operations is valid per block\n */\nexport default class TransactionSelector implements ITransactionSelector {\n  private maxNumberOfOperationsPerBlock: number;\n  private maxNumberOfTransactionsPerBlock: number;\n  public constructor(private transactionStore: ITransactionStore) {\n    this.maxNumberOfOperationsPerBlock =\n      protocolParameters.maxNumberOfOperationsPerTransactionTime;\n    this.maxNumberOfTransactionsPerBlock =\n      protocolParameters.maxNumberOfTransactionsPerTransactionTime;\n  }\n\n  private static getTransactionPriorityQueue() {\n    const comparator = (a: TransactionModel, b: TransactionModel) => {\n      // higher fee comes first. If fees are the same, earlier transaction comes first\n      return (\n        a.transactionFeePaid - b.transactionFeePaid ||\n        b.transactionNumber - a.transactionNumber\n      );\n    };\n\n    return new PriorityQueue({ comparator });\n  }\n\n  /**\n   * Returns an array of transactions that should be processed. Ranked by highest fee paid per transaction and up to the\n   * max number of operations per block\n   * @param transactions The transactions that should be ranked and considered to process\n   */\n  public async selectQualifiedTransactions(\n    transactions: TransactionModel[]\n  ): Promise<TransactionModel[]> {\n    if (!transactions.length) {\n      return [];\n    }\n\n    const transactionsPriorityQueue = TransactionSelector.getTransactionPriorityQueue();\n\n    const currentTransactionTime = transactions[0].transactionTime;\n\n    TransactionSelector.validateTransactions(\n      transactions,\n      currentTransactionTime\n    );\n    TransactionSelector.enqueueFirstTransactionFromEachWriter(\n      transactions,\n      currentTransactionTime,\n      transactionsPriorityQueue\n    );\n\n    const [\n      numberOfOperations,\n      numberOfTransactions,\n    ] = await this.getNumberOfOperationsAndTransactionsAlreadyInTransactionTime(\n      currentTransactionTime\n    );\n    const numberOfOperationsToQualify =\n      this.maxNumberOfOperationsPerBlock - numberOfOperations;\n    const numberOfTransactionsToQualify =\n      this.maxNumberOfTransactionsPerBlock - numberOfTransactions;\n\n    const transactionsToReturn = TransactionSelector.getHighestFeeTransactionsFromCurrentTransactionTime(\n      numberOfOperationsToQualify,\n      numberOfTransactionsToQualify,\n      transactionsPriorityQueue\n    );\n\n    return transactionsToReturn;\n  }\n\n  private static validateTransactions(\n    transactions: TransactionModel[],\n    currentTransactionTime: number\n  ) {\n    for (const transaction of transactions) {\n      // expect all transactions to be in the same transaction time\n      if (transaction.transactionTime !== currentTransactionTime) {\n        throw new SidetreeError(\n          ErrorCode.TransactionsNotInSameBlock,\n          'transaction must be in the same block to perform rate limiting, investigate and fix'\n        );\n      }\n    }\n  }\n\n  private static enqueueFirstTransactionFromEachWriter(\n    transactions: TransactionModel[],\n    currentTransactionTime: number,\n    transactionsPriorityQueue: any\n  ) {\n    const writerToTransactionNumberMap = new Map();\n    // if multiple transactions have the same writer, take the first one in the array and enqueue into transactionPriorityQueue\n    for (const transaction of transactions) {\n      // only 1 transaction is allowed per writer\n      if (writerToTransactionNumberMap.has(transaction.writer)) {\n        const acceptedTransactionNumber = writerToTransactionNumberMap.get(\n          transaction.writer\n        );\n        // tslint:disable-next-line:max-line-length\n        console.info(\n          `Multiple transactions found in transaction time ${currentTransactionTime} from writer ${transaction.writer}, considering transaction ${acceptedTransactionNumber} and ignoring ${transaction.transactionNumber}`\n        );\n      } else {\n        transactionsPriorityQueue.push(transaction);\n        writerToTransactionNumberMap.set(\n          transaction.writer,\n          transaction.transactionNumber\n        );\n      }\n    }\n  }\n\n  private async getNumberOfOperationsAndTransactionsAlreadyInTransactionTime(\n    transactionTime: number\n  ): Promise<number[]> {\n    const transactions = await this.transactionStore.getTransactionsStartingFrom(\n      transactionTime,\n      transactionTime\n    );\n    let numberOfOperations = 0;\n    if (transactions) {\n      for (const transaction of transactions) {\n        try {\n          const numOfOperationsInCurrentTransaction = AnchoredDataSerializer.deserialize(\n            transaction.anchorString\n          ).numberOfOperations;\n          numberOfOperations += numOfOperationsInCurrentTransaction;\n        } catch (e) {\n          console.debug(\n            `Error thrown in TransactionSelector: ${JSON.stringify(\n              e,\n              Object.getOwnPropertyNames(e)\n            )}`\n          );\n          console.info(\n            `Transaction with anchor string ${transaction.anchorString} not considered as selected.`\n          );\n        }\n      }\n    }\n    const numberOfTransactions = transactions ? transactions.length : 0;\n    return [numberOfOperations, numberOfTransactions];\n  }\n\n  /**\n   * Given transactions within a block, return the ones that should be processed.\n   */\n  private static getHighestFeeTransactionsFromCurrentTransactionTime(\n    numberOfOperationsToQualify: number,\n    numberOfTransactionsToQualify: number,\n    transactionsPriorityQueue: any\n  ): TransactionModel[] {\n    let numberOfOperationsSeen = 0;\n    const transactionsToReturn = [];\n\n    while (\n      transactionsToReturn.length < numberOfTransactionsToQualify &&\n      numberOfOperationsSeen < numberOfOperationsToQualify &&\n      transactionsPriorityQueue.length > 0\n    ) {\n      const currentTransaction = transactionsPriorityQueue.pop();\n      try {\n        const numOfOperationsInCurrentTransaction = AnchoredDataSerializer.deserialize(\n          currentTransaction.anchorString\n        ).numberOfOperations;\n        numberOfOperationsSeen += numOfOperationsInCurrentTransaction;\n        if (numberOfOperationsSeen <= numberOfOperationsToQualify) {\n          transactionsToReturn.push(currentTransaction);\n        }\n      } catch (e) {\n        console.debug(\n          `Error thrown in TransactionSelector: ${JSON.stringify(\n            e,\n            Object.getOwnPropertyNames(e)\n          )}`\n        );\n        console.info(\n          `Transaction with anchor string ${currentTransaction.anchorString} not selected`\n        );\n      }\n    }\n\n    // sort based on transaction number ascending\n    return transactionsToReturn;\n  }\n}\n"],"names":["transactionStore","maxNumberOfOperationsPerBlock","protocolParameters","maxNumberOfOperationsPerTransactionTime","maxNumberOfTransactionsPerBlock","maxNumberOfTransactionsPerTransactionTime","getTransactionPriorityQueue","PriorityQueue","comparator","a","b","transactionFeePaid","transactionNumber","selectQualifiedTransactions","transactions","this","length","transactionsPriorityQueue","TransactionSelector","currentTransactionTime","transactionTime","validateTransactions","enqueueFirstTransactionFromEachWriter","_this2","getNumberOfOperationsAndTransactionsAlreadyInTransactionTime","getHighestFeeTransactionsFromCurrentTransactionTime","SidetreeError","ErrorCode","TransactionsNotInSameBlock","writerToTransactionNumberMap","Map","transaction","has","writer","acceptedTransactionNumber","get","console","info","push","set","getTransactionsStartingFrom","numberOfOperations","AnchoredDataSerializer","deserialize","anchorString","e","debug","JSON","stringify","Object","getOwnPropertyNames","numberOfOperationsToQualify","numberOfTransactionsToQualify","numberOfOperationsSeen","transactionsToReturn","currentTransaction","pop"],"mappings":"oaAoC6BA,yBAAAA,OACpBC,8BACHC,qBAAmBC,6CAChBC,gCACHF,qBAAmBG,4CAGRC,4BAAP,kBASC,IAAIC,EAAc,CAAEC,WARR,SAACC,EAAqBC,UAGrCD,EAAEE,mBAAqBD,EAAEC,oBACzBD,EAAEE,kBAAoBH,EAAEG,iDAYjBC,qCACXC,aAuBUC,SArBLD,EAAaE,8BACT,QAGHC,EAA4BC,EAAoBZ,8BAEhDa,EAAyBL,EAAa,GAAGM,uBAE/CF,EAAoBG,qBAClBP,EACAK,GAEFD,EAAoBI,sCAClBR,EACAK,EACAF,mBAMQM,EAAKC,6DACbL,6BAO2BD,EAAoBO,oDAJ/CF,EAAKtB,mCAELsB,EAAKnB,qCAKLa,4CAMWI,qBAAP,SACNP,EACAK,iDAE0BL,6BAERM,kBAAoBD,QAC5B,IAAIO,gBACRC,YAAUC,2BACV,0FAMON,sCAAP,SACNR,EACAK,EACAF,aAEMY,EAA+B,IAAIC,wCAEfhB,kBAAc,KAA7BiB,aAELF,EAA6BG,IAAID,EAAYE,QAAS,KAClDC,EAA4BL,EAA6BM,IAC7DJ,EAAYE,QAGdG,QAAQC,wDAC6ClB,kBAAsCY,EAAYE,oCAAmCC,mBAA0CH,EAAYnB,wBAGhMK,EAA0BqB,KAAKP,GAC/BF,EAA6BU,IAC3BR,EAAYE,OACZF,EAAYnB,uBAMNY,sEACZJ,8BAE2BL,KAAKf,iBAAiBwC,4BAC/CpB,EACAA,mBAFIN,OAIF2B,EAAqB,KACrB3B,gDACwBA,kBAAc,KAA7BiB,cAKPU,GAH4CC,yBAAuBC,YACjEZ,EAAYa,cACZH,mBAEF,MAAOI,GACPT,QAAQU,8CACkCC,KAAKC,UAC3CH,EACAI,OAAOC,oBAAoBL,KAG/BT,QAAQC,uCAC4BN,EAAYa,oDAM/C,CAACH,EADqB3B,EAAeA,EAAaE,OAAS,4CAOrDS,oDAAP,SACN0B,EACAC,EACAnC,WAEIoC,EAAyB,EACvBC,EAAuB,GAG3BA,EAAqBtC,OAASoC,GAC9BC,EAAyBF,GACzBlC,EAA0BD,OAAS,GACnC,KACMuC,EAAqBtC,EAA0BuC,WAKnDH,GAH4CX,yBAAuBC,YACjEY,EAAmBX,cACnBH,qBAE4BU,GAC5BG,EAAqBhB,KAAKiB,GAE5B,MAAOV,GACPT,QAAQU,8CACkCC,KAAKC,UAC3CH,EACAI,OAAOC,oBAAoBL,KAG/BT,QAAQC,uCAC4BkB,EAAmBX,sCAMpDU"}