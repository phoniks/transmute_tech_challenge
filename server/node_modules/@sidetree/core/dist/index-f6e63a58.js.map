{"version":3,"file":"index-f6e63a58.js","sources":["../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../src/util/ArrayMethods.ts","../src/util/Compressor.ts","../src/DocumentComposer.ts","../src/util/JsonAsync.ts","../src/OperationUtils.ts","../src/CreateOperation.ts","../src/util/Jwk.ts","../src/util/Jws.ts","../src/DeactivateOperation.ts","../src/RecoverOperation.ts","../src/write/AnchorFile.ts","../src/write/BatchScheduler.ts","../src/write/ChunkFile.ts","../src/DownloadManager.ts","../src/UpdateOperation.ts","../src/write/MapFile.ts","../src/ThroughputLimiter.ts","../src/Observer.ts","../src/Operation.ts","../src/test/generators/OperationGenerator.ts","../src/Resolver.ts","../src/ServiceInfoProvider.ts","../src/VersionManager.ts"],"sourcesContent":["// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","/*\n * The code in this file originated from\n * @see https://github.com/decentralized-identity/sidetree\n * For the list of changes that was made to the original code\n * @see https://github.com/transmute-industries/sidetree.js/blob/master/reference-implementation-changes.md\n *\n * Copyright 2020 - Transmute Industries Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Class containing methods that operates against an array.\n */\nexport default class ArrayMethods {\n  /**\n   * Checkes to see if there are duplicates in the given array.\n   */\n  public static hasDuplicates<T>(array: Array<T>): boolean {\n    const uniqueValues = new Set<T>();\n\n    for (let i = 0; i < array.length; i++) {\n      const value = array[i];\n      if (uniqueValues.has(value)) {\n        return true;\n      }\n      uniqueValues.add(value);\n    }\n\n    return false;\n  }\n\n  /**\n   * Checks that entries in array 2 is not in array 1.\n   */\n  public static areMutuallyExclusive<T>(\n    array1: Array<T>,\n    array2: Array<T>\n  ): boolean {\n    const valuesInArray1 = new Set<T>(array1);\n\n    for (const value of array2) {\n      if (valuesInArray1.has(value)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n}\n","/*\n * The code in this file originated from\n * @see https://github.com/decentralized-identity/sidetree\n * For the list of changes that was made to the original code\n * @see https://github.com/transmute-industries/sidetree.js/blob/master/reference-implementation-changes.md\n *\n * Copyright 2020 - Transmute Industries Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst pako = require('pako');\n\n/**\n * Encapsulates functionality to compress/decompress data.\n */\nexport default class Compressor {\n  /**\n   * Compresses the data in gzip and return it as buffer.\n   * @param inputAsBuffer The input string to be compressed.\n   */\n  public static async compress(inputAsBuffer: Buffer): Promise<Buffer> {\n    const result = pako.deflate(Buffer.from(inputAsBuffer));\n    return Buffer.from(result);\n  }\n\n  /**\n   * Decompresses the input and returns it as buffer.\n   * @param inputAsBuffer The gzip compressed data.\n   */\n  public static async decompress(inputAsBuffer: Buffer): Promise<Buffer> {\n    const result = pako.inflate(inputAsBuffer);\n    return Buffer.from(result);\n  }\n}\n","/*\n * The code in this file originated from\n * @see https://github.com/decentralized-identity/sidetree\n * For the list of changes that was made to the original code\n * @see https://github.com/transmute-industries/sidetree.js/blob/master/reference-implementation-changes.md\n *\n * Copyright 2020 - Transmute Industries Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  DocumentModel,\n  Encoder,\n  DidState,\n  ErrorCode,\n  SidetreeError,\n  PublicKeyPurpose,\n} from '@sidetree/common';\nimport UpdateOperation from './UpdateOperation';\nimport jsonpatch from 'fast-json-patch';\n\n/**\n * Class that handles the composition of operations into final external-facing document.\n */\nexport default class DocumentComposer {\n  /**\n   * Transforms the given DID state into a DID Document.\n   */\n  public static transformToExternalDocument(\n    didState: DidState,\n    did: string\n  ): any {\n    // If the DID is deactivated.\n    if (didState.nextRecoveryCommitmentHash === undefined) {\n      return { status: 'deactivated' };\n    }\n\n    const document = didState.document as DocumentModel;\n\n    const shortFormDid = did.split('?')[0];\n\n    // Only populate `publicKey` if general purpose exists.\n    // Only populate `authentication` if auth purpose exists.\n    const authentication: any[] = [];\n    const assertionMethod: any[] = [];\n    const capabilityInvocation: any[] = [];\n    const capabilityDelegation: any[] = [];\n    const keyAgreement: any[] = [];\n\n    const public_keys: any[] = [];\n    if (Array.isArray(document.public_keys)) {\n      for (const publicKey of document.public_keys) {\n        const id = '#' + publicKey.id;\n        const didDocumentPublicKey = {\n          id: id,\n          controller: shortFormDid,\n          type: publicKey.type,\n          publicKeyJwk: publicKey.jwk,\n        };\n        const purposeSet: Set<string> = new Set(publicKey.purpose);\n\n        if (purposeSet.has(PublicKeyPurpose.General)) {\n          public_keys.push(didDocumentPublicKey);\n\n          if (purposeSet.has(PublicKeyPurpose.Auth)) {\n            authentication.push(id);\n          }\n          if (purposeSet.has(PublicKeyPurpose.AssertionMethod)) {\n            assertionMethod.push(id);\n          }\n          if (purposeSet.has(PublicKeyPurpose.CapabilityInvocation)) {\n            capabilityInvocation.push(id);\n          }\n          if (purposeSet.has(PublicKeyPurpose.CapabilityDelegation)) {\n            capabilityDelegation.push(id);\n          }\n          if (purposeSet.has(PublicKeyPurpose.KeyAgreement)) {\n            keyAgreement.push(id);\n          }\n        } else if (purposeSet.has(PublicKeyPurpose.Auth)) {\n          authentication.push(didDocumentPublicKey);\n        } else if (purposeSet.has(PublicKeyPurpose.AssertionMethod)) {\n          assertionMethod.push(assertionMethod);\n        } else if (purposeSet.has(PublicKeyPurpose.CapabilityInvocation)) {\n          capabilityInvocation.push(didDocumentPublicKey);\n        } else if (purposeSet.has(PublicKeyPurpose.CapabilityDelegation)) {\n          capabilityDelegation.push(didDocumentPublicKey);\n        } else if (purposeSet.has(PublicKeyPurpose.KeyAgreement)) {\n          keyAgreement.push(didDocumentPublicKey);\n        }\n      }\n    }\n\n    // Only update `service_endpoints` if the array is present\n    const service_endpoints = [];\n    if (Array.isArray(document.service_endpoints)) {\n      for (const serviceEndpoint of document.service_endpoints) {\n        const didDocumentServiceEndpoint = {\n          id: '#' + serviceEndpoint.id,\n          type: serviceEndpoint.type,\n          serviceEndpoint: serviceEndpoint.endpoint,\n        };\n        service_endpoints.push(didDocumentServiceEndpoint);\n      }\n    }\n\n    const didDocument: any = {\n      id: shortFormDid,\n      '@context': ['https://www.w3.org/ns/did/v1', { '@base': shortFormDid }],\n    };\n\n    if (public_keys.length !== 0) {\n      didDocument.publicKey = public_keys;\n    }\n\n    if (authentication.length !== 0) {\n      didDocument.authentication = authentication;\n    }\n\n    if (assertionMethod.length !== 0) {\n      didDocument.assertionMethod = assertionMethod;\n    }\n\n    if (capabilityInvocation.length !== 0) {\n      didDocument.capabilityInvocation = capabilityInvocation;\n    }\n\n    if (capabilityDelegation.length !== 0) {\n      didDocument.capabilityDelegation = capabilityDelegation;\n    }\n\n    if (keyAgreement.length !== 0) {\n      didDocument.keyAgreement = keyAgreement;\n    }\n\n    if (service_endpoints.length !== 0) {\n      didDocument.service = service_endpoints;\n    }\n\n    const didResolutionResult: any = {\n      '@context': 'https://www.w3.org/ns/did-resolution/v1',\n      didDocument: didDocument,\n      methodMetadata: {\n        recoveryCommitment: didState.nextRecoveryCommitmentHash,\n        updateCommitment: didState.nextUpdateCommitmentHash,\n      },\n    };\n\n    return JSON.parse(JSON.stringify(didResolutionResult));\n  }\n\n  /**\n   * Applies the update operation to the given document.\n   * @returns The resultant document.\n   * @throws SidetreeError if invalid operation is given.\n   */\n  public static async applyUpdateOperation(\n    operation: UpdateOperation,\n    document: any\n  ): Promise<any> {\n    const resultantDocument = DocumentComposer.applyPatches(\n      document,\n      operation.delta!.patches\n    );\n\n    return resultantDocument;\n  }\n\n  /**\n   * Validates the schema of the given full document.\n   * @throws SidetreeError if given document patch fails validation.\n   */\n  private static validateDocument(document: any) {\n    if (document === undefined) {\n      throw new SidetreeError(ErrorCode.DocumentComposerDocumentMissing);\n    }\n\n    const allowedProperties = new Set(['public_keys', 'service_endpoints']);\n    for (const property in document) {\n      if (!allowedProperties.has(property)) {\n        throw new SidetreeError(\n          ErrorCode.DocumentComposerUnknownPropertyInDocument,\n          `Unexpected property ${property} in document.`\n        );\n      }\n    }\n\n    // Verify 'public_keys' property if it exists.\n    if (Object.prototype.hasOwnProperty.call(document, 'public_keys')) {\n      DocumentComposer.validatePublicKeys(document.public_keys);\n    }\n\n    // Verify 'service_endpoints' property if it exists.\n    if (Object.prototype.hasOwnProperty.call(document, 'service_endpoints')) {\n      // Verify each endpoint entry in service_endpoints.\n      DocumentComposer.validateServiceEndpoints(document.service_endpoints);\n    }\n  }\n\n  /**\n   * Validates the schema of the given update document patch.\n   * @throws SidetreeError if given document patch fails validation.\n   */\n  public static validateDocumentPatches(patches: any) {\n    if (!Array.isArray(patches)) {\n      throw new SidetreeError(\n        ErrorCode.DocumentComposerUpdateOperationDocumentPatchesNotArray\n      );\n    }\n\n    for (const patch of patches) {\n      DocumentComposer.validatePatch(patch);\n    }\n  }\n\n  private static validatePatch(patch: any) {\n    const action = patch.action;\n    switch (action) {\n      case 'replace':\n        DocumentComposer.validateDocument(patch.document);\n        break;\n      case 'add-public-keys':\n        DocumentComposer.validateAddPublicKeysPatch(patch);\n        break;\n      case 'remove-public-keys':\n        DocumentComposer.validateRemovePublicKeysPatch(patch);\n        break;\n      case 'add-service-endpoints':\n        DocumentComposer.validateAddServiceEndpointsPatch(patch);\n        break;\n      case 'remove-service-endpoints':\n        DocumentComposer.validateRemoveServiceEndpointsPatch(patch);\n        break;\n      case 'ietf-json-patch':\n        DocumentComposer.validateIetfJsonPatch(patch);\n        break;\n      default:\n        throw new SidetreeError(\n          ErrorCode.DocumentComposerPatchMissingOrUnknownAction\n        );\n    }\n  }\n\n  private static validateIetfJsonPatch(patch: any): void {\n    const patchProperties = Object.keys(patch);\n    if (patchProperties.length !== 2) {\n      throw new SidetreeError(\n        ErrorCode.DocumentComposerPatchMissingOrUnknownProperty\n      );\n    }\n    const error = jsonpatch.validate(patch.patches);\n    if (error) {\n      console.warn(error);\n      throw new SidetreeError(error.name);\n    }\n  }\n\n  private static validateAddPublicKeysPatch(patch: any) {\n    const patchProperties = Object.keys(patch);\n    if (patchProperties.length !== 2) {\n      throw new SidetreeError(\n        ErrorCode.DocumentComposerPatchMissingOrUnknownProperty\n      );\n    }\n\n    DocumentComposer.validatePublicKeys(patch.public_keys);\n  }\n\n  private static validatePublicKeys(public_keys: any) {\n    if (!Array.isArray(public_keys)) {\n      throw new SidetreeError(ErrorCode.DocumentComposerPublicKeysNotArray);\n    }\n\n    const publicKeyIdSet: Set<string> = new Set();\n    for (const publicKey of public_keys) {\n      const publicKeyProperties = Object.keys(publicKey);\n      // the expected fields are id, purpose, type and jwk\n      if (publicKeyProperties.length !== 4) {\n        throw new SidetreeError(\n          ErrorCode.DocumentComposerPublicKeyMissingOrUnknownProperty\n        );\n      }\n\n      if (typeof publicKey.jwk !== 'object' || Array.isArray(publicKey.jwk)) {\n        throw new SidetreeError(\n          ErrorCode.DocumentComposerPublicKeyJwkMissingOrIncorrectType\n        );\n      }\n\n      if (typeof publicKey.type !== 'string') {\n        throw new SidetreeError(\n          ErrorCode.DocumentComposerPublicKeyTypeMissingOrIncorrectType\n        );\n      }\n\n      DocumentComposer.validateId(publicKey.id);\n\n      // 'id' must be unique\n      if (publicKeyIdSet.has(publicKey.id)) {\n        throw new SidetreeError(\n          ErrorCode.DocumentComposerPublicKeyIdDuplicated\n        );\n      }\n      publicKeyIdSet.add(publicKey.id);\n\n      if (!Array.isArray(publicKey.purpose) || publicKey.purpose.length === 0) {\n        throw new SidetreeError(\n          ErrorCode.DocumentComposerPublicKeyPurposeMissingOrUnknown\n        );\n      }\n\n      if (publicKey.purpose.length > Object.values(PublicKeyPurpose).length) {\n        throw new SidetreeError(\n          ErrorCode.DocumentComposerPublicKeyPurposeExceedsMaxLength\n        );\n      }\n\n      const validPurposes = new Set(Object.values(PublicKeyPurpose));\n      // Purpose must be one of the valid ones in KeyPurpose\n      for (const purpose of publicKey.purpose) {\n        if (!validPurposes.has(purpose)) {\n          throw new SidetreeError(\n            ErrorCode.DocumentComposerPublicKeyInvalidPurpose\n          );\n        }\n      }\n    }\n  }\n\n  private static validateRemovePublicKeysPatch(patch: any) {\n    const patchProperties = Object.keys(patch);\n    if (patchProperties.length !== 2) {\n      throw new SidetreeError(\n        ErrorCode.DocumentComposerPatchMissingOrUnknownProperty\n      );\n    }\n\n    if (!Array.isArray(patch.public_keys)) {\n      throw new SidetreeError(\n        ErrorCode.DocumentComposerPatchPublicKeyIdsNotArray\n      );\n    }\n\n    for (const publicKeyId of patch.public_keys) {\n      if (typeof publicKeyId !== 'string') {\n        throw new SidetreeError(\n          ErrorCode.DocumentComposerPatchPublicKeyIdNotString\n        );\n      }\n    }\n  }\n\n  /**\n   * validate update patch for removing service endpoints\n   */\n  private static validateRemoveServiceEndpointsPatch(patch: any) {\n    const patchProperties = Object.keys(patch);\n    if (patchProperties.length !== 2) {\n      throw new SidetreeError(\n        ErrorCode.DocumentComposerPatchMissingOrUnknownProperty\n      );\n    }\n\n    if (!Array.isArray(patch.ids)) {\n      throw new SidetreeError(\n        ErrorCode.DocumentComposerPatchServiceEndpointIdsNotArray\n      );\n    }\n\n    for (const id of patch.ids) {\n      DocumentComposer.validateId(id);\n    }\n  }\n\n  /**\n   * Validates update patch for adding service endpoints.\n   */\n  private static validateAddServiceEndpointsPatch(patch: any) {\n    const patchProperties = Object.keys(patch);\n    if (patchProperties.length !== 2) {\n      throw new SidetreeError(\n        ErrorCode.DocumentComposerPatchMissingOrUnknownProperty\n      );\n    }\n\n    if (!Array.isArray(patch.service_endpoints)) {\n      throw new SidetreeError(\n        ErrorCode.DocumentComposerPatchServiceEndpointsNotArray\n      );\n    }\n\n    DocumentComposer.validateServiceEndpoints(patch.service_endpoints);\n  }\n\n  /**\n   * Validates and parses services endpoints\n   * @param service_endpoints the service endpoints to validate and parse\n   */\n  private static validateServiceEndpoints(service_endpoints: any) {\n    if (!Array.isArray(service_endpoints)) {\n      throw new SidetreeError(\n        ErrorCode.DocumentComposerPatchServiceEndpointsNotArray\n      );\n    }\n\n    for (const serviceEndpoint of service_endpoints) {\n      const serviceEndpointProperties = Object.keys(serviceEndpoint);\n      if (serviceEndpointProperties.length !== 3) {\n        // type, id, and endpoint\n        throw new SidetreeError(\n          ErrorCode.DocumentComposerServiceEndpointMissingOrUnknownProperty\n        );\n      }\n\n      DocumentComposer.validateId(serviceEndpoint.id);\n\n      if (typeof serviceEndpoint.type !== 'string') {\n        throw new SidetreeError(\n          ErrorCode.DocumentComposerPatchServiceEndpointTypeNotString\n        );\n      }\n      if (serviceEndpoint.type.length > 30) {\n        throw new SidetreeError(\n          ErrorCode.DocumentComposerPatchServiceEndpointTypeTooLong\n        );\n      }\n      if (typeof serviceEndpoint.endpoint !== 'string') {\n        throw new SidetreeError(\n          ErrorCode.DocumentComposerPatchServiceEndpointServiceEndpointNotString\n        );\n      }\n      if (serviceEndpoint.endpoint.length > 100) {\n        throw new SidetreeError(\n          ErrorCode.DocumentComposerPatchServiceEndpointServiceEndpointTooLong\n        );\n      }\n\n      try {\n        // just want to validate url, no need to assign to variable, it will throw if not valid\n        // tslint:disable-next-line\n        new URL(serviceEndpoint.endpoint);\n      } catch {\n        throw new SidetreeError(\n          ErrorCode.DocumentComposerPatchServiceEndpointServiceEndpointNotValidUrl\n        );\n      }\n    }\n  }\n\n  private static validateId(id: any) {\n    if (typeof id !== 'string') {\n      throw new SidetreeError(\n        ErrorCode.DocumentComposerIdNotString,\n        `ID not string: ${JSON.stringify(id)} is of type '${typeof id}'`\n      );\n    }\n    if (id.length > 50) {\n      throw new SidetreeError(ErrorCode.DocumentComposerIdTooLong);\n    }\n\n    if (!Encoder.isBase64UrlString(id)) {\n      throw new SidetreeError(\n        ErrorCode.DocumentComposerIdNotUsingBase64UrlCharacterSet\n      );\n    }\n  }\n\n  /**\n   * Applies the given patches in order to the given document.\n   * NOTE: Assumes no schema validation is needed, since validation should've already occurred at the time of the operation being parsed.\n   * @returns The resultant document.\n   */\n  public static applyPatches(document: any, patches: any[]): any {\n    // Loop through and apply all patches.\n    let resultantDocument = document;\n    for (const patch of patches) {\n      resultantDocument = DocumentComposer.applyPatchToDidDocument(\n        resultantDocument,\n        patch\n      );\n    }\n\n    return resultantDocument;\n  }\n\n  /**\n   * Applies the given patch to the given DID Document.\n   */\n  private static applyPatchToDidDocument(\n    document: DocumentModel,\n    patch: any\n  ): any {\n    if (patch.action === 'replace') {\n      return patch.document;\n    } else if (patch.action === 'add-public-keys') {\n      return DocumentComposer.addPublicKeys(document, patch);\n    } else if (patch.action === 'remove-public-keys') {\n      return DocumentComposer.removePublicKeys(document, patch);\n    } else if (patch.action === 'add-service-endpoints') {\n      return DocumentComposer.addServiceEndpoints(document, patch);\n    } else if (patch.action === 'remove-service-endpoints') {\n      return DocumentComposer.removeServiceEndpoints(document, patch);\n    } else if (patch.action === 'ietf-json-patch') {\n      return DocumentComposer.applyIetfJsonPatch(document, patch);\n    }\n  }\n\n  private static applyIetfJsonPatch(document: any, patch: any) {\n    const res = jsonpatch.applyPatch({ ...document }, patch.patches);\n    return res.newDocument;\n  }\n\n  /**\n   * Adds public keys to document.\n   */\n  private static addPublicKeys(\n    document: DocumentModel,\n    patch: any\n  ): DocumentModel {\n    const publicKeyMap = new Map(\n      (document.public_keys || []).map((publicKey) => [publicKey.id, publicKey])\n    );\n\n    // Loop through all given public keys and add them if they don't exist already.\n    for (const publicKey of patch.public_keys) {\n      // NOTE: If a key ID already exists, we will just replace the existing key.\n      // Not throwing error will minimize the need (thus risk) of reusing exposed update reveal value.\n      publicKeyMap.set(publicKey.id, publicKey);\n    }\n\n    document.public_keys = Array.from(publicKeyMap.entries()).map(\n      (pkm: any) => pkm[1]\n    );\n\n    return document;\n  }\n\n  /**\n   * Removes public keys from document.\n   */\n  private static removePublicKeys(\n    document: DocumentModel,\n    patch: any\n  ): DocumentModel {\n    const publicKeyMap = new Map(\n      (document.public_keys || []).map((publicKey) => [publicKey.id, publicKey])\n    );\n\n    // Loop through all given public key IDs and delete them from the existing public key only if it is not a recovery key.\n    for (const publicKey of patch.public_keys) {\n      const existingKey = publicKeyMap.get(publicKey);\n\n      if (existingKey !== undefined) {\n        publicKeyMap.delete(publicKey);\n      }\n      // NOTE: Else we will just treat this key removal as a no-op.\n      // Not throwing error will minimize the need (thus risk) of reusing exposed update reveal value.\n    }\n\n    document.public_keys = Array.from(publicKeyMap.entries()).map(\n      (pkm: any) => pkm[1]\n    );\n\n    return document;\n  }\n\n  private static addServiceEndpoints(\n    document: DocumentModel,\n    patch: any\n  ): DocumentModel {\n    const service_endpoints = patch.service_endpoints;\n\n    if (document.service_endpoints === undefined) {\n      // create a new array if service did not exist\n      document.service_endpoints = [];\n    }\n\n    const idToIndexMapper = new Map();\n    // map all id and their index\n    for (const idx in document.service_endpoints) {\n      idToIndexMapper.set(document.service_endpoints[idx].id, idx);\n    }\n\n    for (const serviceEndpoint of service_endpoints) {\n      if (idToIndexMapper.has(serviceEndpoint.id)) {\n        const idx = idToIndexMapper.get(serviceEndpoint.id);\n        document.service_endpoints[idx] = serviceEndpoint;\n      } else {\n        document.service_endpoints.push(serviceEndpoint);\n      }\n    }\n\n    return document;\n  }\n\n  private static removeServiceEndpoints(\n    document: DocumentModel,\n    patch: any\n  ): DocumentModel {\n    if (document.service_endpoints === undefined) {\n      return document;\n    }\n\n    const idsToRemove = new Set(patch.ids);\n    document.service_endpoints = document.service_endpoints.filter(\n      (serviceEndpoint) => !idsToRemove.has(serviceEndpoint.id)\n    );\n\n    return document;\n  }\n}\n","/*\n * The code in this file originated from\n * @see https://github.com/decentralized-identity/sidetree\n * For the list of changes that was made to the original code\n * @see https://github.com/transmute-industries/sidetree.js/blob/master/reference-implementation-changes.md\n *\n * Copyright 2020 - Transmute Industries Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst yieldableJson = require('yieldable-json');\n\n/**\n * A JSON library that performs operations asynchronously.\n */\nexport default class JsonAsync {\n  /**\n   * Parses the given operation into a JavaScript object asynchronously,\n   * to allow the event loop a chance to handle requests.\n   */\n  public static async parse(jsonData: Buffer | string): Promise<any> {\n    // Create a promise to wrap the successful/failed read events.\n    const jsonParsePromise = new Promise((resolve, reject) => {\n      yieldableJson.parseAsync(jsonData, (err: any, data: any) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(data);\n        }\n      });\n    });\n\n    // Wait until the JSON parsing is completed.\n    const result = await jsonParsePromise;\n    return result;\n  }\n}\n","/*\n * The code in this file originated from\n * @see https://github.com/decentralized-identity/sidetree\n * For the list of changes that was made to the original code\n * @see https://github.com/transmute-industries/sidetree.js/blob/master/reference-implementation-changes.md\n *\n * Copyright 2020 - Transmute Industries Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  DeltaModel,\n  Encoder,\n  ErrorCode,\n  Multihash,\n  SidetreeError,\n} from '@sidetree/common';\nimport DocumentComposer from './DocumentComposer';\nimport JsonAsync from './util/JsonAsync';\n\n/**\n * A class that contains Sidetree operation utility methods.\n */\nexport default class OperationUtils {\n  /**\n   * Parses the given encoded delta string into an internal `DeltaModel`.\n   */\n  public static async parseDelta(deltaEncodedString: any): Promise<DeltaModel> {\n    if (typeof deltaEncodedString !== 'string') {\n      throw new SidetreeError(ErrorCode.DeltaMissingOrNotString);\n    }\n\n    const deltaJsonString = Encoder.decodeAsString(deltaEncodedString);\n    const delta = await JsonAsync.parse(deltaJsonString);\n\n    const properties = Object.keys(delta);\n    if (properties.length !== 2) {\n      throw new SidetreeError(ErrorCode.DeltaMissingOrUnknownProperty);\n    }\n\n    if (delta.patches === undefined) {\n      throw new SidetreeError(ErrorCode.OperationDocumentPatchesMissing);\n    }\n\n    // Validate `patches` property using the DocumentComposer.\n    DocumentComposer.validateDocumentPatches(delta.patches);\n\n    const nextUpdateCommitment = Encoder.decodeAsBuffer(\n      delta.update_commitment\n    );\n    Multihash.verifyHashComputedUsingLatestSupportedAlgorithm(\n      nextUpdateCommitment\n    );\n\n    return {\n      patches: delta.patches,\n      update_commitment: delta.update_commitment,\n    };\n  }\n}\n","/*\n * The code in this file originated from\n * @see https://github.com/decentralized-identity/sidetree\n * For the list of changes that was made to the original code\n * @see https://github.com/transmute-industries/sidetree.js/blob/master/reference-implementation-changes.md\n *\n * Copyright 2020 - Transmute Industries Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  OperationType,\n  ErrorCode,\n  SidetreeError,\n  DeltaModel,\n  OperationModel,\n  Multihash,\n  Encoder,\n} from '@sidetree/common';\nimport OperationUtils from './OperationUtils';\nimport JsonAsync from './util/JsonAsync';\n\ninterface SuffixDataModel {\n  delta_hash: string;\n  recovery_commitment: string;\n}\n\n/**\n * A class that represents a create operation.\n */\nexport default class CreateOperation implements OperationModel {\n  /** The original request buffer sent by the requester. */\n  public readonly operationBuffer: Buffer;\n\n  /** The unique suffix of the DID. */\n  public readonly didUniqueSuffix: string;\n\n  /** The type of operation. */\n  public readonly type: OperationType;\n\n  /** Data used to generate the unique DID suffix. */\n  public readonly suffixData: SuffixDataModel;\n\n  /** Delta. */\n  public readonly delta: DeltaModel | undefined;\n\n  /** Encoded string of the suffix data. */\n  public readonly encodedSuffixData: string;\n\n  /** Encoded string of the delta. */\n  public readonly encodedDelta: string | undefined;\n\n  /**\n   * NOTE: should only be used by `parse()` and `parseObject()` else the contructed instance could be invalid.\n   */\n  private constructor(\n    operationBuffer: Buffer,\n    didUniqueSuffix: string,\n    encodedSuffixData: string,\n    suffixData: SuffixDataModel,\n    encodedDelta: string | undefined,\n    delta: DeltaModel | undefined\n  ) {\n    this.didUniqueSuffix = didUniqueSuffix;\n    this.type = OperationType.Create;\n    this.operationBuffer = operationBuffer;\n    this.encodedSuffixData = encodedSuffixData;\n    this.suffixData = suffixData;\n    this.encodedDelta = encodedDelta;\n    this.delta = delta;\n  }\n\n  /**\n   * Computes the DID unique suffix given the encoded suffix data string.\n   */\n  private static computeDidUniqueSuffix(encodedSuffixData: string): string {\n    const suffixDataBuffer = Encoder.decodeAsBuffer(encodedSuffixData);\n    const multihash = Multihash.hash(suffixDataBuffer);\n    const encodedMultihash = Encoder.encode(multihash);\n    return encodedMultihash;\n  }\n\n  /**\n   * Parses the given input as a create operation entry in the anchor file.\n   */\n  public static async parseOperationFromAnchorFile(\n    input: any\n  ): Promise<CreateOperation> {\n    // Issue #442 - Replace `operationBuffer` in `OperationModel` and `AnchoredOperationModel` with actual operation request\n    const operationBuffer = Buffer.from(JSON.stringify(input));\n    const operation = await CreateOperation.parseObject(\n      input,\n      operationBuffer,\n      true\n    );\n    return operation;\n  }\n\n  /**\n   * Parses the given buffer as a `CreateOperation`.\n   */\n  public static async parse(operationBuffer: Buffer): Promise<CreateOperation> {\n    const operationJsonString = operationBuffer.toString();\n    const operationObject = await JsonAsync.parse(operationJsonString);\n    const createOperation = await CreateOperation.parseObject(\n      operationObject,\n      operationBuffer,\n      false\n    );\n    return createOperation;\n  }\n\n  /**\n   * Parses the given operation object as a `CreateOperation`.\n   * The `operationBuffer` given is assumed to be valid and is assigned to the `operationBuffer` directly.\n   * NOTE: This method is purely intended to be used as an optimization method over the `parse` method in that\n   * JSON parsing is not required to be performed more than once when an operation buffer of an unknown operation type is given.\n   * @param anchorFileMode If set to true, then `delta` and `type` properties are expected to be absent.\n   */\n  public static async parseObject(\n    operationObject: any,\n    operationBuffer: Buffer,\n    anchorFileMode: boolean\n  ): Promise<CreateOperation> {\n    let expectedPropertyCount = 3;\n    if (anchorFileMode) {\n      expectedPropertyCount = 1;\n    }\n\n    const properties = Object.keys(operationObject);\n    if (properties.length !== expectedPropertyCount) {\n      throw new SidetreeError(\n        ErrorCode.CreateOperationMissingOrUnknownProperty\n      );\n    }\n\n    const encodedSuffixData = operationObject.suffix_data;\n    const suffixData = await CreateOperation.parseSuffixData(encodedSuffixData);\n\n    // If not in anchor file mode, we need to validate `type` and `delta` properties.\n    let encodedDelta = undefined;\n    let delta = undefined;\n    if (!anchorFileMode) {\n      if (operationObject.type !== OperationType.Create) {\n        throw new SidetreeError(ErrorCode.CreateOperationTypeIncorrect);\n      }\n\n      encodedDelta = operationObject.delta;\n      try {\n        delta = await OperationUtils.parseDelta(operationObject.delta);\n      } catch {\n        // For compatibility with data pruning, we have to assume that `delta` may be unavailable,\n        // thus an operation with invalid `delta` needs to be processed as an operation with unavailable `delta`,\n        // so here we let `delta` be `undefined`.\n      }\n    }\n\n    const didUniqueSuffix = CreateOperation.computeDidUniqueSuffix(\n      operationObject.suffix_data\n    );\n    return new CreateOperation(\n      operationBuffer,\n      didUniqueSuffix,\n      encodedSuffixData,\n      suffixData,\n      encodedDelta,\n      delta\n    );\n  }\n\n  private static async parseSuffixData(\n    suffixDataEncodedString: any\n  ): Promise<SuffixDataModel> {\n    if (typeof suffixDataEncodedString !== 'string') {\n      throw new SidetreeError(\n        ErrorCode.CreateOperationSuffixDataMissingOrNotString\n      );\n    }\n\n    const suffixDataJsonString = Encoder.decodeAsString(\n      suffixDataEncodedString\n    );\n    const suffixData = await JsonAsync.parse(suffixDataJsonString);\n\n    const properties = Object.keys(suffixData);\n    if (properties.length !== 2) {\n      throw new SidetreeError(\n        ErrorCode.CreateOperationSuffixDataMissingOrUnknownProperty\n      );\n    }\n\n    const delta_hash = Encoder.decodeAsBuffer(suffixData.delta_hash);\n    const nextRecoveryCommitment = Encoder.decodeAsBuffer(\n      suffixData.recovery_commitment\n    );\n\n    Multihash.verifyHashComputedUsingLatestSupportedAlgorithm(delta_hash);\n    Multihash.verifyHashComputedUsingLatestSupportedAlgorithm(\n      nextRecoveryCommitment\n    );\n\n    return {\n      delta_hash: suffixData.delta_hash,\n      recovery_commitment: suffixData.recovery_commitment,\n    };\n  }\n}\n","/*\n * The code in this file originated from\n * @see https://github.com/decentralized-identity/sidetree\n * For the list of changes that was made to the original code\n * @see https://github.com/transmute-industries/sidetree.js/blob/master/reference-implementation-changes.md\n *\n * Copyright 2020 - Transmute Industries Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  ErrorCode,\n  SidetreeError,\n  PublicKeyJwkSecp256k1,\n  PublicKeyJwkEd25519,\n  PrivateKeyJwkSecp256k1,\n  PrivateKeyJwkEd25519,\n  PrivateKeyJwk,\n  PublicKeyJwk,\n} from '@sidetree/common';\nimport { JWK } from 'jose';\nimport * as bip39 from 'bip39';\nimport { Ed25519KeyPair } from '@transmute/did-key-ed25519';\nimport hdkey from 'hdkey';\nimport { from as keytoFrom } from '@trust/keyto';\n\n/**\n * Class containing reusable JWK operations.\n */\nexport default class Jwk {\n  /**\n   * Generates ED25519 key pair.\n   * Mainly used for testing.\n   * @returns [publicKey, privateKey]\n   */\n  public static async generateEd25519KeyPair(): Promise<\n    [PublicKeyJwkEd25519, PrivateKeyJwkEd25519]\n  > {\n    const keyPair = await JWK.generate('OKP', 'Ed25519');\n    const privateKey = keyPair.toJWK(true) as PrivateKeyJwkEd25519;\n    const publicKey = keyPair.toJWK(false) as PublicKeyJwkEd25519;\n    return [publicKey, privateKey];\n  }\n\n  // Helper method to generate keys from a mnemonic\n  public static async getBufferAtIndex(\n    mnemonic: string,\n    index: number\n  ): Promise<Buffer> {\n    const seed = await bip39.mnemonicToSeed(mnemonic);\n    const root = hdkey.fromMasterSeed(seed);\n    // TODO: 60 is specific to ethereum, we could use another value unique to sidetree\n    const hdPath = `m/44'/60'/0'/0/${index}`;\n    const addrNode = root.derive(hdPath);\n    return addrNode.privateKey;\n  }\n\n  private static async generateEd25519KeyPairFromMnemonic(\n    mnemonic: string,\n    index: number\n  ): Promise<[PublicKeyJwkEd25519, PrivateKeyJwkEd25519]> {\n    const privateKeyBuffer = await Jwk.getBufferAtIndex(mnemonic, index);\n    const keyPair = await Ed25519KeyPair.generate({\n      seed: privateKeyBuffer,\n    });\n    const ed25519KeyPair = new Ed25519KeyPair(keyPair);\n    const publicKeyJwk = (await ed25519KeyPair.toJwk(\n      false\n    )) as PublicKeyJwkEd25519;\n    const privateKeyJwk = (await ed25519KeyPair.toJwk(\n      true\n    )) as PrivateKeyJwkEd25519;\n    return [publicKeyJwk, privateKeyJwk];\n  }\n\n  /**\n   * Generates SECP256K1 key pair.\n   * Mainly used for testing.\n   * @returns [publicKey, privateKey]\n   */\n  public static async generateSecp256k1KeyPair(): Promise<\n    [PublicKeyJwkSecp256k1, PrivateKeyJwkSecp256k1]\n  > {\n    const keyPair = await JWK.generate('EC', 'secp256k1');\n    const publicKey = keyPair.toJWK(false) as PublicKeyJwkSecp256k1;\n    const privateKey = keyPair.toJWK(true) as PrivateKeyJwkSecp256k1;\n    return [publicKey, privateKey];\n  }\n\n  public static async generateJwkKeyPairFromMnemonic(\n    keyType: string,\n    mnemonic: string,\n    index: number\n  ): Promise<[PublicKeyJwk, PrivateKeyJwk]> {\n    switch (keyType) {\n      case 'secp256k1':\n        return this.generateSecp256k1KeyPairFromMnemonic(mnemonic, index);\n      case 'ed25519':\n        return this.generateEd25519KeyPairFromMnemonic(mnemonic, index);\n      default:\n        throw new Error('Invalid key type');\n    }\n  }\n\n  private static async generateSecp256k1KeyPairFromMnemonic(\n    mnemonic: string,\n    index: number\n  ): Promise<[PublicKeyJwkSecp256k1, PrivateKeyJwkSecp256k1]> {\n    const privateKeyBuffer = await Jwk.getBufferAtIndex(mnemonic, index);\n    const publicKeyJwk = keytoFrom(privateKeyBuffer, 'blk').toJwk('public');\n    publicKeyJwk.crv = 'secp256k1';\n    const privateKeyJwk = keytoFrom(privateKeyBuffer, 'blk').toJwk('private');\n    privateKeyJwk.crv = 'secp256k1';\n    return [publicKeyJwk, privateKeyJwk];\n  }\n\n  /**\n   * Validates the given key is a public key in JWK format allowed by Sidetree.\n   * @throws SidetreeError if given object is not a key in JWK format allowed by Sidetree.\n   */\n  public static validatePublicJwk(jwk: any): void {\n    if (jwk === undefined) {\n      throw new SidetreeError(ErrorCode.JwkUndefined);\n    }\n\n    // TODO: Check validity with JSON schema...\n    const allowedProperties = new Set(['kty', 'crv', 'x', 'y', 'kid']);\n    for (const property in jwk) {\n      if (!allowedProperties.has(property)) {\n        throw new SidetreeError(ErrorCode.JwkHasUnknownProperty);\n      }\n    }\n\n    switch (jwk.crv) {\n      case 'Ed25519':\n        if (jwk.kty !== 'OKP') {\n          throw new SidetreeError(ErrorCode.JwkMissingOrInvalidKty);\n        }\n        if (typeof jwk.x !== 'string') {\n          throw new SidetreeError(ErrorCode.JwkMissingOrInvalidTypeX);\n        }\n        break;\n      case 'secp256k1':\n        if (jwk.kty !== 'EC') {\n          throw new SidetreeError(ErrorCode.JwkMissingOrInvalidKty);\n        }\n        if (typeof jwk.x !== 'string') {\n          throw new SidetreeError(ErrorCode.JwkMissingOrInvalidTypeX);\n        }\n        if (typeof jwk.y !== 'string') {\n          throw new SidetreeError(ErrorCode.JwkMissingOrInvalidTypeY);\n        }\n        break;\n      default:\n        throw new SidetreeError(ErrorCode.JwkMissingOrInvalidCrv);\n    }\n  }\n\n  /**\n   * Gets the public key given the private ES256K key.\n   * Mainly used for testing purposes.\n   */\n  public static getCurve25519PublicKey(\n    privateKey: PrivateKeyJwkEd25519\n  ): PublicKeyJwkEd25519 {\n    const keyCopy = Object.assign({}, privateKey);\n\n    // Delete the private key portion.\n    delete keyCopy.d;\n\n    return keyCopy;\n  }\n}\n","/*\n * The code in this file originated from\n * @see https://github.com/decentralized-identity/sidetree\n * For the list of changes that was made to the original code\n * @see https://github.com/transmute-industries/sidetree.js/blob/master/reference-implementation-changes.md\n *\n * Copyright 2020 - Transmute Industries Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Encoder,\n  ErrorCode,\n  SidetreeError,\n  PublicKeyJwk,\n  PrivateKeyJwk,\n} from '@sidetree/common';\nimport { EdDSA } from '@transmute/did-key-ed25519';\nimport { ES256K } from '@transmute/did-key-secp256k1';\n\n/**\n * Class containing reusable JWS operations.\n */\nexport default class Jws {\n  /** Protected header. */\n  public readonly protected: string;\n  /** Payload. */\n  public readonly payload: string;\n  /** Signature. */\n  public readonly signature: string;\n\n  /**\n   * Constructs a JWS object.\n   * @param compactJws Input should be a compact JWS string.\n   */\n  private constructor(compactJws: any) {\n    if (typeof compactJws !== 'string') {\n      throw new SidetreeError(ErrorCode.JwsCompactJwsNotString);\n    }\n\n    const parts = compactJws.split('.');\n    if (parts.length !== 3) {\n      throw new SidetreeError(ErrorCode.JwsCompactJwsInvalid);\n    }\n\n    const protectedHeader = parts[0];\n    const payload = parts[1];\n    const signature = parts[2];\n\n    const decodedProtectedHeadJsonString = Encoder.decodeBase64UrlAsString(\n      protectedHeader\n    );\n    const decodedProtectedHeader = JSON.parse(decodedProtectedHeadJsonString);\n\n    const expectedHeaderPropertyCount = 1; // By default we must have header property is `alg`.\n\n    const headerProperties = Object.keys(decodedProtectedHeader);\n    if (headerProperties.length !== expectedHeaderPropertyCount) {\n      throw new SidetreeError(\n        ErrorCode.JwsProtectedHeaderMissingOrUnknownProperty\n      );\n    }\n\n    // Protected header must contain 'alg' property with value 'EdDSA'.\n    if (\n      decodedProtectedHeader.alg !== 'EdDSA' &&\n      decodedProtectedHeader.alg !== 'ES256K'\n    ) {\n      throw new SidetreeError(\n        ErrorCode.JwsProtectedHeaderMissingOrIncorrectAlg\n      );\n    }\n\n    // Must contain Base64URL string 'signature' property.\n    if (!Encoder.isBase64UrlString(signature)) {\n      throw new SidetreeError(ErrorCode.JwsSignatureNotBase64UrlString);\n    }\n\n    // Must contain Base64URL string 'payload' property.\n    if (!Encoder.isBase64UrlString(payload)) {\n      throw new SidetreeError(ErrorCode.JwsPayloadNotBase64UrlString);\n    }\n\n    this.protected = protectedHeader;\n    this.payload = payload;\n    this.signature = signature;\n  }\n\n  /**\n   * Converts this object to a compact JWS string.\n   */\n  public toCompactJws(): string {\n    return Jws.createCompactJws(this.protected, this.payload, this.signature);\n  }\n\n  /**\n   * Verifies the JWS signature.\n   * @returns true if signature is successfully verified, false otherwise.\n   */\n  public async verifySignature(publicKey: PublicKeyJwk): Promise<boolean> {\n    return Jws.verifySignature(\n      this.protected,\n      this.payload,\n      this.signature,\n      publicKey\n    );\n  }\n\n  /**\n   * Verifies the JWS signature.\n   * @returns true if signature is successfully verified, false otherwise.\n   */\n  public static async verifySignature(\n    encodedProtectedHeader: string,\n    encodedPayload: string,\n    signature: string,\n    publicKey: PublicKeyJwk\n  ): Promise<boolean> {\n    const jwsSigningInput =\n      encodedProtectedHeader + '.' + encodedPayload + '.' + signature;\n    const signatureValid = await Jws.verifyCompactJws(\n      jwsSigningInput,\n      publicKey\n    );\n    return signatureValid;\n  }\n\n  /**\n   * Verifies the compact JWS string using the given JWK key.\n   * @returns true if signature is valid; else otherwise.\n   */\n  public static async verifyCompactJws(\n    compactJws: string,\n    jwk: PublicKeyJwk\n  ): Promise<boolean> {\n    try {\n      if (jwk.crv === 'Ed25519') {\n        await EdDSA.verify(compactJws, jwk);\n      } else if (jwk.crv === 'secp256k1') {\n        await ES256K.verify(compactJws, jwk as any);\n      } else {\n        return false;\n      }\n      return true;\n    } catch (error) {\n      console.log(\n        `Input '${compactJws}' failed signature verification: ${SidetreeError.createFromError(\n          ErrorCode.JwsFailedSignatureValidation,\n          error\n        )}`\n      );\n      return false;\n    }\n  }\n\n  /**\n   * Signs the given payload as a compact JWS string.\n   * This is mainly used by tests to create valid test data.\n   */\n  public static async signAsCompactJws(\n    payload: object,\n    privateKey: PrivateKeyJwk,\n    protectedHeader?: any\n  ): Promise<string> {\n    let alg;\n    if (protectedHeader && protectedHeader.alg) {\n      alg = protectedHeader.alg;\n    } else {\n      if (privateKey.crv === 'Ed25519') {\n        alg = 'EdDSA';\n      } else {\n        alg = 'ES256K';\n      }\n    }\n    const header = {\n      ...protectedHeader,\n      alg,\n    };\n    if (privateKey.crv === 'secp256k1') {\n      return await ES256K.sign(payload, privateKey as any, header);\n    }\n    return await EdDSA.sign(payload, privateKey, header);\n  }\n\n  /**\n   * Parses the input as a `Jws` object.\n   */\n  public static parseCompactJws(compactJws: any): Jws {\n    return new Jws(compactJws);\n  }\n\n  /**\n   * Creates a compact JWS string using the given input. No string validation is performed.\n   */\n  public static createCompactJws(\n    protectedHeader: string,\n    payload: string,\n    signature: string\n  ): string {\n    return protectedHeader + '.' + payload + '.' + signature;\n  }\n}\n","/*\n * The code in this file originated from\n * @see https://github.com/decentralized-identity/sidetree\n * For the list of changes that was made to the original code\n * @see https://github.com/transmute-industries/sidetree.js/blob/master/reference-implementation-changes.md\n *\n * Copyright 2020 - Transmute Industries Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Encoder,\n  ErrorCode,\n  PublicKeyJwk,\n  OperationModel,\n  OperationType,\n  SidetreeError,\n} from '@sidetree/common';\nimport JsonAsync from './util/JsonAsync';\nimport Jwk from './util/Jwk';\nimport Jws from './util/Jws';\n\ninterface SignedDataModel {\n  didSuffix: string;\n  recovery_key: PublicKeyJwk;\n}\n\n/**\n * A class that represents a deactivate operation.\n */\nexport default class DeactivateOperation implements OperationModel {\n  /** The original request buffer sent by the requester. */\n  public readonly operationBuffer: Buffer;\n\n  /** The unique suffix of the DID. */\n  public readonly didUniqueSuffix: string;\n\n  /** The type of operation. */\n  public readonly type: OperationType;\n\n  /** Signed data. */\n  public readonly signedDataJws: Jws;\n\n  /** Decoded signed data payload. */\n  public readonly signedData: SignedDataModel;\n\n  /**\n   * NOTE: should only be used by `parse()` and `parseObject()` else the contructed instance could be invalid.\n   */\n  private constructor(\n    operationBuffer: Buffer,\n    didUniqueSuffix: string,\n    signedDataJws: Jws,\n    signedData: SignedDataModel\n  ) {\n    this.operationBuffer = operationBuffer;\n    this.type = OperationType.Deactivate;\n    this.didUniqueSuffix = didUniqueSuffix;\n    this.signedDataJws = signedDataJws;\n    this.signedData = signedData;\n  }\n\n  /**\n   * Parses the given input as a deactivate operation entry in the anchor file.\n   */\n  public static async parseOperationFromAnchorFile(\n    input: any\n  ): Promise<DeactivateOperation> {\n    const operationBuffer = Buffer.from(JSON.stringify(input));\n    const operation = await DeactivateOperation.parseObject(\n      input,\n      operationBuffer,\n      true\n    );\n    return operation;\n  }\n\n  /**\n   * Parses the given buffer as a `UpdateOperation`.\n   */\n  public static async parse(\n    operationBuffer: Buffer\n  ): Promise<DeactivateOperation> {\n    const operationJsonString = operationBuffer.toString();\n    const operationObject = await JsonAsync.parse(operationJsonString);\n    const deactivateOperation = await DeactivateOperation.parseObject(\n      operationObject,\n      operationBuffer,\n      false\n    );\n    return deactivateOperation;\n  }\n\n  /**\n   * Parses the given operation object as a `DeactivateOperation`.\n   * The `operationBuffer` given is assumed to be valid and is assigned to the `operationBuffer` directly.\n   * NOTE: This method is purely intended to be used as an optimization method over the `parse` method in that\n   * JSON parsing is not required to be performed more than once when an operation buffer of an unknown operation type is given.\n   * @param anchorFileMode If set to true, then `type` is expected to be absent.\n   */\n  public static async parseObject(\n    operationObject: any,\n    operationBuffer: Buffer,\n    anchorFileMode: boolean\n  ): Promise<DeactivateOperation> {\n    let expectedPropertyCount = 3;\n    if (anchorFileMode) {\n      expectedPropertyCount = 2;\n    }\n\n    const properties = Object.keys(operationObject);\n    if (properties.length !== expectedPropertyCount) {\n      throw new SidetreeError(\n        ErrorCode.DeactivateOperationMissingOrUnknownProperty\n      );\n    }\n\n    if (typeof operationObject.did_suffix !== 'string') {\n      throw new SidetreeError(\n        ErrorCode.DeactivateOperationMissingOrInvalidDidUniqueSuffix\n      );\n    }\n\n    const signedDataJws = Jws.parseCompactJws(operationObject.signed_data);\n    const signedData = await DeactivateOperation.parseSignedDataPayload(\n      signedDataJws.payload,\n      operationObject.did_suffix\n    );\n\n    // If not in anchor file mode, we need to validate `type` property.\n    if (!anchorFileMode) {\n      if (operationObject.type !== OperationType.Deactivate) {\n        throw new SidetreeError(ErrorCode.DeactivateOperationTypeIncorrect);\n      }\n    }\n\n    return new DeactivateOperation(\n      operationBuffer,\n      operationObject.did_suffix,\n      signedDataJws,\n      signedData\n    );\n  }\n\n  private static async parseSignedDataPayload(\n    deltaEncodedString: string,\n    expectedDidUniqueSuffix: string\n  ): Promise<SignedDataModel> {\n    const signedDataJsonString = Encoder.decodeAsString(deltaEncodedString);\n    const signedData = await JsonAsync.parse(signedDataJsonString);\n\n    const properties = Object.keys(signedData);\n    if (properties.length !== 2) {\n      throw new SidetreeError(\n        ErrorCode.DeactivateOperationSignedDataMissingOrUnknownProperty\n      );\n    }\n\n    if (signedData.did_suffix !== expectedDidUniqueSuffix) {\n      throw new SidetreeError(\n        ErrorCode.DeactivateOperationSignedDidUniqueSuffixMismatch\n      );\n    }\n\n    Jwk.validatePublicJwk(signedData.recovery_key);\n\n    return {\n      didSuffix: signedData.did_suffix,\n      recovery_key: signedData.recovery_key,\n    };\n  }\n}\n","/*\n * The code in this file originated from\n * @see https://github.com/decentralized-identity/sidetree\n * For the list of changes that was made to the original code\n * @see https://github.com/transmute-industries/sidetree.js/blob/master/reference-implementation-changes.md\n *\n * Copyright 2020 - Transmute Industries Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  DeltaModel,\n  Encoder,\n  ErrorCode,\n  PublicKeyJwk,\n  Multihash,\n  OperationModel,\n  OperationType,\n  SidetreeError,\n} from '@sidetree/common';\nimport OperationUtils from './OperationUtils';\nimport JsonAsync from './util/JsonAsync';\nimport Jwk from './util/Jwk';\nimport Jws from './util/Jws';\n\ninterface SignedDataModel {\n  delta_hash: string;\n  recovery_key: PublicKeyJwk;\n  recovery_commitment: string;\n}\n\n/**\n * A class that represents a recover operation.\n */\nexport default class RecoverOperation implements OperationModel {\n  /** The original request buffer sent by the requester. */\n  public readonly operationBuffer: Buffer;\n\n  /** The unique suffix of the DID. */\n  public readonly didUniqueSuffix: string;\n\n  /** The type of operation. */\n  public readonly type: OperationType;\n\n  /** Signed data. */\n  public readonly signedDataJws: Jws;\n\n  /** Encoded string of the delta. */\n  public readonly encodedDelta: string | undefined;\n\n  /** Decoded signed data payload. */\n  public readonly signedData: SignedDataModel;\n\n  /** Patch data. */\n  public readonly delta: DeltaModel | undefined;\n\n  /**\n   * NOTE: should only be used by `parse()` and `parseObject()` else the constructed instance could be invalid.\n   */\n  private constructor(\n    operationBuffer: Buffer,\n    didUniqueSuffix: string,\n    signedDataJws: Jws,\n    signedData: SignedDataModel,\n    encodedDelta: string | undefined,\n    delta: DeltaModel | undefined\n  ) {\n    this.operationBuffer = operationBuffer;\n    this.type = OperationType.Recover;\n    this.didUniqueSuffix = didUniqueSuffix;\n    this.signedDataJws = signedDataJws;\n    this.signedData = signedData;\n    this.encodedDelta = encodedDelta;\n    this.delta = delta;\n  }\n\n  /**\n   * Parses the given input as a recover operation entry in the anchor file.\n   */\n  public static async parseOperationFromAnchorFile(\n    input: any\n  ): Promise<RecoverOperation> {\n    const operationBuffer = Buffer.from(JSON.stringify(input));\n    const operation = await RecoverOperation.parseObject(\n      input,\n      operationBuffer,\n      true\n    );\n    return operation;\n  }\n\n  /**\n   * Parses the given buffer as a `UpdateOperation`.\n   */\n  public static async parse(\n    operationBuffer: Buffer\n  ): Promise<RecoverOperation> {\n    const operationJsonString = operationBuffer.toString();\n    const operationObject = await JsonAsync.parse(operationJsonString);\n    const recoverOperation = await RecoverOperation.parseObject(\n      operationObject,\n      operationBuffer,\n      false\n    );\n    return recoverOperation;\n  }\n\n  /**\n   * Parses the given operation object as a `RecoverOperation`.\n   * The `operationBuffer` given is assumed to be valid and is assigned to the `operationBuffer` directly.\n   * NOTE: This method is purely intended to be used as an optimization method over the `parse` method in that\n   * JSON parsing is not required to be performed more than once when an operation buffer of an unknown operation type is given.\n   * @param anchorFileMode If set to true, then `delta` and `type` properties are expected to be absent.\n   */\n  public static async parseObject(\n    operationObject: any,\n    operationBuffer: Buffer,\n    anchorFileMode: boolean\n  ): Promise<RecoverOperation> {\n    let expectedPropertyCount = 4;\n    if (anchorFileMode) {\n      expectedPropertyCount = 2;\n    }\n\n    const properties = Object.keys(operationObject);\n    if (properties.length !== expectedPropertyCount) {\n      throw new SidetreeError(\n        ErrorCode.RecoverOperationMissingOrUnknownProperty\n      );\n    }\n\n    if (typeof operationObject.did_suffix !== 'string') {\n      throw new SidetreeError(\n        ErrorCode.RecoverOperationMissingOrInvalidDidUniqueSuffix\n      );\n    }\n\n    const signedDataJws = Jws.parseCompactJws(operationObject.signed_data);\n    const signedData = await RecoverOperation.parseSignedDataPayload(\n      signedDataJws.payload\n    );\n\n    // If not in anchor file mode, we need to validate `type` and `delta` properties.\n    let encodedDelta = undefined;\n    let delta = undefined;\n    if (!anchorFileMode) {\n      if (operationObject.type !== OperationType.Recover) {\n        throw new SidetreeError(ErrorCode.RecoverOperationTypeIncorrect);\n      }\n\n      encodedDelta = operationObject.delta;\n      try {\n        delta = await OperationUtils.parseDelta(operationObject.delta);\n      } catch {\n        // For compatibility with data pruning, we have to assume that delta may be unavailable,\n        // thus an operation with invalid delta needs to be processed as an operation with unavailable delta,\n        // so here we let delta be `undefined`.\n      }\n    }\n\n    return new RecoverOperation(\n      operationBuffer,\n      operationObject.did_suffix,\n      signedDataJws,\n      signedData,\n      encodedDelta,\n      delta\n    );\n  }\n\n  private static async parseSignedDataPayload(\n    signedDataEncodedString: string\n  ): Promise<SignedDataModel> {\n    const signedDataJsonString = Encoder.decodeAsString(\n      signedDataEncodedString\n    );\n    const signedData = await JsonAsync.parse(signedDataJsonString);\n\n    const properties = Object.keys(signedData);\n\n    // TODO: JSON Schema instead of property count type checking...\n    if (properties.length !== 3) {\n      throw new SidetreeError(\n        ErrorCode.RecoverOperationSignedDataMissingOrUnknownProperty\n      );\n    }\n\n    Jwk.validatePublicJwk(signedData.recovery_key);\n\n    const delta_hash = Encoder.decodeAsBuffer(signedData.delta_hash);\n    Multihash.verifyHashComputedUsingLatestSupportedAlgorithm(delta_hash);\n\n    const nextRecoveryCommitmentHash = Encoder.decodeAsBuffer(\n      signedData.recovery_commitment\n    );\n    Multihash.verifyHashComputedUsingLatestSupportedAlgorithm(\n      nextRecoveryCommitmentHash\n    );\n\n    return {\n      delta_hash: signedData.delta_hash,\n      recovery_key: signedData.recovery_key,\n      recovery_commitment: signedData.recovery_commitment,\n    };\n  }\n}\n","/*\n * The code in this file originated from\n * @see https://github.com/decentralized-identity/sidetree\n * For the list of changes that was made to the original code\n * @see https://github.com/transmute-industries/sidetree.js/blob/master/reference-implementation-changes.md\n *\n * Copyright 2020 - Transmute Industries Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { AnchorFileModel, ErrorCode, SidetreeError } from '@sidetree/common';\nimport ArrayMethods from '../util/ArrayMethods';\nimport Compressor from '../util/Compressor';\nimport CreateOperation from '../CreateOperation';\nimport DeactivateOperation from '../DeactivateOperation';\nimport JsonAsync from '../util/JsonAsync';\nimport RecoverOperation from '../RecoverOperation';\n\n/**\n * Class containing Anchor File related operations.\n */\nexport default class AnchorFile {\n  /**\n   * Class that represents an anchor file.\n   * NOTE: this class is introduced as an internal structure in replacement to `AnchorFileModel`\n   * to keep useful metadata so that repeated computation can be avoided.\n   */\n  private constructor(\n    public readonly model: AnchorFileModel,\n    public readonly didUniqueSuffixes: string[],\n    public readonly createOperations: CreateOperation[],\n    public readonly recoverOperations: RecoverOperation[],\n    public readonly deactivateOperations: DeactivateOperation[]\n  ) {}\n\n  /**\n   * Parses and validates the given anchor file buffer.\n   * @throws `SidetreeError` if failed parsing or validation.\n   */\n  public static async parse(anchorFileBuffer: Buffer): Promise<AnchorFile> {\n    let anchorFileDecompressedBuffer;\n    try {\n      anchorFileDecompressedBuffer = await Compressor.decompress(\n        anchorFileBuffer\n      );\n    } catch (e) {\n      throw SidetreeError.createFromError(\n        ErrorCode.AnchorFileDecompressionFailure,\n        e\n      );\n    }\n\n    let anchorFileModel;\n    try {\n      anchorFileModel = await JsonAsync.parse(anchorFileDecompressedBuffer);\n    } catch (e) {\n      throw SidetreeError.createFromError(ErrorCode.AnchorFileNotJson, e);\n    }\n\n    const allowedProperties = new Set([\n      'map_file_uri',\n      'operations',\n      'writer_lock_id',\n    ]);\n    for (const property in anchorFileModel) {\n      if (!allowedProperties.has(property)) {\n        throw new SidetreeError(ErrorCode.AnchorFileHasUnknownProperty);\n      }\n    }\n\n    if (\n      !Object.prototype.hasOwnProperty.call(anchorFileModel, 'map_file_uri')\n    ) {\n      throw new SidetreeError(ErrorCode.AnchorFileMapFileHashMissing);\n    }\n\n    if (!Object.prototype.hasOwnProperty.call(anchorFileModel, 'operations')) {\n      throw new SidetreeError(ErrorCode.AnchorFileMissingOperationsProperty);\n    }\n\n    if (\n      Object.prototype.hasOwnProperty.call(anchorFileModel, 'writer_lock_id') &&\n      typeof anchorFileModel.writer_lock_id !== 'string'\n    ) {\n      throw new SidetreeError(ErrorCode.AnchorFileWriterLockIPropertyNotString);\n    }\n\n    // Map file hash validations.\n    const mapFileUri = anchorFileModel.map_file_uri;\n    if (typeof mapFileUri !== 'string') {\n      throw new SidetreeError(ErrorCode.AnchorFileMapFileHashNotString);\n    }\n\n    const allowedOperationsProperties = new Set([\n      'create',\n      'recover',\n      'deactivate',\n    ]);\n    const operations = anchorFileModel.operations;\n    for (const property in operations) {\n      if (!allowedOperationsProperties.has(property)) {\n        throw new SidetreeError(\n          ErrorCode.AnchorFileUnexpectedPropertyInOperations,\n          `Unexpected property ${property} in 'operations' property in anchor file.`\n        );\n      }\n    }\n\n    // Will be populated for later validity check.\n    const didUniqueSuffixes: string[] = [];\n\n    // Validate `create` if exists.\n    const createOperations: CreateOperation[] = [];\n    if (operations.create !== undefined) {\n      if (!Array.isArray(operations.create)) {\n        throw new SidetreeError(ErrorCode.AnchorFileCreatePropertyNotArray);\n      }\n\n      // Validate every create operation.\n      for (const operation of operations.create) {\n        const createOperation = await CreateOperation.parseOperationFromAnchorFile(\n          operation\n        );\n        createOperations.push(createOperation);\n        didUniqueSuffixes.push(createOperation.didUniqueSuffix);\n      }\n    }\n\n    // Validate `recover` if exists.\n    const recoverOperations: RecoverOperation[] = [];\n    if (operations.recover !== undefined) {\n      if (!Array.isArray(operations.recover)) {\n        throw new SidetreeError(ErrorCode.AnchorFileRecoverPropertyNotArray);\n      }\n\n      // Validate every recover operation.\n      for (const operation of operations.recover) {\n        const recoverOperation = await RecoverOperation.parseOperationFromAnchorFile(\n          operation\n        );\n        recoverOperations.push(recoverOperation);\n        didUniqueSuffixes.push(recoverOperation.didUniqueSuffix);\n      }\n    }\n\n    // Validate `deactivate` if exists.\n    const deactivateOperations: DeactivateOperation[] = [];\n    if (operations.deactivate !== undefined) {\n      if (!Array.isArray(operations.deactivate)) {\n        throw new SidetreeError(ErrorCode.AnchorFileDeactivatePropertyNotArray);\n      }\n\n      // Validate every operation.\n      for (const operation of operations.deactivate) {\n        const deactivateOperation = await DeactivateOperation.parseOperationFromAnchorFile(\n          operation\n        );\n        deactivateOperations.push(deactivateOperation);\n        didUniqueSuffixes.push(deactivateOperation.didUniqueSuffix);\n      }\n    }\n\n    if (ArrayMethods.hasDuplicates(didUniqueSuffixes)) {\n      throw new SidetreeError(\n        ErrorCode.AnchorFileMultipleOperationsForTheSameDid\n      );\n    }\n\n    const anchorFile = new AnchorFile(\n      anchorFileModel,\n      didUniqueSuffixes,\n      createOperations,\n      recoverOperations,\n      deactivateOperations\n    );\n    return anchorFile;\n  }\n\n  /**\n   * Creates an `AnchorFileModel`.\n   */\n  public static async createModel(\n    writerLockId: string | undefined,\n    mapFileHash: string,\n    createOperationArray: CreateOperation[],\n    recoverOperationArray: RecoverOperation[],\n    deactivateOperationArray: DeactivateOperation[]\n  ): Promise<AnchorFileModel> {\n    const createOperations = createOperationArray.map((operation) => {\n      return {\n        suffix_data: operation.encodedSuffixData,\n      };\n    });\n\n    const recoverOperations = recoverOperationArray.map((operation) => {\n      return {\n        did_suffix: operation.didUniqueSuffix,\n        signed_data: operation.signedDataJws.toCompactJws(),\n      };\n    });\n\n    const deactivateOperations = deactivateOperationArray.map((operation) => {\n      return {\n        did_suffix: operation.didUniqueSuffix,\n        signed_data: operation.signedDataJws.toCompactJws(),\n      };\n    });\n\n    const anchorFileModel = {\n      writer_lock_id: writerLockId,\n      map_file_uri: mapFileHash,\n      operations: {\n        create: createOperations,\n        recover: recoverOperations,\n        deactivate: deactivateOperations,\n      },\n    };\n\n    return anchorFileModel;\n  }\n\n  /**\n   * Creates an anchor file buffer.\n   */\n  public static async createBuffer(\n    writerLockId: string | undefined,\n    mapFileHash: string,\n    createOperations: CreateOperation[],\n    recoverOperations: RecoverOperation[],\n    deactivateOperations: DeactivateOperation[]\n  ): Promise<Buffer> {\n    const anchorFileModel = await AnchorFile.createModel(\n      writerLockId,\n      mapFileHash,\n      createOperations,\n      recoverOperations,\n      deactivateOperations\n    );\n    const anchorFileJson = JSON.stringify(anchorFileModel);\n    const anchorFileBuffer = Buffer.from(anchorFileJson);\n\n    return Compressor.compress(anchorFileBuffer);\n  }\n}\n","/*\n * The code in this file originated from\n * @see https://github.com/decentralized-identity/sidetree\n * For the list of changes that was made to the original code\n * @see https://github.com/transmute-industries/sidetree.js/blob/master/reference-implementation-changes.md\n *\n * Copyright 2020 - Transmute Industries Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { IBlockchain, IVersionManager } from '@sidetree/common';\nimport timeSpan from 'time-span';\n\n/**\n * Class that performs periodic writing of batches of Sidetree operations to CAS and blockchain.\n */\nexport default class BatchScheduler {\n  /**\n   * Denotes if the periodic batch writing should continue to occur.\n   * Used mainly for test purposes.\n   */\n  private continuePeriodicBatchWriting = false;\n\n  public constructor(\n    private versionManager: IVersionManager,\n    private blockchain: IBlockchain,\n    private batchingIntervalInSeconds: number\n  ) {}\n\n  /**\n   * The function that starts periodically anchoring operation batches to blockchain.\n   */\n  public startPeriodicBatchWriting() {\n    this.continuePeriodicBatchWriting = true;\n    setImmediate(async () => this.writeOperationBatch());\n  }\n\n  /**\n   * Stops periodic batch writing.\n   * Mainly used for test purposes.\n   */\n  public stopPeriodicBatchWriting() {\n    console.info(`Stopped periodic batch writing.`);\n    this.continuePeriodicBatchWriting = false;\n  }\n\n  /**\n   * Processes the operations in the queue.\n   */\n  public async writeOperationBatch() {\n    const endTimer = timeSpan(); // For calcuating time taken to write operations.\n\n    try {\n      console.info('Start operation batch writing...');\n\n      // Get the correct version of the `BatchWriter`.\n      const currentTime = this.blockchain.approximateTime.time;\n      const batchWriter = this.versionManager.getBatchWriter(currentTime);\n\n      await batchWriter.write();\n    } catch (error) {\n      console.error(\n        'Unexpected and unhandled error during batch writing, investigate and fix:'\n      );\n      console.error(error);\n    } finally {\n      console.info(`End batch writing. Duration: ${endTimer.rounded()} ms.`);\n\n      if (this.continuePeriodicBatchWriting) {\n        console.info(\n          `Waiting for ${this.batchingIntervalInSeconds} seconds before writing another batch.`\n        );\n        setTimeout(\n          async () => this.writeOperationBatch(),\n          this.batchingIntervalInSeconds * 1000\n        );\n      }\n    }\n  }\n}\n","/*\n * The code in this file originated from\n * @see https://github.com/decentralized-identity/sidetree\n * For the list of changes that was made to the original code\n * @see https://github.com/transmute-industries/sidetree.js/blob/master/reference-implementation-changes.md\n *\n * Copyright 2020 - Transmute Industries Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  ChunkFileModel,\n  ErrorCode,\n  SidetreeError,\n  protocolParameters,\n} from '@sidetree/common';\nimport timeSpan from 'time-span';\nimport CreateOperation from '../CreateOperation';\nimport RecoverOperation from '../RecoverOperation';\nimport UpdateOperation from '../UpdateOperation';\nimport Compressor from '../util/Compressor';\nimport JsonAsync from '../util/JsonAsync';\n\n/**\n * Defines schema of a Chunk File and its related operations.\n * NOTE: Must NOT add properties not defined by Sidetree protocol.\n */\nexport default class ChunkFile {\n  /**\n   * Parses and validates the given chunk file buffer and all the operations within it.\n   * @throws SidetreeError if failed parsing or validation.\n   */\n  public static async parse(chunkFileBuffer: Buffer): Promise<ChunkFileModel> {\n    const endTimer = timeSpan();\n    const decompressedChunkFileBuffer = await Compressor.decompress(\n      chunkFileBuffer\n    );\n    const chunkFileObject = await JsonAsync.parse(decompressedChunkFileBuffer);\n    console.info(`Parsed chunk file in ${endTimer.rounded()} ms.`);\n\n    // Ensure only properties specified by Sidetree protocol are given.\n    const allowedProperties = new Set(['deltas']);\n    for (const property in chunkFileObject) {\n      if (!allowedProperties.has(property)) {\n        throw new SidetreeError(\n          ErrorCode.ChunkFileUnexpectedProperty,\n          `Unexpected property ${property} in chunk file.`\n        );\n      }\n    }\n\n    this.validateDeltasProperty(chunkFileObject.deltas);\n\n    return chunkFileObject;\n  }\n\n  private static validateDeltasProperty(deltas: any) {\n    // Make sure deltas is an array.\n    if (!(deltas instanceof Array)) {\n      throw new SidetreeError(\n        ErrorCode.ChunkFileDeltasPropertyNotArray,\n        'Invalid chunk file, deltas property is not an array.'\n      );\n    }\n\n    // Validate every encoded delta string.\n    for (const encodedDelta of deltas) {\n      if (typeof encodedDelta !== 'string') {\n        throw new SidetreeError(\n          ErrorCode.ChunkFileDeltasNotArrayOfStrings,\n          'Invalid chunk file, deltas property is not an array of strings.'\n        );\n      }\n\n      const deltaBuffer = Buffer.from(encodedDelta);\n\n      // Verify size of each delta does not exceed the maximum allowed limit.\n      if (deltaBuffer.length > protocolParameters.maxDeltaSizeInBytes) {\n        throw new SidetreeError(\n          ErrorCode.ChunkFileDeltaSizeExceedsLimit,\n          `Operation size of ${deltaBuffer.length} bytes exceeds the allowed limit of ${protocolParameters.maxDeltaSizeInBytes} bytes.`\n        );\n      }\n    }\n  }\n\n  /**\n   * Creates chunk file buffer.\n   */\n  public static async createBuffer(\n    createOperations: CreateOperation[],\n    recoverOperations: RecoverOperation[],\n    updateOperations: UpdateOperation[]\n  ) {\n    const deltas = [];\n    deltas.push(\n      ...createOperations.map((operation) => operation.encodedDelta!)\n    );\n    deltas.push(\n      ...recoverOperations.map((operation) => operation.encodedDelta!)\n    );\n    deltas.push(\n      ...updateOperations.map((operation) => operation.encodedDelta!)\n    );\n\n    const chunkFileModel = {\n      deltas,\n    };\n\n    const rawData = Buffer.from(JSON.stringify(chunkFileModel));\n    const compressedRawData = await Compressor.compress(Buffer.from(rawData));\n\n    return compressedRawData;\n  }\n}\n","/*\n * The code in this file originated from\n * @see https://github.com/decentralized-identity/sidetree\n * For the list of changes that was made to the original code\n * @see https://github.com/transmute-industries/sidetree.js/blob/master/reference-implementation-changes.md\n *\n * Copyright 2020 - Transmute Industries Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as crypto from 'crypto';\nimport { ICas, FetchResult } from '@sidetree/common';\n\n/**\n * Interface containing information regarding each queued CAS download.\n */\ninterface DownloadInfo {\n  /**\n   * A globally unique handle to this download.\n   */\n  handle: Buffer;\n\n  /**\n   * The content hash used to perform the download from CAS.\n   */\n  contentHash: string;\n\n  /**\n   * The maximum allowed content size.\n   */\n  maxSizeInBytes: number;\n\n  /**\n   * The resolve function that will be invoked by the download manager when download is completed\n   * regarless if the download is successful or not.\n   */\n  resolve: (value?: any | PromiseLike<any> | undefined) => void;\n\n  /**\n   * Set to true if download attempt is completed either successfully or unsuccessfully.\n   */\n  completed: boolean;\n\n  /**\n   * Holds the fetch result once the download is completed.\n   */\n  fetchResult?: FetchResult;\n}\n\n/**\n * A download manager class that performs multiple downloads at the same time.\n */\nexport default class DownloadManager {\n  private pendingDownloads: DownloadInfo[] = [];\n  private activeDownloads: Map<Buffer, DownloadInfo> = new Map();\n  private completedDownloads: Map<Buffer, FetchResult> = new Map();\n\n  /**\n   * Constructs the download manager.\n   * @param cas The Content Adressable Store to use for fetching the actual content.\n   */\n  public constructor(public maxConcurrentDownloads: number, private cas: ICas) {\n    // If maximum concurrent CAS download count is NaN, set it to a default value.\n    if (isNaN(maxConcurrentDownloads)) {\n      const defaultmaxConcurrentDownloads = 20;\n      console.info(\n        `Maximum concurrent CAS download count not given, defaulting to ${defaultmaxConcurrentDownloads}.`\n      );\n      this.maxConcurrentDownloads = defaultmaxConcurrentDownloads;\n    }\n  }\n\n  /**\n   * Starts pending downloads if maximum concurrent download count is not reached,\n   * and resolve downloads that are completed, then invokes this same method again,\n   * thus this method must only be invoked once externally as initialization.\n   */\n  public start() {\n    try {\n      // Move all completed downloads in `activeDownloads` to the `completedDownloads` map.\n      const completedDownloadHandles = [];\n      for (const [downloadHandle, downloadInfo] of this.activeDownloads) {\n        if (downloadInfo.completed) {\n          this.completedDownloads.set(\n            downloadHandle,\n            downloadInfo.fetchResult!\n          );\n          completedDownloadHandles.push(downloadHandle);\n\n          // Resolve the promise associated with the download.\n          downloadInfo.resolve();\n        }\n      }\n      for (const downloadHandle of completedDownloadHandles) {\n        this.activeDownloads.delete(downloadHandle);\n      }\n\n      // If maximum concurrent download count is reached, then we can't schedule more downloads.\n      const availableDownloadLanes =\n        this.maxConcurrentDownloads - this.activeDownloads.size;\n      if (availableDownloadLanes <= 0) {\n        return;\n      }\n\n      // Else we can schedule more downloads, but only if there are pending downloads.\n      if (this.pendingDownloads.length === 0) {\n        return;\n      }\n\n      // Keep start downloading the next queued item until all download lanes are full or there is no more item to download.\n      for (\n        let i = 0;\n        i < this.pendingDownloads.length && i < availableDownloadLanes;\n        i++\n      ) {\n        const downloadInfo = this.pendingDownloads[i];\n\n        // Intentionally not awaiting on a download.\n        void this.downloadAsync(downloadInfo);\n        this.activeDownloads.set(downloadInfo.handle, downloadInfo);\n      }\n\n      // Remove active downloads from `pendingDownloads` list.\n      this.pendingDownloads.splice(0, availableDownloadLanes);\n    } catch (error) {\n      console.error(\n        `Encountered unhandled/unexpected error in DownloadManager, must investigate and fix: ${error}`\n      );\n    } finally {\n      setTimeout(async () => this.start(), 1000);\n    }\n  }\n\n  /**\n   * Downloads the content of the given content hash.\n   * @param contentHash Hash of the content to be downloaded.\n   */\n  public async download(\n    contentHash: string,\n    maxSizeInBytes: number\n  ): Promise<FetchResult> {\n    const handle = crypto.randomBytes(32);\n    const fetchPromise = new Promise((resolve) => {\n      const downloadInfo = {\n        handle,\n        contentHash,\n        maxSizeInBytes,\n        resolve,\n        completed: false,\n        content: undefined,\n      };\n      this.pendingDownloads.push(downloadInfo);\n    });\n\n    await fetchPromise;\n\n    const fetchResult = this.completedDownloads.get(handle);\n    this.completedDownloads.delete(handle);\n\n    return fetchResult!;\n  }\n\n  /**\n   * The internal download method that gets called by the main download manager monitoring loop when download lanes are available to download content.\n   * NOTE: This method MUST NEVER throw (more accurately: ALWAYS set downloadInfo.completed = true),\n   * else it will LEAK the available download lanes and in turn hang the Observer.\n   * @param downloadInfo Data structure containing `completed` flag and `fetchResult`,\n   *                     used to signal to the main download manager monitoring loop when the requested download is completed.\n   */\n  private async downloadAsync(downloadInfo: DownloadInfo): Promise<void> {\n    let contentHash = '';\n    try {\n      contentHash = downloadInfo.contentHash;\n\n      const fetchResult = await this.cas.read(\n        contentHash\n        // downloadInfo.maxSizeInBytes\n      );\n\n      downloadInfo.fetchResult = fetchResult;\n    } catch (error) {\n      console.error(\n        `Unexpected error while downloading '${contentHash}, investigate and fix ${error}'.`\n      );\n    } finally {\n      downloadInfo.completed = true;\n    }\n  }\n}\n","/*\n * The code in this file originated from\n * @see https://github.com/decentralized-identity/sidetree\n * For the list of changes that was made to the original code\n * @see https://github.com/transmute-industries/sidetree.js/blob/master/reference-implementation-changes.md\n *\n * Copyright 2020 - Transmute Industries Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  DeltaModel,\n  Encoder,\n  ErrorCode,\n  PublicKeyJwk,\n  Multihash,\n  OperationModel,\n  OperationType,\n  SidetreeError,\n} from '@sidetree/common';\nimport JsonAsync from './util/JsonAsync';\nimport Jwk from './util/Jwk';\nimport Jws from './util/Jws';\nimport OperationUtils from './OperationUtils';\n\ninterface SignedDataModel {\n  delta_hash: string;\n  update_key: PublicKeyJwk;\n}\n\n/**\n * A class that represents an update operation.\n */\nexport default class UpdateOperation implements OperationModel {\n  /** The original request buffer sent by the requester. */\n  public readonly operationBuffer: Buffer;\n\n  /** The unique suffix of the DID. */\n  public readonly didUniqueSuffix: string;\n\n  /** The type of operation. */\n  public readonly type: OperationType;\n\n  /** Signed data for the operation. */\n  public readonly signedDataJws: Jws;\n\n  /** Decoded signed data payload. */\n  public readonly signedData: SignedDataModel;\n\n  /** Patch data. */\n  public readonly delta: DeltaModel | undefined;\n\n  /** Encoded string of the delta. */\n  public readonly encodedDelta: string | undefined;\n\n  /**\n   * NOTE: should only be used by `parse()` and `parseObject()` else the contructed instance could be invalid.\n   */\n  private constructor(\n    operationBuffer: Buffer,\n    didUniqueSuffix: string,\n    signedDataJws: Jws,\n    signedData: SignedDataModel,\n    encodedDelta: string | undefined,\n    delta: DeltaModel | undefined\n  ) {\n    this.operationBuffer = operationBuffer;\n    this.type = OperationType.Update;\n    this.didUniqueSuffix = didUniqueSuffix;\n    this.signedDataJws = signedDataJws;\n    this.signedData = signedData;\n    this.encodedDelta = encodedDelta;\n    this.delta = delta;\n  }\n\n  /**\n   * Parses the given input as an update operation entry in the map file.\n   */\n  public static async parseOperationFromMapFile(\n    input: any\n  ): Promise<UpdateOperation> {\n    const operationBuffer = Buffer.from(JSON.stringify(input));\n    const operation = await UpdateOperation.parseObject(\n      input,\n      operationBuffer,\n      true\n    );\n    return operation;\n  }\n\n  /**\n   * Parses the given buffer as a `UpdateOperation`.\n   */\n  public static async parse(operationBuffer: Buffer): Promise<UpdateOperation> {\n    const operationJsonString = operationBuffer.toString();\n    const operationObject = await JsonAsync.parse(operationJsonString);\n    const updateOperation = await UpdateOperation.parseObject(\n      operationObject,\n      operationBuffer,\n      false\n    );\n    return updateOperation;\n  }\n\n  /**\n   * Parses the given operation object as a `UpdateOperation`.\n   * The `operationBuffer` given is assumed to be valid and is assigned to the `operationBuffer` directly.\n   * NOTE: This method is purely intended to be used as an optimization method over the `parse` method in that\n   * JSON parsing is not required to be performed more than once when an operation buffer of an unknown operation type is given.\n   * @param mapFileMode If set to true, then `delta` and `type` properties are expected to be absent.\n   */\n  public static async parseObject(\n    operationObject: any,\n    operationBuffer: Buffer,\n    mapFileMode: boolean\n  ): Promise<UpdateOperation> {\n    let expectedPropertyCount = 4;\n    if (mapFileMode) {\n      expectedPropertyCount = 2;\n    }\n\n    const properties = Object.keys(operationObject);\n    if (properties.length !== expectedPropertyCount) {\n      throw new SidetreeError(\n        ErrorCode.UpdateOperationMissingOrUnknownProperty\n      );\n    }\n\n    if (typeof operationObject.did_suffix !== 'string') {\n      throw new SidetreeError(ErrorCode.UpdateOperationMissingDidUniqueSuffix);\n    }\n\n    const signedData = Jws.parseCompactJws(operationObject.signed_data);\n    const signedDataModel = await UpdateOperation.parseSignedDataPayload(\n      signedData.payload\n    );\n\n    // If not in map file mode, we need to validate `type` and `delta` properties.\n    let encodedDelta = undefined;\n    let delta = undefined;\n    if (!mapFileMode) {\n      if (operationObject.type !== OperationType.Update) {\n        throw new SidetreeError(ErrorCode.UpdateOperationTypeIncorrect);\n      }\n\n      encodedDelta = operationObject.delta;\n      delta = await OperationUtils.parseDelta(encodedDelta);\n    }\n\n    return new UpdateOperation(\n      operationBuffer,\n      operationObject.did_suffix,\n      signedData,\n      signedDataModel,\n      encodedDelta,\n      delta\n    );\n  }\n\n  private static async parseSignedDataPayload(\n    signedDataEncodedString: string\n  ): Promise<SignedDataModel> {\n    const signedDataJsonString = Encoder.decodeAsString(\n      signedDataEncodedString\n    );\n    const signedData = await JsonAsync.parse(signedDataJsonString);\n\n    const properties = Object.keys(signedData);\n    if (properties.length !== 2) {\n      throw new SidetreeError(\n        ErrorCode.UpdateOperationSignedDataHasMissingOrUnknownProperty\n      );\n    }\n\n    Jwk.validatePublicJwk(signedData.update_key);\n\n    const delta_hash = Encoder.decodeAsBuffer(signedData.delta_hash);\n    Multihash.verifyHashComputedUsingLatestSupportedAlgorithm(delta_hash);\n\n    return {\n      delta_hash: signedData.delta_hash,\n      update_key: signedData.update_key,\n    };\n  }\n}\n","/*\n * The code in this file originated from\n * @see https://github.com/decentralized-identity/sidetree\n * For the list of changes that was made to the original code\n * @see https://github.com/transmute-industries/sidetree.js/blob/master/reference-implementation-changes.md\n *\n * Copyright 2020 - Transmute Industries Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ErrorCode, MapFileModel, SidetreeError } from '@sidetree/common';\nimport UpdateOperation from '../UpdateOperation';\nimport ArrayMethods from '../util/ArrayMethods';\nimport Compressor from '../util/Compressor';\nimport JsonAsync from '../util/JsonAsync';\n\n/**\n * Class containing Map File related operations.\n */\nexport default class MapFile {\n  /**\n   * Class that represents a map file.\n   * NOTE: this class is introduced as an internal structure in replacement to `MapFileModel`\n   * to keep useful metadata so that repeated computation can be avoided.\n   */\n  private constructor(\n    public readonly model: MapFileModel,\n    public readonly didUniqueSuffixes: string[],\n    public readonly updateOperations: UpdateOperation[]\n  ) {}\n\n  /**\n   * Parses and validates the given map file buffer.\n   * @throws `SidetreeError` if failed parsing or validation.\n   */\n  public static async parse(mapFileBuffer: Buffer): Promise<MapFile> {\n    let decompressedBuffer;\n    try {\n      decompressedBuffer = await Compressor.decompress(mapFileBuffer);\n    } catch (error) {\n      throw SidetreeError.createFromError(\n        ErrorCode.MapFileDecompressionFailure,\n        error\n      );\n    }\n\n    let mapFileModel;\n    try {\n      mapFileModel = await JsonAsync.parse(decompressedBuffer);\n    } catch (error) {\n      throw SidetreeError.createFromError(ErrorCode.MapFileNotJson, error);\n    }\n\n    const allowedProperties = new Set(['chunks', 'operations']);\n    for (const property in mapFileModel) {\n      if (!allowedProperties.has(property)) {\n        throw new SidetreeError(ErrorCode.MapFileHasUnknownProperty);\n      }\n    }\n\n    MapFile.validateChunksProperty(mapFileModel.chunks);\n\n    const updateOperations = await MapFile.parseOperationsProperty(\n      mapFileModel.operations\n    );\n    const didUniqueSuffixes = updateOperations.map(\n      (operation) => operation.didUniqueSuffix\n    );\n\n    const mapFile = new MapFile(\n      mapFileModel,\n      didUniqueSuffixes,\n      updateOperations\n    );\n    return mapFile;\n  }\n\n  /**\n   * Validates the given `operations` property, throws error if the property fails validation.\n   */\n  private static async parseOperationsProperty(\n    operations: any\n  ): Promise<UpdateOperation[]> {\n    if (operations === undefined) {\n      return [];\n    }\n\n    const properties = Object.keys(operations);\n    if (properties.length !== 1) {\n      throw new SidetreeError(\n        ErrorCode.MapFileOperationsPropertyHasMissingOrUnknownProperty\n      );\n    }\n\n    const updateOperations: UpdateOperation[] = [];\n    if (!Array.isArray(operations.update)) {\n      throw new SidetreeError(ErrorCode.MapFileUpdateOperationsNotArray);\n    }\n\n    // Validate each update operation.\n    for (const operation of operations.update) {\n      const updateOperation = await UpdateOperation.parseOperationFromMapFile(\n        operation\n      );\n      updateOperations.push(updateOperation);\n    }\n\n    // Make sure no operation with same DID.\n    const didUniqueSuffixes = updateOperations.map(\n      (operation) => operation.didUniqueSuffix\n    );\n    if (ArrayMethods.hasDuplicates(didUniqueSuffixes)) {\n      throw new SidetreeError(ErrorCode.MapFileMultipleOperationsForTheSameDid);\n    }\n\n    return updateOperations;\n  }\n\n  /**\n   * Validates the given `chunks` property, throws error if the property fails validation.\n   */\n  private static validateChunksProperty(chunks: any) {\n    if (!Array.isArray(chunks)) {\n      throw new SidetreeError(\n        ErrorCode.MapFileChunksPropertyMissingOrIncorrectType\n      );\n    }\n\n    // This version expects only one hash.\n    if (chunks.length !== 1) {\n      throw new SidetreeError(\n        ErrorCode.MapFileChunksPropertyDoesNotHaveExactlyOneElement\n      );\n    }\n\n    const chunk = chunks[0];\n    const properties = Object.keys(chunk);\n    if (properties.length !== 1) {\n      throw new SidetreeError(\n        ErrorCode.MapFileChunkHasMissingOrUnknownProperty\n      );\n    }\n  }\n\n  /**\n   * Creates the Map File buffer.\n   */\n  public static async createBuffer(\n    chunkFileHash: string,\n    updateOperationArray: UpdateOperation[]\n  ): Promise<Buffer> {\n    const updateOperations = updateOperationArray.map((operation) => {\n      return {\n        did_suffix: operation.didUniqueSuffix,\n        signed_data: operation.signedDataJws.toCompactJws(),\n      };\n    });\n\n    const mapFileModel: MapFileModel = {\n      chunks: [{ chunk_file_uri: chunkFileHash }],\n    };\n\n    // Only insert an `operations` property if there are update operations.\n    if (updateOperations.length > 0) {\n      mapFileModel.operations = {\n        update: updateOperations,\n      };\n    }\n\n    const rawData = JSON.stringify(mapFileModel);\n    const compressedRawData = await Compressor.compress(Buffer.from(rawData));\n\n    return compressedRawData;\n  }\n}\n","/*\n * The code in this file originated from\n * @see https://github.com/decentralized-identity/sidetree\n * For the list of changes that was made to the original code\n * @see https://github.com/transmute-industries/sidetree.js/blob/master/reference-implementation-changes.md\n *\n * Copyright 2020 - Transmute Industries Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { IVersionManager, TransactionModel } from '@sidetree/common';\n\n/**\n * Keeps track of current block and throughput limits based on the state\n */\nexport default class ThroughputLimiter {\n  constructor(private versionManager: IVersionManager) {}\n\n  /**\n   * given a an array of transactions, return an array of qualified transactions per transaction time.\n   * @param transactions array of transactions to filter for\n   */\n  public async getQualifiedTransactions(transactions: TransactionModel[]) {\n    let currentTransactionTime: number | undefined = undefined;\n    const transactionsGroupedByTransactionTime: TransactionModel[][] = [];\n\n    for (const transaction of transactions) {\n      // If transaction is transitioning into a new time, create a new grouping.\n      if (transaction.transactionTime !== currentTransactionTime) {\n        transactionsGroupedByTransactionTime.push([]);\n        currentTransactionTime = transaction.transactionTime;\n      }\n      transactionsGroupedByTransactionTime[\n        transactionsGroupedByTransactionTime.length - 1\n      ].push(transaction);\n    }\n\n    const qualifiedTransactions: TransactionModel[] = [];\n    for (const transactionGroup of transactionsGroupedByTransactionTime) {\n      const transactionSelector = this.versionManager.getTransactionSelector(\n        transactionGroup[0].transactionTime\n      );\n      const qualifiedTransactionsInCurrentGroup = await transactionSelector.selectQualifiedTransactions(\n        transactionGroup\n      );\n      qualifiedTransactions.push(...qualifiedTransactionsInCurrentGroup);\n    }\n    return qualifiedTransactions;\n  }\n}\n","/*\n * The code in this file originated from\n * @see https://github.com/decentralized-identity/sidetree\n * For the list of changes that was made to the original code\n * @see https://github.com/transmute-industries/sidetree.js/blob/master/reference-implementation-changes.md\n *\n * Copyright 2020 - Transmute Industries Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  IBlockchain,\n  IOperationStore,\n  ITransactionProcessor,\n  ITransactionStore,\n  IUnresolvableTransactionStore,\n  IVersionManager,\n  SharedErrorCode,\n  SidetreeError,\n  TransactionModel,\n  TransactionUnderProcessingModel,\n  TransactionProcessingStatus,\n} from '@sidetree/common';\nimport timeSpan from 'time-span';\nimport ThroughputLimiter from './ThroughputLimiter';\n\n/**\n * Class that performs periodic processing of batches of Sidetree operations anchored to the blockchain.\n */\nexport default class Observer {\n  /**\n   * Denotes if the periodic transaction processing should continue to occur.\n   * Used mainly for test purposes.\n   */\n  private continuePeriodicProcessing = false;\n\n  /**\n   * The list of transactions that are being downloaded or processed.\n   */\n  private transactionsUnderProcessing: TransactionUnderProcessingModel[] = [];\n\n  /**\n   * This is the transaction that is used as a timestamp to fetch newer transaction.\n   */\n  private lastKnownTransaction: TransactionModel | undefined;\n\n  private throughputLimiter: ThroughputLimiter;\n\n  public constructor(\n    private versionManager: IVersionManager,\n    private blockchain: IBlockchain,\n    private maxConcurrentDownloads: number,\n    private operationStore: IOperationStore,\n    private transactionStore: ITransactionStore,\n    private unresolvableTransactionStore: IUnresolvableTransactionStore,\n    private observingIntervalInSeconds: number\n  ) {\n    this.throughputLimiter = new ThroughputLimiter(versionManager);\n  }\n\n  public async refreshLastKnownTransaction(): Promise<void> {\n    this.lastKnownTransaction = await this.transactionStore.getLastTransaction();\n  }\n\n  /**\n   * The method that starts the periodic polling and processing of Sidetree operations.\n   */\n  public async startPeriodicProcessing(): Promise<void> {\n    // Initialize the last known transaction before starting processing.\n    await this.refreshLastKnownTransaction();\n\n    console.info(`Starting periodic transactions processing.`);\n    setImmediate(async () => {\n      this.continuePeriodicProcessing = true;\n\n      // tslint:disable-next-line:no-floating-promises - this.processTransactions() never throws.\n      this.processTransactions();\n    });\n  }\n\n  /**\n   * Stops periodic transaction processing.\n   * Mainly used for test purposes.\n   */\n  public stopPeriodicProcessing(): void {\n    console.info(`Stopped periodic transactions processing.`);\n    this.continuePeriodicProcessing = false;\n  }\n\n  /**\n   * Processes new transactions if any, then reprocess a set of unresolvable transactions if any,\n   * then schedules the next round of processing unless `stopPeriodicProcessing()` is invoked.\n   */\n  public async processTransactions(\n    awaitTransactionProcessing = false\n  ): Promise<void> {\n    try {\n      await this.storeConsecutiveTransactionsProcessed(); // Do this in multiple places\n\n      // Keep fetching new Sidetree transactions from blockchain and processing them\n      // until there are no more new transactions or there is a block reorganization.\n      let moreTransactions = false;\n      do {\n        // Get the last transaction to be used as a timestamp to fetch new transactions.\n        const lastKnownTransactionNumber = this.lastKnownTransaction\n          ? this.lastKnownTransaction.transactionNumber\n          : undefined;\n        const lastKnownTransactionTimeHash = this.lastKnownTransaction\n          ? this.lastKnownTransaction.transactionTimeHash\n          : undefined;\n        const lastKnownTransactionTime = this.lastKnownTransaction\n          ? this.lastKnownTransaction.transactionTime\n          : 0;\n\n        let invalidTransactionNumberOrTimeHash = false;\n        let readResult;\n        const endTimer = timeSpan(); // Measure time taken to go blockchain read.\n        try {\n          console.info(\n            'Fetching Sidetree transactions from blockchain service...'\n          );\n          const nextTransactionNumber =\n            lastKnownTransactionNumber !== undefined\n              ? lastKnownTransactionNumber + 1\n              : undefined;\n          readResult = await this.blockchain.read(\n            nextTransactionNumber,\n            lastKnownTransactionTimeHash\n          );\n          console.info(\n            `Fetched ${\n              readResult.transactions.length\n            } Sidetree transactions from blockchain service in ${endTimer.rounded()} ms.`\n          );\n        } catch (error) {\n          if (\n            error instanceof SidetreeError &&\n            error.code === SharedErrorCode.InvalidTransactionNumberOrTimeHash\n          ) {\n            console.info(\n              `Invalid transaction number ${lastKnownTransactionNumber} or time hash ${lastKnownTransactionTimeHash} given to blockchain service.`\n            );\n            invalidTransactionNumberOrTimeHash = true;\n          } else {\n            throw error;\n          }\n        }\n\n        const transactions = readResult ? readResult.transactions : [];\n        moreTransactions = readResult ? readResult.moreTransactions : false;\n        let qualifiedTransactions = await this.throughputLimiter.getQualifiedTransactions(\n          transactions\n        );\n        qualifiedTransactions = qualifiedTransactions.sort(\n          (\n            a: { transactionNumber: number },\n            b: { transactionNumber: number }\n          ) => {\n            return a.transactionNumber - b.transactionNumber;\n          }\n        );\n\n        // Queue parallel downloading and processing of chunk files.\n        for (const transaction of qualifiedTransactions) {\n          const awaitingTransaction = {\n            transaction: transaction,\n            processingStatus: TransactionProcessingStatus.Pending,\n          };\n          this.transactionsUnderProcessing.push(awaitingTransaction);\n          if (awaitTransactionProcessing) {\n            await this.processTransaction(transaction, awaitingTransaction);\n          } else {\n            // Intentionally not awaiting on downloading and processing each operation batch.\n            void this.processTransaction(transaction, awaitingTransaction);\n          }\n        }\n\n        // NOTE: Blockchain reorg has happened for sure only if `invalidTransactionNumberOrTimeHash` AND\n        // latest transaction time is less or equal to blockchain service time.\n        // This check will prevent Core from reverting transactions if/when blockchain service is reinitializing its data itself.\n        let blockReorganizationDetected = false;\n        if (invalidTransactionNumberOrTimeHash) {\n          if (\n            lastKnownTransactionTime <= this.blockchain.approximateTime.time\n          ) {\n            blockReorganizationDetected = true;\n            moreTransactions = true;\n          } else {\n            console.info(\n              `Blockchain microservice blockchain time is behind last known transaction time, waiting for blockchain microservice to catch up...`\n            );\n          }\n        }\n\n        // If block reorg is detected, we must wait until no more operation processing is pending,\n        // then revert invalid transaction and operations.\n        if (blockReorganizationDetected) {\n          console.info(`Block reorganization detected.`);\n          await this.waitUntilCountOfTransactionsUnderProcessingIsLessOrEqualTo(\n            0\n          );\n\n          console.info(`Reverting invalid transactions...`);\n          await this.revertInvalidTransactions();\n          console.info(`Completed reverting invalid transactions.`);\n        } else {\n          // Else it means transaction fetch was successful:\n          // We hold off from fetching more transactions if the list of transactions under processing gets too long.\n          // We will wait for count of transaction being processed to fall to the maximum allowed concurrent downloads\n          // before attempting further transaction fetches.\n          await this.waitUntilCountOfTransactionsUnderProcessingIsLessOrEqualTo(\n            this.maxConcurrentDownloads\n          );\n        }\n\n        // Update the last known transaction.\n        // NOTE: In case of block reorg, last known transaction will be updated in `this.RevertInvalidTransactions()` method.\n        if (transactions && transactions.length > 0) {\n          this.lastKnownTransaction = transactions[transactions.length - 1];\n        }\n      } while (moreTransactions);\n\n      await this.storeConsecutiveTransactionsProcessed();\n      console.info(\n        'Successfully kicked off downloading/processing of all new Sidetree transactions.'\n      );\n\n      // Continue onto processing unresolvable transactions if any.\n      await this.processUnresolvableTransactions(awaitTransactionProcessing);\n    } catch (error) {\n      console.error(\n        `Encountered unhandled and possibly fatal Observer error, must investigate and fix:`\n      );\n      console.error(error);\n    } finally {\n      if (this.continuePeriodicProcessing) {\n        console.info(\n          `Waiting for ${this.observingIntervalInSeconds} seconds before fetching and processing transactions again.`\n        );\n        setTimeout(\n          async () => this.processTransactions(),\n          this.observingIntervalInSeconds * 1000\n        );\n      }\n    }\n  }\n\n  private async waitUntilCountOfTransactionsUnderProcessingIsLessOrEqualTo(\n    count: number\n  ): Promise<void> {\n    while (this.transactionsUnderProcessing.length > count) {\n      // Store the consecutively processed transactions in the transaction store.\n      await this.storeConsecutiveTransactionsProcessed();\n\n      // Wait a little before checking again.\n      await new Promise((resolve) => setTimeout(resolve, 1000));\n    }\n\n    return;\n  }\n\n  /**\n   * Attempts to fetch and process unresolvable transactions due for retry.\n   * Waits until all unresolvable transactions due for retry are processed.\n   */\n  private async processUnresolvableTransactions(\n    awaitTransactionProcessing = false\n  ): Promise<void> {\n    const endTimer = timeSpan();\n    const unresolvableTransactions = await this.unresolvableTransactionStore.getUnresolvableTransactionsDueForRetry();\n    console.info(\n      `Fetched ${\n        unresolvableTransactions.length\n      } unresolvable transactions to retry in ${endTimer.rounded()} ms.`\n    );\n\n    // Download and process each unresolvable transactions.\n    const unresolvableTransactionStatus = [];\n    for (const transaction of unresolvableTransactions) {\n      const awaitingTransaction = {\n        transaction: transaction,\n        processingStatus: TransactionProcessingStatus.Pending,\n      };\n      unresolvableTransactionStatus.push(awaitingTransaction);\n      // Intentionally not awaiting on downloading and processing each operation batch.\n      if (awaitTransactionProcessing) {\n        await this.processTransaction(transaction, awaitingTransaction);\n      } else {\n        // Intentionally not awaiting on downloading and processing each operation batch.\n        void this.processTransaction(transaction, awaitingTransaction);\n      }\n    }\n\n    // Wait until all unresolvable transactions are processed,\n    while (unresolvableTransactionStatus.length > 0) {\n      // Find the index of the first transaction that is not processed yet.\n      let i = 0;\n      while (\n        i < unresolvableTransactionStatus.length &&\n        unresolvableTransactionStatus[i].processingStatus ===\n          TransactionProcessingStatus.Processed\n      ) {\n        i++;\n      }\n\n      // Trim the parallelized transaction list.\n      unresolvableTransactionStatus.splice(0, i);\n\n      // Wait a little before checking again.\n      await new Promise((resolve) => setTimeout(resolve, 1000));\n    }\n  }\n\n  /**\n   * Goes through the `transactionsUnderProcessing` in chronological order, records each processed transaction\n   * in the transaction store and remove it from `transactionsUnderProcessing` until a transaction that has not been processed yet is hit.\n   */\n  private async storeConsecutiveTransactionsProcessed(): Promise<void> {\n    let i = 0;\n    while (\n      i < this.transactionsUnderProcessing.length &&\n      this.transactionsUnderProcessing[i].processingStatus ===\n        TransactionProcessingStatus.Processed\n    ) {\n      await this.transactionStore.addTransaction(\n        this.transactionsUnderProcessing[i].transaction\n      );\n      i++;\n    }\n\n    // Trim the transaction list.\n    this.transactionsUnderProcessing.splice(0, i);\n  }\n\n  /**\n   * Processes the given transaction by passing the transaction to the right version of the transaction processor based on the transaction time.\n   * The transaction processing generically involves first downloading DID operation data from CAS (Content Addressable Storage),\n   * then storing the operations indexed/grouped by DIDs in the persistent operation DB.\n   */\n  private async processTransaction(\n    transaction: TransactionModel,\n    transactionUnderProcessing: TransactionUnderProcessingModel\n  ): Promise<void> {\n    let transactionProcessedSuccessfully;\n\n    try {\n      const transactionProcessor: ITransactionProcessor = this.versionManager.getTransactionProcessor(\n        transaction.transactionTime\n      );\n      transactionProcessedSuccessfully = await transactionProcessor.processTransaction(\n        transaction\n      );\n    } catch (error) {\n      console.error(\n        `Unhandled error encountered processing transaction '${transaction.transactionNumber}'.`\n      );\n      console.error(error);\n      transactionProcessedSuccessfully = false;\n    } finally {\n      // Purposely setting processing status first before rest of the code to prevent any possibility of deadlocking the Observer.\n      console.info(\n        `Finished processing transaction '${transaction.transactionNumber}'.`\n      );\n      transactionUnderProcessing.processingStatus =\n        TransactionProcessingStatus.Processed;\n\n      if (transactionProcessedSuccessfully) {\n        console.info(\n          `Removing transaction '${transaction.transactionNumber}' from unresolvable transactions if exists...`\n        );\n        await this.unresolvableTransactionStore.removeUnresolvableTransaction(\n          transaction\n        );\n      } else {\n        console.info(\n          `Recording failed processing attempt for transaction '${transaction.transactionNumber}'...`\n        );\n        await this.unresolvableTransactionStore.recordUnresolvableTransactionFetchAttempt(\n          transaction\n        );\n      }\n    }\n  }\n\n  /**\n   * Reverts invalid transactions. Used in the event of a block-reorganization.\n   */\n  private async revertInvalidTransactions(): Promise<void> {\n    // Compute a list of exponentially-spaced transactions with their index, starting from the last transaction of the processed transactions.\n    const exponentiallySpacedTransactions = await this.transactionStore.getExponentiallySpacedTransactions();\n\n    // Find a known valid Sidetree transaction that is prior to the block reorganization.\n    const bestKnownValidRecentTransaction = await this.blockchain.getFirstValidTransaction(\n      exponentiallySpacedTransactions\n    );\n\n    const bestKnownValidRecentTransactionNumber =\n      bestKnownValidRecentTransaction === undefined\n        ? undefined\n        : bestKnownValidRecentTransaction.transactionNumber;\n    console.info(\n      `Best known valid recent transaction: ${bestKnownValidRecentTransactionNumber}`\n    );\n\n    // Revert all processed operations that came after the best known valid recent transaction.\n    console.info('Reverting operations...');\n    await this.operationStore.delete(bestKnownValidRecentTransactionNumber);\n\n    // NOTE: MUST do this step LAST to handle incomplete operation rollback due to unexpected scenarios, such as power outage etc.\n    await this.transactionStore.removeTransactionsLaterThan(\n      bestKnownValidRecentTransactionNumber\n    );\n    await this.unresolvableTransactionStore.removeUnresolvableTransactionsLaterThan(\n      bestKnownValidRecentTransactionNumber\n    );\n\n    // Reset the in-memory last known good Transaction so we next processing cycle will fetch from the correct timestamp/maker.\n    this.lastKnownTransaction = bestKnownValidRecentTransaction;\n  }\n}\n","/*\n * The code in this file originated from\n * @see https://github.com/decentralized-identity/sidetree\n * For the list of changes that was made to the original code\n * @see https://github.com/transmute-industries/sidetree.js/blob/master/reference-implementation-changes.md\n *\n * Copyright 2020 - Transmute Industries Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  ErrorCode,\n  OperationModel,\n  OperationType,\n  SidetreeError,\n} from '@sidetree/common';\nimport CreateOperation from './CreateOperation';\nimport DeactivateOperation from './DeactivateOperation';\nimport RecoverOperation from './RecoverOperation';\nimport UpdateOperation from './UpdateOperation';\n\n/**\n * A class that contains Sidetree operation utility methods.\n */\nexport default class Operation {\n  /** Maximum allowed encoded reveal value string length. */\n  public static readonly maxEncodedRevealValueLength = 50;\n\n  /**\n   * Parses the given buffer into an `OperationModel`.\n   */\n  public static async parse(operationBuffer: Buffer): Promise<OperationModel> {\n    // Parse request buffer into a JS object.\n    const operationJsonString = operationBuffer.toString();\n    const operationObject = JSON.parse(operationJsonString);\n    const operationType = operationObject.type;\n    const isAnchorFileMode = false;\n\n    if (operationType === OperationType.Create) {\n      return CreateOperation.parseObject(\n        operationObject,\n        operationBuffer,\n        isAnchorFileMode\n      );\n    } else if (operationType === OperationType.Update) {\n      return UpdateOperation.parseObject(\n        operationObject,\n        operationBuffer,\n        isAnchorFileMode\n      );\n    } else if (operationType === OperationType.Recover) {\n      return RecoverOperation.parseObject(\n        operationObject,\n        operationBuffer,\n        isAnchorFileMode\n      );\n    } else if (operationType === OperationType.Deactivate) {\n      return DeactivateOperation.parseObject(\n        operationObject,\n        operationBuffer,\n        isAnchorFileMode\n      );\n    } else {\n      throw new SidetreeError(ErrorCode.OperationTypeUnknownOrMissing);\n    }\n  }\n}\n","/*\n * The code in this file originated from\n * @see https://github.com/decentralized-identity/sidetree\n * For the list of changes that was made to the original code\n * @see https://github.com/transmute-industries/sidetree.js/blob/master/reference-implementation-changes.md\n *\n * Copyright 2020 - Transmute Industries Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  AnchoredOperationModel,\n  Encoder,\n  PublicKeyJwk,\n  Multihash,\n  OperationModel,\n  OperationType,\n  PrivateKeyJwk,\n  PublicKeyModel,\n  ServiceEndpointModel,\n  PublicKeyPurpose,\n  DocumentModel,\n  PrivateKeyJwkEd25519,\n} from '@sidetree/common';\nimport * as crypto from 'crypto';\nimport CreateOperation from '../../CreateOperation';\nimport DeactivateOperation from '../../DeactivateOperation';\nimport RecoverOperation from '../../RecoverOperation';\nimport UpdateOperation from '../../UpdateOperation';\nimport Jwk from '../../util/Jwk';\nimport Jws from '../../util/Jws';\n\ninterface AnchoredCreateOperationGenerationInput {\n  transactionNumber: number;\n  transactionTime: number;\n  operationIndex: number;\n}\n\ninterface RecoverOperationGenerationInput {\n  didUniqueSuffix: string;\n  recoveryPrivateKey: PrivateKeyJwk;\n}\n\ninterface GeneratedRecoverOperationData {\n  operationBuffer: Buffer;\n  recoverOperation: RecoverOperation;\n  recoveryPublicKey: PublicKeyJwk;\n  recoveryPrivateKey: PrivateKeyJwk;\n  signingPublicKey: PublicKeyModel;\n  signingPrivateKey: PrivateKeyJwk;\n  update_key: PublicKeyModel;\n  updatePrivateKey: PrivateKeyJwk;\n}\n\n/**\n * A class that can generate valid operations.\n * Mainly useful for testing purposes.\n */\nexport default class OperationGenerator {\n  /**\n   * Generates random hash.\n   */\n  public static generateRandomHash(): string {\n    const randomBuffer = crypto.randomBytes(32);\n    const randomHash = Encoder.encode(Multihash.hash(randomBuffer));\n\n    return randomHash;\n  }\n\n  /**\n   * Generates Ed25519 key pair to be used in an operation. If purpose not supplied, all purposes will be included\n   * Mainly used for testing.\n   * @returns [publicKey, privateKey]\n   */\n  public static async generateKeyPair(\n    id: string,\n    purpose?: PublicKeyPurpose[]\n  ): Promise<[PublicKeyModel, PrivateKeyJwk]> {\n    const [publicKey, privateKey] = await Jwk.generateEd25519KeyPair();\n    const publicKeyModel = {\n      id,\n      type: 'Ed25519VerificationKey2018',\n      jwk: publicKey,\n      purpose: purpose || Object.values(PublicKeyPurpose),\n    };\n\n    return [publicKeyModel, privateKey];\n  }\n\n  /**\n   * Generates an anchored create operation.\n   */\n  public static async generateAnchoredCreateOperation(\n    input: AnchoredCreateOperationGenerationInput\n  ) {\n    const createOperationData = await OperationGenerator.generateCreateOperation();\n\n    const anchoredOperationModel = {\n      type: OperationType.Create,\n      didUniqueSuffix: createOperationData.createOperation.didUniqueSuffix,\n      operationBuffer: createOperationData.createOperation.operationBuffer,\n      transactionNumber: input.transactionNumber,\n      transactionTime: input.transactionTime,\n      operationIndex: input.operationIndex,\n    };\n\n    return {\n      createOperation: createOperationData.createOperation,\n      operationRequest: createOperationData.operationRequest,\n      anchoredOperationModel,\n      recoveryPublicKey: createOperationData.recoveryPublicKey,\n      recoveryPrivateKey: createOperationData.recoveryPrivateKey,\n      updatePublicKey: createOperationData.updatePublicKey,\n      updatePrivateKey: createOperationData.updatePrivateKey,\n      signingPublicKey: createOperationData.signingPublicKey,\n      signingPrivateKey: createOperationData.signingPrivateKey,\n      nextUpdateRevealValueEncodedString:\n        createOperationData.nextUpdateRevealValueEncodedString,\n    };\n  }\n\n  /**\n   * Generates an create operation.\n   */\n  public static async generateCreateOperation() {\n    const signingKeyId = 'signingKey';\n    const [\n      recoveryPublicKey,\n      recoveryPrivateKey,\n    ] = await Jwk.generateEd25519KeyPair();\n    const [\n      updatePublicKey,\n      updatePrivateKey,\n    ] = await Jwk.generateEd25519KeyPair();\n    const [\n      signingPublicKey,\n      signingPrivateKey,\n    ] = await OperationGenerator.generateKeyPair(signingKeyId);\n    const service = OperationGenerator.generateServiceEndpoints([\n      'serviceEndpointId123',\n    ]);\n\n    const operationRequest = await OperationGenerator.generateCreateOperationRequest(\n      recoveryPublicKey,\n      updatePublicKey,\n      [signingPublicKey],\n      service\n    );\n\n    const operationBuffer = Buffer.from(JSON.stringify(operationRequest));\n\n    const createOperation = await CreateOperation.parse(operationBuffer);\n\n    const nextUpdateRevealValueEncodedString = Multihash.canonicalizeThenHashThenEncode(\n      signingPublicKey.jwk\n    );\n    return {\n      createOperation,\n      operationRequest,\n      recoveryPublicKey,\n      recoveryPrivateKey,\n      updatePublicKey,\n      updatePrivateKey,\n      signingPublicKey,\n      signingPrivateKey,\n      nextUpdateRevealValueEncodedString,\n    };\n  }\n\n  /**\n   * Generates a recover operation.\n   */\n  public static async generateRecoverOperation(\n    input: RecoverOperationGenerationInput\n  ): Promise<GeneratedRecoverOperationData> {\n    const newSigningKeyId = 'newSigningKey';\n    const [\n      newRecoveryPublicKey,\n      newRecoveryPrivateKey,\n    ] = await Jwk.generateEd25519KeyPair();\n    const [\n      newSigningPublicKey,\n      newSigningPrivateKey,\n    ] = await OperationGenerator.generateKeyPair(newSigningKeyId);\n    const [publicKeyToBeInDocument] = await OperationGenerator.generateKeyPair(\n      'newKey'\n    );\n    const services = OperationGenerator.generateServiceEndpoints([\n      'serviceEndpointId123',\n    ]);\n\n    // Generate the next update and recover operation commitment hash reveal value pair.\n    const [\n      update_key,\n      updatePrivateKey,\n    ] = await OperationGenerator.generateKeyPair('update_key');\n\n    const operationJson = await OperationGenerator.generateRecoverOperationRequest(\n      input.didUniqueSuffix,\n      input.recoveryPrivateKey,\n      newRecoveryPublicKey,\n      newSigningPublicKey,\n      services,\n      [publicKeyToBeInDocument]\n    );\n\n    const operationBuffer = Buffer.from(JSON.stringify(operationJson));\n    const recoverOperation = await RecoverOperation.parse(operationBuffer);\n\n    return {\n      recoverOperation,\n      operationBuffer,\n      recoveryPublicKey: newRecoveryPublicKey,\n      recoveryPrivateKey: newRecoveryPrivateKey,\n      signingPublicKey: newSigningPublicKey,\n      signingPrivateKey: newSigningPrivateKey,\n      update_key,\n      updatePrivateKey,\n    };\n  }\n\n  /**\n   * Generates an update operation that adds a new key.\n   */\n  public static async generateUpdateOperation(\n    didUniqueSuffix: string,\n    updatePublicKey: PublicKeyJwk,\n    updatePrivateKey: PrivateKeyJwk\n  ) {\n    const additionalKeyId = `additional-key`;\n    const [\n      additionalPublicKey,\n      additionalPrivateKey,\n    ] = await OperationGenerator.generateKeyPair(additionalKeyId);\n\n    const operationJson = await OperationGenerator.createUpdateOperationRequestForAddingAKey(\n      didUniqueSuffix,\n      updatePublicKey,\n      updatePrivateKey,\n      additionalPublicKey,\n      Multihash.canonicalizeThenHashThenEncode(additionalPublicKey)\n    );\n\n    const operationBuffer = Buffer.from(JSON.stringify(operationJson));\n    const updateOperation = await UpdateOperation.parse(operationBuffer);\n\n    return {\n      updateOperation,\n      operationBuffer,\n      additionalKeyId,\n      additionalPublicKey,\n      additionalPrivateKey,\n      nextUpdateKey: additionalPublicKey.jwk,\n    };\n  }\n\n  /**\n   * Creates a named anchored operation model from `OperationModel`.\n   */\n  public static createAnchoredOperationModelFromOperationModel(\n    operationModel: OperationModel,\n    transactionTime: number,\n    transactionNumber: number,\n    operationIndex: number\n  ): AnchoredOperationModel {\n    const anchoredOperationModel: AnchoredOperationModel = {\n      didUniqueSuffix: operationModel.didUniqueSuffix,\n      type: operationModel.type,\n      operationBuffer: operationModel.operationBuffer,\n      operationIndex,\n      transactionNumber,\n      transactionTime,\n    };\n    return anchoredOperationModel;\n  }\n\n  /**\n   * Generates a create operation request.\n   */\n  public static async generateCreateOperationRequest(\n    recoveryPublicKey: PublicKeyJwk,\n    updatePublicKey: PublicKeyJwk,\n    otherPublicKeys: PublicKeyModel[],\n    service_endpoints?: ServiceEndpointModel[]\n  ) {\n    const document: DocumentModel = {\n      public_keys: otherPublicKeys,\n      service_endpoints,\n    };\n\n    const patches = [\n      {\n        action: 'replace',\n        document,\n      },\n    ];\n\n    const delta = {\n      update_commitment: Multihash.canonicalizeThenHashThenEncode(\n        updatePublicKey\n      ),\n      patches,\n    };\n\n    const deltaBuffer = Buffer.from(JSON.stringify(delta));\n    const delta_hash = Encoder.encode(Multihash.hash(deltaBuffer));\n\n    const suffixData = {\n      delta_hash: delta_hash,\n      recovery_commitment: Multihash.canonicalizeThenHashThenEncode(\n        recoveryPublicKey\n      ),\n    };\n\n    const suffixDataEncodedString = Encoder.encode(JSON.stringify(suffixData));\n    const deltaEncodedString = Encoder.encode(deltaBuffer);\n    const operation = {\n      type: OperationType.Create,\n      suffix_data: suffixDataEncodedString,\n      delta: deltaEncodedString,\n    };\n\n    return operation;\n  }\n\n  /**\n   * Generates an update operation request.\n   */\n  public static async generateUpdateOperationRequest(didUniqueSuffix?: string) {\n    if (didUniqueSuffix === undefined) {\n      didUniqueSuffix = OperationGenerator.generateRandomHash();\n    }\n    const [nextUpdateKey] = await OperationGenerator.generateKeyPair(\n      'nextUpdateKey'\n    );\n    const nextUpdateCommitmentHash = Multihash.canonicalizeThenHashThenEncode(\n      nextUpdateKey.jwk\n    );\n    const anyNewSigningPublicKeyId = 'anyNewKey';\n    const [anyNewSigningKey] = await OperationGenerator.generateKeyPair(\n      anyNewSigningPublicKeyId\n    );\n    const patches = [\n      {\n        action: 'add-public-keys',\n        public_keys: [anyNewSigningKey],\n      },\n    ];\n    const signingKeyId = 'anySigningKeyId';\n    const [\n      signingPublicKey,\n      signingPrivateKey,\n    ] = await OperationGenerator.generateKeyPair(signingKeyId);\n    const request = await OperationGenerator.createUpdateOperationRequest(\n      didUniqueSuffix,\n      signingPublicKey.jwk,\n      signingPrivateKey,\n      nextUpdateCommitmentHash,\n      patches\n    );\n\n    const buffer = Buffer.from(JSON.stringify(request));\n    const updateOperation = await UpdateOperation.parse(buffer);\n\n    return {\n      request,\n      buffer,\n      updateOperation,\n    };\n  }\n\n  /**\n   * Creates an update operation request.\n   */\n  public static async createUpdateOperationRequest(\n    didUniqueSuffix: string,\n    updatePublicKey: PublicKeyJwk,\n    updatePrivateKey: PrivateKeyJwk,\n    nextUpdateCommitmentHash: string,\n    patches: any\n  ) {\n    const delta = {\n      patches,\n      update_commitment: nextUpdateCommitmentHash,\n    };\n    const deltaJsonString = JSON.stringify(delta);\n    const delta_hash = Encoder.encode(\n      Multihash.hash(Buffer.from(deltaJsonString))\n    );\n    const encodedDeltaString = Encoder.encode(deltaJsonString);\n\n    const signedDataPayloadObject = {\n      update_key: updatePublicKey,\n      delta_hash: delta_hash,\n    };\n    const signedData = await OperationGenerator.signUsingEd25519(\n      signedDataPayloadObject,\n      updatePrivateKey\n    );\n\n    const updateOperationRequest = {\n      type: OperationType.Update,\n      did_suffix: didUniqueSuffix,\n      delta: encodedDeltaString,\n      signed_data: signedData,\n    };\n\n    return updateOperationRequest;\n  }\n\n  /**\n   * Generates a recover operation request.\n   */\n  public static async generateRecoverOperationRequest(\n    didUniqueSuffix: string,\n    recoveryPrivateKey: PrivateKeyJwk,\n    newRecoveryPublicKey: PublicKeyJwk,\n    newSigningPublicKey: PublicKeyModel,\n    service_endpoints?: ServiceEndpointModel[],\n    public_keys?: PublicKeyModel[]\n  ) {\n    const document = {\n      public_keys: public_keys,\n      service_endpoints: service_endpoints,\n    };\n    const recoverOperation = await OperationGenerator.createRecoverOperationRequest(\n      didUniqueSuffix,\n      recoveryPrivateKey,\n      newRecoveryPublicKey,\n      Multihash.canonicalizeThenHashThenEncode(newSigningPublicKey.jwk),\n      document\n    );\n    return recoverOperation;\n  }\n\n  /**\n   * Creates a recover operation request.\n   */\n  public static async createRecoverOperationRequest(\n    didUniqueSuffix: string,\n    recoveryPrivateKey: PrivateKeyJwk,\n    newRecoveryPublicKey: PublicKeyJwk,\n    nextUpdateCommitmentHash: string,\n    document: any\n  ) {\n    const patches = [\n      {\n        action: 'replace',\n        document,\n      },\n    ];\n\n    const delta = {\n      patches,\n      update_commitment: nextUpdateCommitmentHash,\n    };\n\n    const deltaBuffer = Buffer.from(JSON.stringify(delta));\n    const delta_hash = Encoder.encode(Multihash.hash(deltaBuffer));\n\n    const signedDataPayloadObject = {\n      delta_hash: delta_hash,\n      recovery_key: Jwk.getCurve25519PublicKey(\n        recoveryPrivateKey as PrivateKeyJwkEd25519\n      ),\n      recovery_commitment: Multihash.canonicalizeThenHashThenEncode(\n        newRecoveryPublicKey\n      ),\n    };\n    const signedData = await OperationGenerator.signUsingEd25519(\n      signedDataPayloadObject,\n      recoveryPrivateKey\n    );\n\n    const deltaEncodedString = Encoder.encode(deltaBuffer);\n    const operation = {\n      type: OperationType.Recover,\n      did_suffix: didUniqueSuffix,\n      signed_data: signedData,\n      delta: deltaEncodedString,\n    };\n\n    return operation;\n  }\n\n  /**\n   * Generates a deactivate operation request.\n   */\n  public static async createDeactivateOperationRequest(\n    didUniqueSuffix: string,\n    recoveryPrivateKey: PrivateKeyJwk\n  ) {\n    const signedDataPayloadObject = {\n      did_suffix: didUniqueSuffix,\n      recovery_key: Jwk.getCurve25519PublicKey(\n        recoveryPrivateKey as PrivateKeyJwkEd25519\n      ),\n    };\n    const signedData = await OperationGenerator.signUsingEd25519(\n      signedDataPayloadObject,\n      recoveryPrivateKey\n    );\n\n    const operation = {\n      type: OperationType.Deactivate,\n      did_suffix: didUniqueSuffix,\n      signed_data: signedData,\n    };\n\n    return operation;\n  }\n\n  /**\n   * Generates a create operation request buffer.\n   * @param nextRecoveryCommitmentHash The encoded commitment hash for the next recovery.\n   * @param nextUpdateCommitmentHash The encoded commitment hash for the next update.\n   */\n  public static async generateCreateOperationBuffer(\n    recoveryPublicKey: PublicKeyJwk,\n    signingPublicKey: PublicKeyModel,\n    service_endpoints?: ServiceEndpointModel[]\n  ): Promise<Buffer> {\n    const operation = await OperationGenerator.generateCreateOperationRequest(\n      recoveryPublicKey,\n      signingPublicKey.jwk,\n      [signingPublicKey],\n      service_endpoints\n    );\n\n    return Buffer.from(JSON.stringify(operation));\n  }\n\n  /**\n   * Creates an update operation for adding a key.\n   */\n  public static async createUpdateOperationRequestForAddingAKey(\n    didUniqueSuffix: string,\n    updatePublicKey: PublicKeyJwk,\n    updatePrivateKey: PrivateKeyJwk,\n    newPublicKey: PublicKeyModel,\n    nextUpdateCommitmentHash: string\n  ) {\n    const patches = [\n      {\n        action: 'add-public-keys',\n        public_keys: [newPublicKey],\n      },\n    ];\n\n    const updateOperationRequest = await OperationGenerator.createUpdateOperationRequest(\n      didUniqueSuffix,\n      updatePublicKey,\n      updatePrivateKey,\n      nextUpdateCommitmentHash,\n      patches\n    );\n\n    return updateOperationRequest;\n  }\n\n  /**\n   * Creates an update operation for adding and/or removing hub service endpoints.\n   */\n  public static async createUpdateOperationRequestForHubEndpoints(\n    didUniqueSuffix: string,\n    updatePublicKey: any,\n    updatePrivateKey: PrivateKeyJwk,\n    nextUpdateCommitmentHash: string,\n    idOfServiceEndpointToAdd: string | undefined,\n    idsOfServiceEndpointToRemove: string[]\n  ) {\n    const patches = [];\n\n    if (idOfServiceEndpointToAdd !== undefined) {\n      const patch = {\n        action: 'add-service-endpoints',\n        service_endpoints: OperationGenerator.generateServiceEndpoints([\n          idOfServiceEndpointToAdd,\n        ]),\n      };\n\n      patches.push(patch);\n    }\n\n    if (idsOfServiceEndpointToRemove.length > 0) {\n      const patch = {\n        action: 'remove-service-endpoints',\n        ids: idsOfServiceEndpointToRemove,\n      };\n\n      patches.push(patch);\n    }\n\n    const updateOperationRequest = await OperationGenerator.createUpdateOperationRequest(\n      didUniqueSuffix,\n      updatePublicKey,\n      updatePrivateKey,\n      nextUpdateCommitmentHash,\n      patches\n    );\n\n    return updateOperationRequest;\n  }\n\n  /**\n   * Signs the given payload as a ed25519 compact JWS.\n   */\n  public static async signUsingEd25519(\n    payload: any,\n    privateKey: PrivateKeyJwk\n  ): Promise<string> {\n    const protectedHeader = {\n      alg: 'EdDSA',\n    };\n\n    const compactJws = await Jws.signAsCompactJws(\n      payload,\n      privateKey,\n      protectedHeader\n    );\n    return compactJws;\n  }\n\n  /**\n   * Generates a Deactivate Operation data.\n   */\n  public static async createDeactivateOperation(\n    didUniqueSuffix: string,\n    recoveryPrivateKey: PrivateKeyJwk\n  ) {\n    const operationRequest = await OperationGenerator.createDeactivateOperationRequest(\n      didUniqueSuffix,\n      recoveryPrivateKey\n    );\n    const operationBuffer = Buffer.from(JSON.stringify(operationRequest));\n    const deactivateOperation = await DeactivateOperation.parse(\n      operationBuffer\n    );\n\n    return {\n      operationRequest,\n      operationBuffer,\n      deactivateOperation,\n    };\n  }\n\n  /**\n   * Generates an array of service endpoints with specified ids\n   * @param ids the id field in endpoint.\n   */\n  public static generateServiceEndpoints(ids: string[]): any[] {\n    const service_endpoints = [];\n    for (const id of ids) {\n      service_endpoints.push({\n        id: id,\n        type: 'someType',\n        endpoint: 'https://www.url.com',\n      });\n    }\n    return service_endpoints;\n  }\n}\n","/*\n * The code in this file originated from\n * @see https://github.com/decentralized-identity/sidetree\n * For the list of changes that was made to the original code\n * @see https://github.com/transmute-industries/sidetree.js/blob/master/reference-implementation-changes.md\n *\n * Copyright 2020 - Transmute Industries Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  AnchoredOperationModel,\n  DidState,\n  IOperationStore,\n  IVersionManager,\n  Multihash,\n  OperationType,\n  SidetreeError,\n} from '@sidetree/common';\n\n/**\n * NOTE: Resolver cannot be versioned because it needs to be aware of `VersionManager` to fetch versioned operation processors.\n */\nexport default class Resolver {\n  public constructor(\n    private versionManager: IVersionManager,\n    private operationStore: IOperationStore\n  ) {}\n\n  /**\n   * Resolve the given DID unique suffix to its latest DID state.\n   * @param didUniqueSuffix The unique suffix of the DID to resolve. e.g. if 'did:sidetree:abc123' is the DID, the unique suffix would be 'abc123'\n   * @returns Final DID state of the DID. Undefined if the unique suffix of the DID is not found or the DID state is not constructable.\n   */\n  public async resolve(didUniqueSuffix: string): Promise<DidState | undefined> {\n    console.info(`Resolving DID unique suffix '${didUniqueSuffix}'...`);\n\n    const operations = await this.operationStore.get(didUniqueSuffix);\n    const operationsByType = Resolver.categorizeOperationsByType(operations);\n\n    // Find and apply a valid create operation.\n    let didState = await this.applyCreateOperation(\n      operationsByType.createOperations\n    );\n\n    // If can't construct an initial DID state.\n    if (didState === undefined) {\n      return undefined;\n    }\n\n    // Apply recovery/deactivate operations until an operation matching the next recovery commitment cannot be found.\n    const recoverAndDeactivateOperations = operationsByType.recoverOperations.concat(\n      operationsByType.deactivateOperations\n    );\n    const recoveryCommitValueToOperationMap = await this.constructCommitValueToOperationLookupMap(\n      recoverAndDeactivateOperations\n    );\n    didState = await this.applyRecoverAndDeactivateOperations(\n      didState,\n      recoveryCommitValueToOperationMap\n    );\n\n    // If the previous applied operation is a deactivate. No need to continue further.\n    if (didState.nextRecoveryCommitmentHash === undefined) {\n      return didState;\n    }\n\n    // Apply update operations until an operation matching the next update commitment cannot be found.\n    const updateCommitValueToOperationMap = await this.constructCommitValueToOperationLookupMap(\n      operationsByType.updateOperations\n    );\n    didState = await this.applyUpdateOperations(\n      didState,\n      updateCommitValueToOperationMap\n    );\n\n    return didState;\n  }\n\n  private static categorizeOperationsByType(\n    operations: AnchoredOperationModel[]\n  ): {\n    createOperations: AnchoredOperationModel[];\n    recoverOperations: AnchoredOperationModel[];\n    updateOperations: AnchoredOperationModel[];\n    deactivateOperations: AnchoredOperationModel[];\n  } {\n    const createOperations = [];\n    const recoverOperations = [];\n    const updateOperations = [];\n    const deactivateOperations = [];\n\n    for (const operation of operations) {\n      if (operation.type === OperationType.Create) {\n        createOperations.push(operation);\n      } else if (operation.type === OperationType.Recover) {\n        recoverOperations.push(operation);\n      } else if (operation.type === OperationType.Update) {\n        updateOperations.push(operation);\n      } else {\n        // This is a deactivate operation.\n        deactivateOperations.push(operation);\n      }\n    }\n    return {\n      createOperations,\n      recoverOperations,\n      updateOperations,\n      deactivateOperations,\n    };\n  }\n\n  /**\n   * Iterate through all duplicates of creates until we can construct an initial DID state (some creates maybe incomplete. eg. without `delta`).\n   */\n  private async applyCreateOperation(\n    createOperations: AnchoredOperationModel[]\n  ): Promise<DidState | undefined> {\n    let didState;\n\n    for (const createOperation of createOperations) {\n      didState = await this.applyOperation(createOperation, undefined);\n\n      // Exit loop as soon as we can construct an initial state.\n      if (didState !== undefined) {\n        break;\n      }\n    }\n\n    return didState;\n  }\n\n  /**\n   * Apply recovery/deactivate operations until an operation matching the next recovery commitment cannot be found.\n   */\n  private async applyRecoverAndDeactivateOperations(\n    startingDidState: DidState,\n    commitValueToOperationMap: Map<string, AnchoredOperationModel[]>\n  ): Promise<DidState> {\n    let didState = startingDidState;\n\n    while (\n      commitValueToOperationMap.has(didState.nextRecoveryCommitmentHash!)\n    ) {\n      let operationsWithCorrectRevealValue: AnchoredOperationModel[] = commitValueToOperationMap.get(\n        didState.nextRecoveryCommitmentHash!\n      )!;\n\n      // Sort using blockchain time.\n      operationsWithCorrectRevealValue = operationsWithCorrectRevealValue.sort(\n        (a, b) => a.transactionNumber - b.transactionNumber\n      );\n\n      const newDidState:\n        | DidState\n        | undefined = await this.applyFirstValidOperation(\n        operationsWithCorrectRevealValue,\n        didState\n      );\n\n      // We are done if we can't find a valid recover/deactivate operation to apply.\n      if (newDidState === undefined) {\n        break;\n      }\n\n      // We reach here if we have successfully computed a new DID state.\n      didState = newDidState;\n\n      // If the previous applied operation is a deactivate. No need to continue further.\n      if (didState.nextRecoveryCommitmentHash === undefined) {\n        return didState;\n      }\n    }\n\n    return didState;\n  }\n\n  /**\n   * Apply update operations until an operation matching the next update commitment cannot be found.\n   */\n  private async applyUpdateOperations(\n    startingDidState: DidState,\n    commitValueToOperationMap: Map<string, AnchoredOperationModel[]>\n  ): Promise<DidState> {\n    let didState = startingDidState;\n\n    while (commitValueToOperationMap.has(didState.nextUpdateCommitmentHash!)) {\n      let operationsWithCorrectRevealValue: AnchoredOperationModel[] = commitValueToOperationMap.get(\n        didState.nextUpdateCommitmentHash!\n      )!;\n\n      // Sort using blockchain time.\n      operationsWithCorrectRevealValue = operationsWithCorrectRevealValue.sort(\n        (a, b) => a.transactionNumber - b.transactionNumber\n      );\n\n      const newDidState:\n        | DidState\n        | undefined = await this.applyFirstValidOperation(\n        operationsWithCorrectRevealValue,\n        didState\n      );\n\n      // We are done if we can't find a valid update operation to apply.\n      if (newDidState === undefined) {\n        break;\n      }\n\n      // We reach here if we have successfully computed a new DID state.\n      didState = newDidState;\n    }\n\n    return didState;\n  }\n\n  /**\n   * Applies the given operation to the given DID state.\n   * @param operation The operation to be applied.\n   * @param didState The DID state to apply the operation on top of.\n   * @returns The resultant `DidState`. The given DID state is return if the given operation cannot be applied.\n   */\n  private async applyOperation(\n    operation: AnchoredOperationModel,\n    didState: DidState | undefined\n  ): Promise<DidState | undefined> {\n    let appliedDidState = didState;\n\n    // NOTE: MUST NOT throw error, else a bad operation can be used to denial resolution for a DID.\n    try {\n      const operationProcessor = this.versionManager.getOperationProcessor(\n        operation.transactionTime\n      );\n\n      appliedDidState = await operationProcessor.apply(\n        operation,\n        appliedDidState\n      );\n    } catch (error) {\n      console.log(\n        `Skipped bad operation for DID ${operation.didUniqueSuffix} at time ${\n          operation.transactionTime\n        }. Error: ${SidetreeError.stringify(error)}`\n      );\n    }\n\n    return appliedDidState;\n  }\n\n  /**\n   * @returns The new DID State if a valid operation is applied, `undefined` otherwise.\n   */\n  private async applyFirstValidOperation(\n    operations: AnchoredOperationModel[],\n    originalDidState: DidState\n  ): Promise<DidState | undefined> {\n    let newDidState = originalDidState;\n\n    // Stop as soon as an operation is applied successfully.\n    for (const operation of operations) {\n      newDidState = (await this.applyOperation(operation, newDidState))!;\n\n      // If operation matching the recovery commitment is applied.\n      if (\n        newDidState.lastOperationTransactionNumber !==\n        originalDidState.lastOperationTransactionNumber\n      ) {\n        return newDidState;\n      }\n    }\n\n    // Else we reach the end of operations without being able to apply any of them.\n    return undefined;\n  }\n\n  /**\n   * Constructs a single commit value -> operation lookup map by looping through each supported hash algorithm,\n   * hashing each operations as key, then adding the result to a map.\n   */\n  private async constructCommitValueToOperationLookupMap(\n    nonCreateOperations: AnchoredOperationModel[]\n  ): Promise<Map<string, AnchoredOperationModel[]>> {\n    const commitValueToOperationMap = new Map<\n      string,\n      AnchoredOperationModel[]\n    >();\n\n    // Loop through each supported algorithm and hash each operation.\n    const allSupportedHashAlgorithms = this.versionManager\n      .allSupportedHashAlgorithms;\n    for (const hashAlgorithm of allSupportedHashAlgorithms) {\n      for (const operation of nonCreateOperations) {\n        const operationProcessor = this.versionManager.getOperationProcessor(\n          operation.transactionTime\n        );\n        const revealValueBuffer = await operationProcessor.getRevealValue(\n          operation\n        );\n\n        const hashOfRevealValue = Multihash.hashThenEncode(\n          revealValueBuffer,\n          hashAlgorithm\n        );\n\n        if (commitValueToOperationMap.has(hashOfRevealValue)) {\n          commitValueToOperationMap.get(hashOfRevealValue)!.push(operation);\n        } else {\n          commitValueToOperationMap.set(hashOfRevealValue, [operation]);\n        }\n      }\n    }\n\n    return commitValueToOperationMap;\n  }\n}\n","/*\n * The code in this file originated from\n * @see https://github.com/decentralized-identity/sidetree\n * For the list of changes that was made to the original code\n * @see https://github.com/transmute-industries/sidetree.js/blob/master/reference-implementation-changes.md\n *\n * Copyright 2020 - Transmute Industries Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ServiceVersionModel } from '@sidetree/common';\n/**\n * Encapsulates the functionality to get the information about the service such as\n * version info.\n */\nexport default class ServiceInfoProvider {\n  private static readonly packageJson = require('../package.json');\n  private serviceName: string;\n\n  constructor(serviceName: string) {\n    this.serviceName = serviceName;\n  }\n\n  /**\n   * Gets the service version from the package.json file.\n   */\n  public getServiceVersion(): ServiceVersionModel {\n    return {\n      name: this.serviceName,\n      version: ServiceInfoProvider.packageJson.version,\n    };\n  }\n}\n","/*\n * The code in this file originated from\n * @see https://github.com/decentralized-identity/sidetree\n * For the list of changes that was made to the original code\n * @see https://github.com/transmute-industries/sidetree.js/blob/master/reference-implementation-changes.md\n *\n * Copyright 2020 - Transmute Industries Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  AbstractVersionMetadata,\n  Config,\n  CoreErrorCode,\n  IBatchWriter,\n  IBlockchain,\n  ICas,\n  IOperationProcessor,\n  IOperationStore,\n  IRequestHandler,\n  ITransactionProcessor,\n  ITransactionSelector,\n  ITransactionStore,\n  IVersionManager,\n  IVersionMetadataFetcher,\n  ProtocolVersionModel,\n  SidetreeError,\n  IOperationQueue,\n} from '@sidetree/common';\nimport DownloadManager from './DownloadManager';\nimport Resolver from './Resolver';\n\n/**\n * The class that handles the loading of different versions of protocol codebase.\n */\nexport default class VersionManager\n  implements IVersionManager, IVersionMetadataFetcher {\n  public allSupportedHashAlgorithms: number[] = [];\n\n  // Reverse sorted protocol versions. ie. latest version first.\n  private protocolVersionsReverseSorted: ProtocolVersionModel[];\n\n  private batchWriters: Map<string, IBatchWriter>;\n  private operationProcessors: Map<string, IOperationProcessor>;\n  private operationQueues: Map<string, IOperationQueue>;\n  private requestHandlers: Map<string, IRequestHandler>;\n  private transactionProcessors: Map<string, ITransactionProcessor>;\n  private transactionSelectors: Map<string, ITransactionSelector>;\n  private versionMetadatas: Map<string, AbstractVersionMetadata>;\n\n  public constructor(\n    private config: Config,\n    protocolVersions: ProtocolVersionModel[]\n  ) {\n    // Reverse sort protocol versions.\n    this.protocolVersionsReverseSorted = protocolVersions.sort(\n      (a, b) => b.startingBlockchainTime - a.startingBlockchainTime\n    );\n\n    this.batchWriters = new Map();\n    this.operationProcessors = new Map();\n    this.operationQueues = new Map();\n    this.requestHandlers = new Map();\n    this.transactionProcessors = new Map();\n    this.transactionSelectors = new Map();\n    this.versionMetadatas = new Map();\n  }\n\n  /**\n   * Loads all the versions of the protocol codebase.\n   */\n  public async initialize(\n    blockchain: IBlockchain,\n    cas: ICas,\n    downloadManager: DownloadManager,\n    operationStore: IOperationStore,\n    resolver: Resolver,\n    transactionStore: ITransactionStore\n  ): Promise<void> {\n    // Instantiate rest of the protocol components.\n    // NOTE: In principal each version of the interface implemtnations can have different constructors,\n    // but we currently keep the constructor signature the same as much as possible for simple instance construction,\n    // but it is not inherently \"bad\" if we have to have conditional constructions for each if we have to.\n    for (const protocolVersion of this.protocolVersionsReverseSorted) {\n      const version = protocolVersion.version;\n\n      /* tslint:disable-next-line */\n      const MongoDbOperationQueue = await this.loadDefaultExportsForVersion(\n        version,\n        'MongoDbOperationQueue'\n      );\n      const operationQueue = new MongoDbOperationQueue(\n        this.config.mongoDbConnectionString,\n        this.config.databaseName\n      );\n      await operationQueue.initialize();\n      this.operationQueues.set(version, operationQueue);\n\n      /* tslint:disable-next-line */\n      const TransactionProcessor = await this.loadDefaultExportsForVersion(\n        version,\n        'TransactionProcessor'\n      );\n      const transactionProcessor = new TransactionProcessor(\n        downloadManager,\n        operationStore,\n        blockchain,\n        this\n      );\n      this.transactionProcessors.set(version, transactionProcessor);\n\n      /* tslint:disable-next-line */\n      const TransactionSelector = await this.loadDefaultExportsForVersion(\n        version,\n        'TransactionSelector'\n      );\n      const transactionSelector = new TransactionSelector(transactionStore);\n      this.transactionSelectors.set(version, transactionSelector);\n\n      /* tslint:disable-next-line */\n      const BatchWriter = await this.loadDefaultExportsForVersion(\n        version,\n        'BatchWriter'\n      );\n      const batchWriter = new BatchWriter(\n        operationQueue,\n        blockchain,\n        cas,\n        this\n      );\n      this.batchWriters.set(version, batchWriter);\n\n      /* tslint:disable-next-line */\n      const OperationProcessor = await this.loadDefaultExportsForVersion(\n        version,\n        'OperationProcessor'\n      );\n      const operationProcessor = new OperationProcessor();\n      this.operationProcessors.set(version, operationProcessor);\n\n      /* tslint:disable-next-line */\n      const RequestHandler = await this.loadDefaultExportsForVersion(\n        version,\n        'RequestHandler'\n      );\n      const requestHandler = new RequestHandler(\n        resolver,\n        operationQueue,\n        this.config.didMethodName\n      );\n      this.requestHandlers.set(version, requestHandler);\n\n      /* tslint:disable-next-line */\n      const VersionMetadata = await this.loadDefaultExportsForVersion(\n        version,\n        'VersionMetadata'\n      );\n      const versionMetadata = new VersionMetadata();\n      if (!(versionMetadata instanceof AbstractVersionMetadata)) {\n        throw new SidetreeError(\n          CoreErrorCode.VersionManagerVersionMetadataIncorrectType,\n          `make sure VersionMetaData is properly implemented for version ${version}`\n        );\n      }\n      this.versionMetadatas.set(version, versionMetadata);\n    }\n\n    // Get and cache supported hash algorithms.\n    const hashAlgorithmsWithDuplicates = Array.from(\n      this.versionMetadatas.values(),\n      (value) => value.hashAlgorithmInMultihashCode\n    );\n    this.allSupportedHashAlgorithms = Array.from(\n      new Set(hashAlgorithmsWithDuplicates)\n    ); // This line removes duplicates.\n  }\n\n  /**\n   * Gets the corresponding version of the `IBatchWriter` based on the given blockchain time.\n   */\n  public getBatchWriter(blockchainTime: number): IBatchWriter {\n    const version = this.getVersionString(blockchainTime);\n    const batchWriter = this.batchWriters.get(version);\n\n    if (batchWriter === undefined) {\n      throw new SidetreeError(\n        CoreErrorCode.VersionManagerBatchWriterNotFound,\n        `Batch writer for blockchain time ${blockchainTime} not found.`\n      );\n    }\n\n    return batchWriter;\n  }\n\n  /**\n   * Gets the corresponding version of the `IOperationProcessor` based on the given blockchain time.\n   */\n  public getOperationProcessor(blockchainTime: number): IOperationProcessor {\n    const version = this.getVersionString(blockchainTime);\n    const operationProcessor = this.operationProcessors.get(version);\n\n    if (operationProcessor === undefined) {\n      throw new SidetreeError(\n        CoreErrorCode.VersionManagerOperationProcessorNotFound,\n        `Operation processor for blockchain time ${blockchainTime} not found.`\n      );\n    }\n\n    return operationProcessor;\n  }\n\n  /**\n   * Gets the corresponding version of the `IRequestHandler` based on the given blockchain time.\n   */\n  public getRequestHandler(blockchainTime: number): IRequestHandler {\n    const version = this.getVersionString(blockchainTime);\n    const requestHandler = this.requestHandlers.get(version);\n\n    if (requestHandler === undefined) {\n      throw new SidetreeError(\n        CoreErrorCode.VersionManagerRequestHandlerNotFound,\n        `Request handler for blockchain time ${blockchainTime} not found.`\n      );\n    }\n\n    return requestHandler;\n  }\n\n  /**\n   * Gets the corresponding version of the `TransactionProcessor` based on the given blockchain time.\n   */\n  public getTransactionProcessor(\n    blockchainTime: number\n  ): ITransactionProcessor {\n    const version = this.getVersionString(blockchainTime);\n    const transactionProcessor = this.transactionProcessors.get(version);\n\n    if (transactionProcessor === undefined) {\n      throw new SidetreeError(\n        CoreErrorCode.VersionManagerTransactionProcessorNotFound,\n        `Transaction processor for blockchain time ${blockchainTime} not found.`\n      );\n    }\n\n    return transactionProcessor;\n  }\n\n  /**\n   * Gets the corresponding version of the `TransactionSelector` based on the given blockchain time.\n   */\n  public getTransactionSelector(blockchainTime: number): ITransactionSelector {\n    const version = this.getVersionString(blockchainTime);\n    const transactionSelector = this.transactionSelectors.get(version);\n\n    if (transactionSelector === undefined) {\n      throw new SidetreeError(\n        CoreErrorCode.VersionManagerTransactionSelectorNotFound,\n        `Transaction selector for blockchain time ${blockchainTime} not found.`\n      );\n    }\n\n    return transactionSelector;\n  }\n\n  public getVersionMetadata(blockchainTime: number): AbstractVersionMetadata {\n    const versionString = this.getVersionString(blockchainTime);\n    const versionMetadata = this.versionMetadatas.get(versionString);\n    // this is always be defined because if blockchain time is found, version will be defined\n    return versionMetadata!;\n  }\n\n  public getOperationQueue(blockchainTime: number): IOperationQueue {\n    const versionString = this.getVersionString(blockchainTime);\n    const operationQueue = this.operationQueues.get(versionString);\n    // this is always be defined because if blockchain time is found, version will be defined\n    return operationQueue!;\n  }\n\n  /**\n   * Gets the corresponding protocol version string given the blockchain time.\n   */\n  private getVersionString(blockchainTime: number): string {\n    // Iterate through each version to find the right version.\n    for (const protocolVersion of this.protocolVersionsReverseSorted) {\n      if (blockchainTime >= protocolVersion.startingBlockchainTime) {\n        return protocolVersion.version;\n      }\n    }\n\n    throw new SidetreeError(\n      CoreErrorCode.VersionManagerVersionStringNotFound,\n      `Unable to find version string for blockchain time ${blockchainTime}.`\n    );\n  }\n\n  private async loadDefaultExportsForVersion(\n    version: string,\n    className: string\n  ): Promise<any> {\n    if (version === 'latest') {\n      switch (className) {\n        case 'MongoDbOperationQueue':\n          return (await import('@sidetree/db')).MongoDbOperationQueue;\n        case 'TransactionProcessor':\n          return (await import('./TransactionProcessor')).default;\n        case 'TransactionSelector':\n          return (await import('./TransactionSelector')).default;\n        case 'BatchWriter':\n          return (await import('./write/BatchWriter')).default;\n        case 'OperationProcessor':\n          return (await import('./OperationProcessor')).default;\n        case 'RequestHandler':\n          return (await import('./RequestHandler')).default;\n        case 'VersionMetadata':\n          return (await import('./VersionMetadata')).default;\n        default:\n          return;\n      }\n    }\n    return (await import(`./versions/${version}/${className}`)).default;\n  }\n}\n"],"names":["ArrayMethods","hasDuplicates","array","uniqueValues","Set","i","length","value","has","add","areMutuallyExclusive","array1","array2","valuesInArray1","pako","require","Compressor","compress","inputAsBuffer","result","deflate","Buffer","from","decompress","inflate","DocumentComposer","transformToExternalDocument","didState","did","nextRecoveryCommitmentHash","undefined","status","document","shortFormDid","split","authentication","assertionMethod","capabilityInvocation","capabilityDelegation","keyAgreement","public_keys","Array","isArray","publicKey","id","didDocumentPublicKey","controller","type","publicKeyJwk","jwk","purposeSet","purpose","PublicKeyPurpose","General","push","Auth","AssertionMethod","CapabilityInvocation","CapabilityDelegation","KeyAgreement","service_endpoints","serviceEndpoint","didDocumentServiceEndpoint","endpoint","didDocument","service","didResolutionResult","methodMetadata","recoveryCommitment","updateCommitment","nextUpdateCommitmentHash","JSON","parse","stringify","applyUpdateOperation","operation","resultantDocument","applyPatches","delta","patches","validateDocument","SidetreeError","ErrorCode","DocumentComposerDocumentMissing","allowedProperties","property","DocumentComposerUnknownPropertyInDocument","Object","prototype","hasOwnProperty","call","validatePublicKeys","validateServiceEndpoints","validateDocumentPatches","DocumentComposerUpdateOperationDocumentPatchesNotArray","patch","validatePatch","action","validateAddPublicKeysPatch","validateRemovePublicKeysPatch","validateAddServiceEndpointsPatch","validateRemoveServiceEndpointsPatch","validateIetfJsonPatch","DocumentComposerPatchMissingOrUnknownAction","patchProperties","keys","DocumentComposerPatchMissingOrUnknownProperty","error","jsonpatch","validate","console","warn","name","DocumentComposerPublicKeysNotArray","publicKeyIdSet","publicKeyProperties","DocumentComposerPublicKeyMissingOrUnknownProperty","DocumentComposerPublicKeyJwkMissingOrIncorrectType","DocumentComposerPublicKeyTypeMissingOrIncorrectType","validateId","DocumentComposerPublicKeyIdDuplicated","DocumentComposerPublicKeyPurposeMissingOrUnknown","values","DocumentComposerPublicKeyPurposeExceedsMaxLength","validPurposes","DocumentComposerPublicKeyInvalidPurpose","DocumentComposerPatchPublicKeyIdsNotArray","publicKeyId","DocumentComposerPatchPublicKeyIdNotString","ids","DocumentComposerPatchServiceEndpointIdsNotArray","DocumentComposerPatchServiceEndpointsNotArray","serviceEndpointProperties","DocumentComposerServiceEndpointMissingOrUnknownProperty","DocumentComposerPatchServiceEndpointTypeNotString","DocumentComposerPatchServiceEndpointTypeTooLong","DocumentComposerPatchServiceEndpointServiceEndpointNotString","DocumentComposerPatchServiceEndpointServiceEndpointTooLong","URL","DocumentComposerPatchServiceEndpointServiceEndpointNotValidUrl","DocumentComposerIdNotString","DocumentComposerIdTooLong","Encoder","isBase64UrlString","DocumentComposerIdNotUsingBase64UrlCharacterSet","applyPatchToDidDocument","addPublicKeys","removePublicKeys","addServiceEndpoints","removeServiceEndpoints","applyIetfJsonPatch","res","applyPatch","newDocument","publicKeyMap","Map","map","set","entries","pkm","existingKey","get","idToIndexMapper","idx","idsToRemove","filter","yieldableJson","JsonAsync","jsonData","jsonParsePromise","Promise","resolve","reject","parseAsync","err","data","OperationUtils","parseDelta","deltaEncodedString","DeltaMissingOrNotString","deltaJsonString","decodeAsString","properties","DeltaMissingOrUnknownProperty","OperationDocumentPatchesMissing","nextUpdateCommitment","decodeAsBuffer","update_commitment","Multihash","verifyHashComputedUsingLatestSupportedAlgorithm","CreateOperation","operationBuffer","didUniqueSuffix","encodedSuffixData","suffixData","encodedDelta","OperationType","Create","computeDidUniqueSuffix","suffixDataBuffer","multihash","hash","encodedMultihash","encode","parseOperationFromAnchorFile","input","parseObject","operationJsonString","toString","operationObject","anchorFileMode","expectedPropertyCount","CreateOperationMissingOrUnknownProperty","suffix_data","parseSuffixData","CreateOperationTypeIncorrect","suffixDataEncodedString","CreateOperationSuffixDataMissingOrNotString","suffixDataJsonString","CreateOperationSuffixDataMissingOrUnknownProperty","delta_hash","nextRecoveryCommitment","recovery_commitment","Jwk","generateEd25519KeyPair","JWK","generate","keyPair","privateKey","toJWK","getBufferAtIndex","mnemonic","index","bip39","seed","root","hdkey","fromMasterSeed","hdPath","addrNode","derive","generateEd25519KeyPairFromMnemonic","privateKeyBuffer","Ed25519KeyPair","ed25519KeyPair","toJwk","privateKeyJwk","generateSecp256k1KeyPair","generateJwkKeyPairFromMnemonic","keyType","generateSecp256k1KeyPairFromMnemonic","Error","keytoFrom","crv","validatePublicJwk","JwkUndefined","JwkHasUnknownProperty","kty","JwkMissingOrInvalidKty","x","JwkMissingOrInvalidTypeX","y","JwkMissingOrInvalidTypeY","JwkMissingOrInvalidCrv","getCurve25519PublicKey","keyCopy","assign","d","Jws","compactJws","JwsCompactJwsNotString","parts","JwsCompactJwsInvalid","protectedHeader","payload","signature","decodedProtectedHeadJsonString","decodeBase64UrlAsString","decodedProtectedHeader","expectedHeaderPropertyCount","headerProperties","JwsProtectedHeaderMissingOrUnknownProperty","alg","JwsProtectedHeaderMissingOrIncorrectAlg","JwsSignatureNotBase64UrlString","JwsPayloadNotBase64UrlString","toCompactJws","createCompactJws","verifySignature","encodedProtectedHeader","encodedPayload","jwsSigningInput","verifyCompactJws","EdDSA","verify","ES256K","log","createFromError","JwsFailedSignatureValidation","signAsCompactJws","sign","header","parseCompactJws","DeactivateOperation","signedDataJws","signedData","Deactivate","DeactivateOperationMissingOrUnknownProperty","did_suffix","DeactivateOperationMissingOrInvalidDidUniqueSuffix","signed_data","parseSignedDataPayload","DeactivateOperationTypeIncorrect","expectedDidUniqueSuffix","signedDataJsonString","DeactivateOperationSignedDataMissingOrUnknownProperty","DeactivateOperationSignedDidUniqueSuffixMismatch","recovery_key","didSuffix","RecoverOperation","Recover","RecoverOperationMissingOrUnknownProperty","RecoverOperationMissingOrInvalidDidUniqueSuffix","RecoverOperationTypeIncorrect","signedDataEncodedString","RecoverOperationSignedDataMissingOrUnknownProperty","AnchorFile","model","didUniqueSuffixes","createOperations","recoverOperations","deactivateOperations","anchorFileBuffer","AnchorFileMultipleOperationsForTheSameDid","anchorFile","anchorFileModel","operations","deactivate","AnchorFileDeactivatePropertyNotArray","deactivateOperation","recover","AnchorFileRecoverPropertyNotArray","recoverOperation","AnchorFileHasUnknownProperty","AnchorFileMapFileHashMissing","AnchorFileMissingOperationsProperty","writer_lock_id","AnchorFileWriterLockIPropertyNotString","mapFileUri","map_file_uri","AnchorFileMapFileHashNotString","allowedOperationsProperties","AnchorFileUnexpectedPropertyInOperations","create","AnchorFileCreatePropertyNotArray","createOperation","anchorFileDecompressedBuffer","e","AnchorFileNotJson","AnchorFileDecompressionFailure","createModel","writerLockId","mapFileHash","createOperationArray","recoverOperationArray","deactivateOperationArray","createBuffer","anchorFileJson","BatchScheduler","versionManager","blockchain","batchingIntervalInSeconds","startPeriodicBatchWriting","continuePeriodicBatchWriting","setImmediate","writeOperationBatch","stopPeriodicBatchWriting","info","endTimer","timeSpan","currentTime","approximateTime","time","batchWriter","getBatchWriter","write","rounded","setTimeout","ChunkFile","chunkFileBuffer","decompressedChunkFileBuffer","chunkFileObject","ChunkFileUnexpectedProperty","validateDeltasProperty","deltas","ChunkFileDeltasPropertyNotArray","ChunkFileDeltasNotArrayOfStrings","deltaBuffer","protocolParameters","maxDeltaSizeInBytes","ChunkFileDeltaSizeExceedsLimit","updateOperations","chunkFileModel","rawData","DownloadManager","maxConcurrentDownloads","cas","isNaN","defaultmaxConcurrentDownloads","start","completedDownloadHandles","activeDownloads","downloadHandle","downloadInfo","completed","completedDownloads","fetchResult","availableDownloadLanes","size","pendingDownloads","downloadAsync","handle","splice","download","contentHash","maxSizeInBytes","crypto","fetchPromise","content","read","UpdateOperation","Update","parseOperationFromMapFile","mapFileMode","UpdateOperationMissingOrUnknownProperty","UpdateOperationMissingDidUniqueSuffix","signedDataModel","UpdateOperationTypeIncorrect","UpdateOperationSignedDataHasMissingOrUnknownProperty","update_key","MapFile","mapFileBuffer","mapFileModel","MapFileHasUnknownProperty","validateChunksProperty","chunks","parseOperationsProperty","mapFile","decompressedBuffer","MapFileNotJson","MapFileDecompressionFailure","MapFileMultipleOperationsForTheSameDid","MapFileOperationsPropertyHasMissingOrUnknownProperty","update","MapFileUpdateOperationsNotArray","updateOperation","MapFileChunksPropertyMissingOrIncorrectType","MapFileChunksPropertyDoesNotHaveExactlyOneElement","chunk","MapFileChunkHasMissingOrUnknownProperty","chunkFileHash","updateOperationArray","chunk_file_uri","ThroughputLimiter","getQualifiedTransactions","transactions","currentTransactionTime","transactionsGroupedByTransactionTime","transaction","transactionTime","qualifiedTransactions","transactionGroup","transactionSelector","getTransactionSelector","selectQualifiedTransactions","qualifiedTransactionsInCurrentGroup","Observer","operationStore","transactionStore","unresolvableTransactionStore","observingIntervalInSeconds","throughputLimiter","refreshLastKnownTransaction","getLastTransaction","lastKnownTransaction","startPeriodicProcessing","continuePeriodicProcessing","processTransactions","stopPeriodicProcessing","awaitTransactionProcessing","storeConsecutiveTransactionsProcessed","processUnresolvableTransactions","moreTransactions","readResult","blockReorganizationDetected","invalidTransactionNumberOrTimeHash","lastKnownTransactionTime","waitUntilCountOfTransactionsUnderProcessingIsLessOrEqualTo","revertInvalidTransactions","sort","a","b","transactionNumber","awaitingTransaction","processingStatus","TransactionProcessingStatus","Pending","transactionsUnderProcessing","processTransaction","lastKnownTransactionNumber","lastKnownTransactionTimeHash","transactionTimeHash","nextTransactionNumber","code","SharedErrorCode","InvalidTransactionNumberOrTimeHash","count","getUnresolvableTransactionsDueForRetry","unresolvableTransactions","unresolvableTransactionStatus","Processed","addTransaction","transactionUnderProcessing","transactionProcessedSuccessfully","transactionProcessor","getTransactionProcessor","removeUnresolvableTransaction","recordUnresolvableTransactionFetchAttempt","getExponentiallySpacedTransactions","exponentiallySpacedTransactions","getFirstValidTransaction","bestKnownValidRecentTransaction","bestKnownValidRecentTransactionNumber","removeTransactionsLaterThan","removeUnresolvableTransactionsLaterThan","Operation","operationType","isAnchorFileMode","OperationTypeUnknownOrMissing","OperationGenerator","generateRandomHash","randomBuffer","randomHash","generateKeyPair","publicKeyModel","generateAnchoredCreateOperation","generateCreateOperation","createOperationData","anchoredOperationModel","operationIndex","operationRequest","recoveryPublicKey","recoveryPrivateKey","updatePublicKey","updatePrivateKey","signingPublicKey","signingPrivateKey","nextUpdateRevealValueEncodedString","signingKeyId","generateServiceEndpoints","generateCreateOperationRequest","canonicalizeThenHashThenEncode","generateRecoverOperation","newSigningKeyId","newRecoveryPublicKey","newRecoveryPrivateKey","newSigningPublicKey","newSigningPrivateKey","publicKeyToBeInDocument","services","generateRecoverOperationRequest","operationJson","generateUpdateOperation","additionalKeyId","additionalPublicKey","additionalPrivateKey","createUpdateOperationRequestForAddingAKey","nextUpdateKey","createAnchoredOperationModelFromOperationModel","operationModel","otherPublicKeys","generateUpdateOperationRequest","anyNewSigningPublicKeyId","anyNewSigningKey","createUpdateOperationRequest","request","buffer","encodedDeltaString","signedDataPayloadObject","signUsingEd25519","updateOperationRequest","createRecoverOperationRequest","createDeactivateOperationRequest","generateCreateOperationBuffer","newPublicKey","createUpdateOperationRequestForHubEndpoints","idOfServiceEndpointToAdd","idsOfServiceEndpointToRemove","createDeactivateOperation","Resolver","operationsByType","categorizeOperationsByType","applyCreateOperation","recoverAndDeactivateOperations","concat","constructCommitValueToOperationLookupMap","recoveryCommitValueToOperationMap","applyRecoverAndDeactivateOperations","updateCommitValueToOperationMap","applyUpdateOperations","applyOperation","startingDidState","commitValueToOperationMap","operationsWithCorrectRevealValue","applyFirstValidOperation","newDidState","appliedDidState","operationProcessor","getOperationProcessor","apply","originalDidState","lastOperationTransactionNumber","nonCreateOperations","allSupportedHashAlgorithms","hashAlgorithm","getRevealValue","revealValueBuffer","hashOfRevealValue","hashThenEncode","ServiceInfoProvider","serviceName","getServiceVersion","version","packageJson","VersionManager","config","protocolVersions","protocolVersionsReverseSorted","startingBlockchainTime","batchWriters","operationProcessors","operationQueues","requestHandlers","transactionProcessors","transactionSelectors","versionMetadatas","initialize","downloadManager","resolver","hashAlgorithmsWithDuplicates","hashAlgorithmInMultihashCode","protocolVersion","loadDefaultExportsForVersion","MongoDbOperationQueue","operationQueue","mongoDbConnectionString","databaseName","TransactionProcessor","TransactionSelector","BatchWriter","OperationProcessor","RequestHandler","requestHandler","didMethodName","VersionMetadata","versionMetadata","AbstractVersionMetadata","CoreErrorCode","VersionManagerVersionMetadataIncorrectType","blockchainTime","getVersionString","VersionManagerBatchWriterNotFound","VersionManagerOperationProcessorNotFound","getRequestHandler","VersionManagerRequestHandlerNotFound","VersionManagerTransactionProcessorNotFound","VersionManagerTransactionSelectorNotFound","getVersionMetadata","versionString","getOperationQueue","VersionManagerVersionStringNotFound","className"],"mappings":"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"}