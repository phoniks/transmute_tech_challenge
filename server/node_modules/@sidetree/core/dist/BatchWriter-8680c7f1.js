import { d as Operation, C as ChunkFile, M as MapFile, A as AnchorFile } from './index-f6e63a58.js';
import { OperationType, AnchoredDataSerializer, protocolParameters } from '@sidetree/common';
import 'fast-json-patch';
import 'jose';
import 'bip39';
import '@transmute/did-key-ed25519';
import 'hdkey';
import '@trust/keyto';
import '@transmute/did-key-secp256k1';
import 'time-span';
import 'crypto';
import { F as FeeManager, V as ValueTimeLockVerifier } from './ValueTimeLockVerifier-ce5b08d2.js';
import chalk from 'chalk';

/*
 * The code in this file originated from
 * @see https://github.com/decentralized-identity/sidetree
 * For the list of changes that was made to the original code
 * @see https://github.com/transmute-industries/sidetree.js/blob/master/reference-implementation-changes.md
 *
 * Copyright 2020 - Transmute Industries Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Abstraction for colored logs.
 */

var LogColor = function LogColor() {};
LogColor.lightBlue = /*#__PURE__*/chalk.hex('#75b0eb');
/** Method for logging in green. */

LogColor.green = chalk.green;
/** Method for logging in yellow. */

LogColor.yellow = chalk.yellow;

/*
 * The code in this file originated from
 * @see https://github.com/decentralized-identity/sidetree
 * For the list of changes that was made to the original code
 * @see https://github.com/transmute-industries/sidetree.js/blob/master/reference-implementation-changes.md
 *
 * Copyright 2020 - Transmute Industries Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Implementation of the `IBatchWriter`.
 */

var BatchWriter = /*#__PURE__*/function () {
  function BatchWriter(operationQueue, blockchain, cas, versionMetadataFetcher) {
    this.operationQueue = operationQueue;
    this.blockchain = blockchain;
    this.cas = cas;
    this.versionMetadataFetcher = versionMetadataFetcher;
  }

  var _proto = BatchWriter.prototype;

  _proto.write = function write() {
    try {
      var _this2 = this;

      return Promise.resolve(_this2.blockchain.getFee(_this2.blockchain.approximateTime.time)).then(function (normalizedFee) {
        return Promise.resolve(_this2.blockchain.getWriterValueTimeLock()).then(function (currentLock) {
          var numberOfOpsAllowed = _this2.getNumberOfOperationsAllowed(currentLock); // Get the batch of operations to be anchored on the blockchain.


          return Promise.resolve(_this2.operationQueue.peek(numberOfOpsAllowed)).then(function (queuedOperations) {
            var numberOfOperations = queuedOperations.length; // Do nothing if there is nothing to batch together.

            if (queuedOperations.length === 0) {
              console.info("No queued operations to batch.");
              return;
            }

            console.info(LogColor.lightBlue("Batch size = " + LogColor.green("" + numberOfOperations)));
            return Promise.resolve(Promise.all(queuedOperations.map(function (queuedOperation) {
              try {
                return Promise.resolve(Operation.parse(queuedOperation.operationBuffer));
              } catch (e) {
                return Promise.reject(e);
              }
            }))).then(function (operationModels) {
              var createOperations = operationModels.filter(function (operation) {
                return operation.type === OperationType.Create;
              });
              var recoverOperations = operationModels.filter(function (operation) {
                return operation.type === OperationType.Recover;
              });
              var updateOperations = operationModels.filter(function (operation) {
                return operation.type === OperationType.Update;
              });
              var deactivateOperations = operationModels.filter(function (operation) {
                return operation.type === OperationType.Deactivate;
              }); // Create the chunk file buffer from the operation models.
              // NOTE: deactivate operations don't have delta.

              return Promise.resolve(ChunkFile.createBuffer(createOperations, recoverOperations, updateOperations)).then(function (chunkFileBuffer) {
                // Write the chunk file to content addressable store.
                return Promise.resolve(_this2.cas.write(chunkFileBuffer)).then(function (chunkFileHash) {
                  console.info(LogColor.lightBlue("Wrote chunk file " + LogColor.green(chunkFileHash) + " to content addressable store.")); // Write the map file to content addressable store.

                  return Promise.resolve(MapFile.createBuffer(chunkFileHash, updateOperations)).then(function (mapFileBuffer) {
                    return Promise.resolve(_this2.cas.write(mapFileBuffer)).then(function (mapFileHash) {
                      console.info(LogColor.lightBlue("Wrote map file " + LogColor.green(mapFileHash) + " to content addressable store.")); // Write the anchor file to content addressable store.

                      var writerLockId = currentLock ? currentLock.identifier : undefined;
                      return Promise.resolve(AnchorFile.createBuffer(writerLockId, mapFileHash, createOperations, recoverOperations, deactivateOperations)).then(function (anchorFileBuffer) {
                        return Promise.resolve(_this2.cas.write(anchorFileBuffer)).then(function (anchorFileHash) {
                          console.info(LogColor.lightBlue("Wrote anchor file " + LogColor.green(anchorFileHash) + " to content addressable store.")); // Anchor the data to the blockchain

                          var dataToBeAnchored = {
                            anchorFileHash: anchorFileHash,
                            numberOfOperations: numberOfOperations
                          };
                          var stringToWriteToBlockchain = AnchoredDataSerializer.serialize(dataToBeAnchored);
                          var fee = FeeManager.computeMinimumTransactionFee(normalizedFee, numberOfOperations);
                          console.info(LogColor.lightBlue("Writing data to blockchain: " + LogColor.green(stringToWriteToBlockchain) + " with minimum fee of: " + LogColor.green("" + fee)));
                          return Promise.resolve(_this2.blockchain.write(stringToWriteToBlockchain, fee)).then(function () {
                            // Remove written operations from queue after batch writing has completed successfully.
                            return Promise.resolve(_this2.operationQueue.dequeue(queuedOperations.length)).then(function () {});
                          });
                        });
                      });
                    });
                  });
                });
              });
            });
          });
        });
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.getNumberOfOperationsAllowed = function getNumberOfOperationsAllowed(valueTimeLock) {
    var maxNumberOfOpsAllowedByProtocol = protocolParameters.maxOperationsPerBatch;
    var maxNumberOfOpsAllowedByLock = ValueTimeLockVerifier.calculateMaxNumberOfOperationsAllowed(valueTimeLock, this.versionMetadataFetcher);

    if (maxNumberOfOpsAllowedByLock > maxNumberOfOpsAllowedByProtocol) {
      // tslint:disable-next-line: max-line-length
      console.info("Maximum number of operations allowed by value time lock: " + maxNumberOfOpsAllowedByLock + "; Maximum number of operations allowed by protocol: " + maxNumberOfOpsAllowedByProtocol);
    }

    return Math.min(maxNumberOfOpsAllowedByLock, maxNumberOfOpsAllowedByProtocol);
  };

  return BatchWriter;
}();

export default BatchWriter;
//# sourceMappingURL=BatchWriter-8680c7f1.js.map
