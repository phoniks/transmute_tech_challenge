{"version":3,"file":"OperationProcessor-691a8d37.js","sources":["../src/OperationProcessor.ts"],"sourcesContent":["/*\n * The code in this file originated from\n * @see https://github.com/decentralized-identity/sidetree\n * For the list of changes that was made to the original code\n * @see https://github.com/transmute-industries/sidetree.js/blob/master/reference-implementation-changes.md\n *\n * Copyright 2020 - Transmute Industries Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/* eslint-disable no-case-declarations */\nimport {\n  AnchoredOperationModel,\n  DidState,\n  ErrorCode,\n  IOperationProcessor,\n  JsonCanonicalizer,\n  Multihash,\n  OperationType,\n  SidetreeError,\n} from '@sidetree/common';\nimport CreateOperation from './CreateOperation';\nimport DeactivateOperation from './DeactivateOperation';\nimport DocumentComposer from './DocumentComposer';\nimport Operation from './Operation';\nimport RecoverOperation from './RecoverOperation';\nimport UpdateOperation from './UpdateOperation';\n\n/**\n * Implementation of IOperationProcessor.\n */\nexport default class OperationProcessor implements IOperationProcessor {\n  public async apply(\n    anchoredOperationModel: AnchoredOperationModel,\n    didState: DidState | undefined\n  ): Promise<DidState | undefined> {\n    // If DID state is undefined, then the operation given must be a create operation, otherwise the operation cannot be applied.\n    if (\n      didState === undefined &&\n      anchoredOperationModel.type !== OperationType.Create\n    ) {\n      return undefined;\n    }\n\n    const previousOperationTransactionNumber = didState\n      ? didState.lastOperationTransactionNumber\n      : undefined;\n\n    let appliedDidState: DidState | undefined;\n    if (anchoredOperationModel.type === OperationType.Create) {\n      appliedDidState = await this.applyCreateOperation(\n        anchoredOperationModel,\n        didState\n      );\n    } else if (anchoredOperationModel.type === OperationType.Update) {\n      appliedDidState = await this.applyUpdateOperation(\n        anchoredOperationModel,\n        didState!\n      );\n    } else if (anchoredOperationModel.type === OperationType.Recover) {\n      appliedDidState = await this.applyRecoverOperation(\n        anchoredOperationModel,\n        didState!\n      );\n    } else if (anchoredOperationModel.type === OperationType.Deactivate) {\n      appliedDidState = await this.applyDeactivateOperation(\n        anchoredOperationModel,\n        didState!\n      );\n    } else {\n      throw new SidetreeError(ErrorCode.OperationProcessorUnknownOperationType);\n    }\n\n    try {\n      // If the operation was not applied, log some info in case needed for debugging.\n      if (\n        appliedDidState === undefined ||\n        appliedDidState.lastOperationTransactionNumber ===\n          previousOperationTransactionNumber\n      ) {\n        const index = anchoredOperationModel.operationIndex;\n        const time = anchoredOperationModel.transactionTime;\n        const number = anchoredOperationModel.transactionNumber;\n        const didUniqueSuffix = anchoredOperationModel.didUniqueSuffix;\n        console.debug(\n          `Ignored invalid operation for DID '${didUniqueSuffix}' in transaction '${number}' at time '${time}' at operation index ${index}.`\n        );\n      }\n    } catch (error) {\n      console.log(`Failed logging ${error}.`);\n      // If logging fails, just move on.\n    }\n\n    return appliedDidState;\n  }\n\n  public async getRevealValue(\n    anchoredOperationModel: AnchoredOperationModel\n  ): Promise<Buffer> {\n    if (anchoredOperationModel.type === OperationType.Create) {\n      throw new SidetreeError(\n        ErrorCode.OperationProcessorCreateOperationDoesNotHaveRevealValue\n      );\n    }\n\n    const operation = await Operation.parse(\n      anchoredOperationModel.operationBuffer\n    );\n\n    let revealValueBuffer;\n    switch (operation.type) {\n      case OperationType.Recover:\n        const recoverOperation = operation as RecoverOperation;\n        revealValueBuffer = JsonCanonicalizer.canonicalizeAsBuffer(\n          recoverOperation.signedData.recovery_key\n        );\n        return revealValueBuffer;\n      case OperationType.Update:\n        const updateOperation = operation as UpdateOperation;\n        revealValueBuffer = JsonCanonicalizer.canonicalizeAsBuffer(\n          updateOperation.signedData.update_key\n        );\n        return revealValueBuffer;\n      default:\n        // This is a deactivate.\n        const deactivateOperation = operation as DeactivateOperation;\n        revealValueBuffer = JsonCanonicalizer.canonicalizeAsBuffer(\n          deactivateOperation.signedData.recovery_key\n        );\n        return revealValueBuffer;\n    }\n  }\n\n  /**\n   * @returns new DID state if operation is applied successfully; the given DID state otherwise.\n   */\n  private async applyCreateOperation(\n    anchoredOperationModel: AnchoredOperationModel,\n    didState: DidState | undefined\n  ): Promise<DidState | undefined> {\n    // If DID state is already created by a previous create operation, then we cannot apply a create operation again.\n    if (didState !== undefined) {\n      return didState;\n    }\n\n    const operation = await CreateOperation.parse(\n      anchoredOperationModel.operationBuffer\n    );\n\n    // Ensure actual delta hash matches expected delta hash.\n    const isMatchingDelta = Multihash.isValidHash(\n      operation.encodedDelta,\n      operation.suffixData.delta_hash\n    );\n    if (!isMatchingDelta) {\n      return didState;\n    }\n\n    // Apply the given patches against an empty object.\n    const delta = operation.delta;\n    let document = {};\n    try {\n      if (delta !== undefined) {\n        document = DocumentComposer.applyPatches(document, delta.patches);\n      }\n    } catch (error) {\n      const didUniqueSuffix = anchoredOperationModel.didUniqueSuffix;\n      const transactionNumber = anchoredOperationModel.transactionNumber;\n      console.debug(\n        `Unable to apply document patch in transaction number ${transactionNumber} for DID ${didUniqueSuffix}: ${SidetreeError.stringify(\n          error\n        )}.`\n      );\n\n      // Return the given DID state if error is encountered applying the patches.\n      return didState;\n    }\n\n    const newDidState = {\n      didUniqueSuffix: operation.didUniqueSuffix,\n      document,\n      nextRecoveryCommitmentHash: operation.suffixData.recovery_commitment,\n      nextUpdateCommitmentHash: delta ? delta.update_commitment : undefined,\n      lastOperationTransactionNumber: anchoredOperationModel.transactionNumber,\n    };\n\n    return newDidState;\n  }\n\n  /**\n   * @returns new DID state if operation is applied successfully; the given DID state otherwise.\n   */\n  private async applyUpdateOperation(\n    anchoredOperationModel: AnchoredOperationModel,\n    didState: DidState\n  ): Promise<DidState> {\n    const operation = await UpdateOperation.parse(\n      anchoredOperationModel.operationBuffer\n    );\n\n    // Verify the update key hash.\n    const isValidUpdateKey = Multihash.canonicalizeAndVerify(\n      operation.signedData.update_key,\n      didState.nextUpdateCommitmentHash!\n    );\n\n    if (!isValidUpdateKey) {\n      return didState;\n    }\n\n    // Verify the signature.\n    const signatureIsValid = await operation.signedDataJws.verifySignature(\n      operation.signedData.update_key\n    );\n\n    if (!signatureIsValid) {\n      return didState;\n    }\n\n    // Verify the delta hash against the expected delta hash.\n    const isValidDelta = Multihash.isValidHash(\n      operation.encodedDelta,\n      operation.signedData.delta_hash\n    );\n\n    if (!isValidDelta) {\n      return didState;\n    }\n\n    let resultingDocument;\n    try {\n      resultingDocument = await DocumentComposer.applyUpdateOperation(\n        operation,\n        didState.document\n      );\n    } catch (error) {\n      const didUniqueSuffix = anchoredOperationModel.didUniqueSuffix;\n      const transactionNumber = anchoredOperationModel.transactionNumber;\n      console.debug(\n        `Unable to apply document patch in transaction number ${transactionNumber} for DID ${didUniqueSuffix}: ${SidetreeError.stringify(\n          error\n        )}.`\n      );\n\n      // Return the given DID state if error is encountered applying the patches.\n      return didState;\n    }\n\n    const newDidState = {\n      nextRecoveryCommitmentHash: didState.nextRecoveryCommitmentHash,\n      // New values below.\n      document: resultingDocument,\n      nextUpdateCommitmentHash: operation.delta!.update_commitment,\n      lastOperationTransactionNumber: anchoredOperationModel.transactionNumber,\n    };\n\n    return newDidState;\n  }\n\n  /**\n   * @returns new DID state if operation is applied successfully; the given DID state otherwise.\n   */\n  private async applyRecoverOperation(\n    anchoredOperationModel: AnchoredOperationModel,\n    didState: DidState\n  ): Promise<DidState> {\n    const operation = await RecoverOperation.parse(\n      anchoredOperationModel.operationBuffer\n    );\n\n    // Verify the recovery key hash.\n    const isValidRecoveryKey = Multihash.canonicalizeAndVerify(\n      operation.signedData.recovery_key,\n      didState.nextRecoveryCommitmentHash!\n    );\n    if (!isValidRecoveryKey) {\n      return didState;\n    }\n\n    // Verify the signature.\n    const signatureIsValid = await operation.signedDataJws.verifySignature(\n      operation.signedData.recovery_key\n    );\n    if (!signatureIsValid) {\n      return didState;\n    }\n\n    // Verify the actual delta hash against the expected delta hash.\n    const isMatchingDelta = Multihash.isValidHash(\n      operation.encodedDelta,\n      operation.signedData.delta_hash\n    );\n    if (!isMatchingDelta) {\n      return didState;\n    }\n\n    // Apply the given patches against an empty object.\n    const delta = operation.delta;\n    let document = {};\n    try {\n      if (delta !== undefined) {\n        document = DocumentComposer.applyPatches(document, delta.patches);\n      }\n    } catch (error) {\n      const didUniqueSuffix = anchoredOperationModel.didUniqueSuffix;\n      const transactionNumber = anchoredOperationModel.transactionNumber;\n      console.debug(\n        `Unable to apply document patch in transaction number ${transactionNumber} for DID ${didUniqueSuffix}: ${SidetreeError.stringify(\n          error\n        )}.`\n      );\n\n      // Return the given DID state if error is encountered applying the patches.\n      return didState;\n    }\n\n    const newDidState = {\n      didUniqueSuffix: operation.didUniqueSuffix,\n      document,\n      recovery_key: operation.signedData.recovery_key,\n      nextRecoveryCommitmentHash: operation.signedData.recovery_commitment,\n      nextUpdateCommitmentHash: delta ? delta.update_commitment : undefined,\n      lastOperationTransactionNumber: anchoredOperationModel.transactionNumber,\n    };\n\n    return newDidState;\n  }\n\n  /**\n   * @returns new DID state if operation is applied successfully; the given DID state otherwise.\n   */\n  private async applyDeactivateOperation(\n    anchoredOperationModel: AnchoredOperationModel,\n    didState: DidState\n  ): Promise<DidState> {\n    const operation = await DeactivateOperation.parse(\n      anchoredOperationModel.operationBuffer\n    );\n\n    // Verify the recovery key hash.\n    const isValidRecoveryKey = Multihash.canonicalizeAndVerify(\n      operation.signedData.recovery_key,\n      didState.nextRecoveryCommitmentHash!\n    );\n    if (!isValidRecoveryKey) {\n      return didState;\n    }\n\n    // Verify the signature.\n    const signatureIsValid = await operation.signedDataJws.verifySignature(\n      operation.signedData.recovery_key\n    );\n    if (!signatureIsValid) {\n      return didState;\n    }\n\n    // The operation passes all checks.\n    const newDidState = {\n      document: didState.document,\n      // New values below.\n      recovery_key: undefined,\n      nextRecoveryCommitmentHash: undefined,\n      nextUpdateCommitmentHash: undefined,\n      lastOperationTransactionNumber: anchoredOperationModel.transactionNumber,\n    };\n    return newDidState;\n  }\n}\n"],"names":["OperationProcessor","apply","anchoredOperationModel","didState","appliedDidState","undefined","lastOperationTransactionNumber","previousOperationTransactionNumber","index","operationIndex","time","transactionTime","number","transactionNumber","didUniqueSuffix","console","debug","error","log","type","OperationType","Create","applyCreateOperation","Update","applyUpdateOperation","Recover","applyRecoverOperation","Deactivate","applyDeactivateOperation","SidetreeError","ErrorCode","OperationProcessorUnknownOperationType","getRevealValue","OperationProcessorCreateOperationDoesNotHaveRevealValue","Operation","parse","operationBuffer","operation","revealValueBuffer","recoverOperation","JsonCanonicalizer","canonicalizeAsBuffer","signedData","recovery_key","updateOperation","update_key","deactivateOperation","CreateOperation","isMatchingDelta","Multihash","isValidHash","encodedDelta","suffixData","delta_hash","delta","document","DocumentComposer","applyPatches","patches","stringify","newDidState","nextRecoveryCommitmentHash","recovery_commitment","nextUpdateCommitmentHash","update_commitment","UpdateOperation","isValidUpdateKey","canonicalizeAndVerify","signedDataJws","verifySignature","signatureIsValid","resultingDocument","isValidDelta","RecoverOperation","isValidRecoveryKey","DeactivateOperation"],"mappings":"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"}