{"version":3,"file":"RequestHandler-5cc027b8.js","sources":["../src/Did.ts","../src/RequestHandler.ts"],"sourcesContent":["/*\n * The code in this file originated from\n * @see https://github.com/decentralized-identity/sidetree\n * For the list of changes that was made to the original code\n * @see https://github.com/transmute-industries/sidetree.js/blob/master/reference-implementation-changes.md\n *\n * Copyright 2020 - Transmute Industries Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  ErrorCode,\n  Multihash,\n  OperationType,\n  SidetreeError,\n} from '@sidetree/common';\nimport CreateOperation from './CreateOperation';\nimport { URL } from 'url';\n\n/**\n * Class containing reusable Sidetree DID related operations.\n */\nexport default class Did {\n  private static readonly initialStateParameterSuffix = 'initial-state';\n\n  /** `true` if DID is short form; `false` if DID is long-form. */\n  public isShortForm: boolean;\n  /** DID method name. */\n  public didMethodName: string;\n  /** DID unique suffix. */\n  public uniqueSuffix: string;\n  /** The create operation if the DID given is long-form, `undefined` otherwise. */\n  public createOperation?: CreateOperation;\n  /** The short form. */\n  public shortForm: string;\n\n  /**\n   * Parses the input string as Sidetree DID.\n   * NOTE: Must not call this constructor directly, use the factory `create` method instead.\n   * @param did Short or long-form DID string.\n   * @param didMethodName The expected DID method given in the DID string. The method throws SidetreeError if mismatch.\n   */\n  private constructor(did: string, didMethodName: string) {\n    this.didMethodName = didMethodName;\n    const didPrefix = `did:${didMethodName}:`;\n\n    if (!did.startsWith(didPrefix)) {\n      throw new SidetreeError(ErrorCode.DidIncorrectPrefix);\n    }\n\n    const indexOfQuestionMarkChar = did.indexOf('?');\n    // If there is no question mark, then DID can only be in short-form.\n    if (indexOfQuestionMarkChar < 0) {\n      this.isShortForm = true;\n    } else {\n      this.isShortForm = false;\n    }\n\n    if (this.isShortForm) {\n      this.uniqueSuffix = did.substring(didPrefix.length);\n    } else {\n      // This is long-form.\n      this.uniqueSuffix = did.substring(\n        didPrefix.length,\n        indexOfQuestionMarkChar\n      );\n    }\n\n    if (this.uniqueSuffix.length === 0) {\n      throw new SidetreeError(ErrorCode.DidNoUniqueSuffix);\n    }\n\n    this.shortForm = didPrefix + this.uniqueSuffix;\n  }\n\n  /**\n   * Parses the input string as Sidetree DID.\n   * @param didString Short or long-form DID string.\n   */\n  public static async create(\n    didString: string,\n    didMethodName: string\n  ): Promise<Did> {\n    const did = new Did(didString, didMethodName);\n\n    // If DID is long-form, ensure the unique suffix constructed from the suffix data matches the short-form DID and populate the `createOperation` property.\n    if (!did.isShortForm) {\n      const initialState = Did.getInitialStateFromDidString(\n        didString,\n        didMethodName\n      );\n      const createOperation = await Did.constructCreateOperationFromInitialState(\n        initialState\n      );\n\n      // NOTE: we cannot use the unique suffix directly from `createOperation.didUniqueSuffix` for comparison,\n      // becasue a given long-form DID may have been created long ago,\n      // thus this version of `CreateOperation.parse()` maybe using a different hashing algorithm than that of the unique DID suffix (short-form).\n      // So we compute the suffix data hash again using the hashing algorithm used by the given unique DID suffix (short-form).\n      const suffixDataHashMatchesUniqueSuffix = Multihash.isValidHash(\n        createOperation.encodedSuffixData,\n        did.uniqueSuffix\n      );\n\n      // If the computed suffix data hash is not the same as the unique suffix given in the DID string, the DID is not valid.\n      if (!suffixDataHashMatchesUniqueSuffix) {\n        throw new SidetreeError(\n          ErrorCode.DidUniqueSuffixFromInitialStateMismatch\n        );\n      }\n\n      did.createOperation = createOperation;\n    }\n\n    return did;\n  }\n\n  private static getInitialStateFromDidString(\n    didString: string,\n    methodNameWithNetworkId: string\n  ): string {\n    let didStringUrl = undefined;\n    try {\n      didStringUrl = new URL(didString);\n    } catch {\n      throw new SidetreeError(ErrorCode.DidInvalidDidString);\n    }\n\n    // TODO: #470 - Support/disambiguate \"network ID\" in method name.\n\n    // Stripping away the potential network ID portion. e.g. 'sidetree:test' -> 'sidetree'\n    const methodName = methodNameWithNetworkId.split(':')[0];\n\n    let queryParamCounter = 0;\n    let initialStateValue;\n\n    // Verify that `-<method-name>-initial-state` is the one and only parameter.\n    for (const [key, value] of didStringUrl.searchParams) {\n      queryParamCounter += 1;\n      if (queryParamCounter > 1) {\n        throw new SidetreeError(ErrorCode.DidLongFormOnlyOneQueryParamAllowed);\n      }\n\n      // expect key to be -<method-name>-initial-state\n      const expectedKey = `-${methodName}-${Did.initialStateParameterSuffix}`;\n      if (key !== expectedKey) {\n        throw new SidetreeError(\n          ErrorCode.DidLongFormOnlyInitialStateParameterIsAllowed\n        );\n      }\n\n      initialStateValue = value;\n    }\n\n    if (initialStateValue === undefined) {\n      throw new SidetreeError(ErrorCode.DidLongFormNoInitialStateFound);\n    }\n\n    return initialStateValue;\n  }\n\n  private static async constructCreateOperationFromInitialState(\n    initialState: string\n  ): Promise<CreateOperation> {\n    // Initial state should be in the format: <suffix-data>.<delta>\n    const firstIndexOfDot = initialState.indexOf('.');\n    if (firstIndexOfDot === -1) {\n      throw new SidetreeError(ErrorCode.DidInitialStateValueContainsNoDot);\n    }\n\n    const lastIndexOfDot = initialState.lastIndexOf('.');\n    if (lastIndexOfDot !== firstIndexOfDot) {\n      throw new SidetreeError(\n        ErrorCode.DidInitialStateValueContainsMoreThanOneDot\n      );\n    }\n\n    if (firstIndexOfDot === initialState.length - 1 || firstIndexOfDot === 0) {\n      throw new SidetreeError(\n        ErrorCode.DidInitialStateValueDoesNotContainTwoParts\n      );\n    }\n\n    const initialStateParts = initialState.split('.');\n    const suffixData = initialStateParts[0];\n    const delta = initialStateParts[1];\n    const createOperationRequest = {\n      type: OperationType.Create,\n      suffix_data: suffixData,\n      delta,\n    };\n    const createOperationBuffer = Buffer.from(\n      JSON.stringify(createOperationRequest)\n    );\n    const createOperation = await CreateOperation.parseObject(\n      createOperationRequest,\n      createOperationBuffer,\n      false\n    );\n\n    return createOperation;\n  }\n}\n","/*\n * The code in this file originated from\n * @see https://github.com/decentralized-identity/sidetree\n * For the list of changes that was made to the original code\n * @see https://github.com/transmute-industries/sidetree.js/blob/master/reference-implementation-changes.md\n *\n * Copyright 2020 - Transmute Industries Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  DidState,\n  ErrorCode,\n  IOperationQueue,\n  IRequestHandler,\n  OperationModel,\n  OperationType,\n  protocolParameters,\n  ResponseModel,\n  ResponseStatus,\n  SidetreeError,\n} from '@sidetree/common';\nimport Did from './Did';\nimport DocumentComposer from './DocumentComposer';\nimport JsonAsync from './util/JsonAsync';\nimport Operation from './Operation';\nimport OperationProcessor from './OperationProcessor';\nimport Resolver from './Resolver';\n\n/**\n * Sidetree operation request handler.\n */\nexport default class RequestHandler implements IRequestHandler {\n  private operationProcessor: OperationProcessor;\n\n  public constructor(\n    private resolver: Resolver,\n    private operationQueue: IOperationQueue,\n    private didMethodName: string\n  ) {\n    this.operationProcessor = new OperationProcessor();\n  }\n\n  /**\n   * Handles an operation request.\n   */\n  public async handleOperationRequest(request: Buffer): Promise<ResponseModel> {\n    console.info(\n      `Handling operation request of size ${request.length} bytes...`\n    );\n\n    // Perform common validation for any write request and parse it into an `OperationModel`.\n    let operationModel: OperationModel;\n    try {\n      const operationRequest = await JsonAsync.parse(request);\n\n      // Check `delta` property data size if they exist in the operation.\n      if (\n        operationRequest.type === OperationType.Create ||\n        operationRequest.type === OperationType.Recover ||\n        operationRequest.type === OperationType.Update\n      ) {\n        const deltaBuffer = Buffer.from(operationRequest.delta);\n        if (deltaBuffer.length > protocolParameters.maxDeltaSizeInBytes) {\n          const errorMessage = `operationDdata byte size of ${deltaBuffer.length} exceeded limit of ${protocolParameters.maxDeltaSizeInBytes}`;\n          console.info(errorMessage);\n          throw new SidetreeError(\n            ErrorCode.RequestHandlerDeltaExceedsMaximumSize,\n            errorMessage\n          );\n        }\n      }\n\n      operationModel = await Operation.parse(request);\n\n      // Reject operation if there is already an operation for the same DID waiting to be batched and anchored.\n      if (await this.operationQueue.contains(operationModel.didUniqueSuffix)) {\n        const errorMessage = `An operation request already exists in queue for DID '${operationModel.didUniqueSuffix}', only one is allowed at a time.`;\n        throw new SidetreeError(\n          ErrorCode.QueueingMultipleOperationsPerDidNotAllowed,\n          errorMessage\n        );\n      }\n    } catch (error) {\n      // Give meaningful/specific error code and message when possible.\n      if (error instanceof SidetreeError) {\n        console.info(`Bad request: ${error.code}`);\n        console.info(`Error message: ${error.message}`);\n        return {\n          status: ResponseStatus.BadRequest,\n          body: { code: error.code, message: error.message },\n        };\n      }\n\n      // Else we give a generic bad request response.\n      console.info(`Bad request: ${error}`);\n      return {\n        status: ResponseStatus.BadRequest,\n      };\n    }\n\n    try {\n      console.info(\n        `Operation type: '${operationModel.type}', DID unique suffix: '${operationModel.didUniqueSuffix}'`\n      );\n\n      // Passed common operation validation, hand off to specific operation handler.\n      let response: ResponseModel;\n      switch (operationModel.type) {\n        case OperationType.Create:\n          response = await this.handleCreateRequest(operationModel);\n          break;\n        // these cases do nothing because we do not know the latest document state unless we resolve.\n        case OperationType.Update:\n        case OperationType.Recover:\n        case OperationType.Deactivate:\n          response = {\n            status: ResponseStatus.Succeeded,\n          };\n          break;\n        default:\n          // Should be an impossible condition, but we defensively check and handle.\n          response = {\n            status: ResponseStatus.BadRequest,\n            body: {\n              code: ErrorCode.RequestHandlerUnknownOperationType,\n              message: `Unsupported operation type '${operationModel.type}'.`,\n            },\n          };\n      }\n\n      // if the operation was processed successfully, queue the original request buffer for batching.\n      if (response.status === ResponseStatus.Succeeded) {\n        await this.operationQueue.enqueue(\n          operationModel.didUniqueSuffix,\n          operationModel.operationBuffer\n        );\n      }\n\n      return response;\n    } catch (error) {\n      // Give meaningful/specific error code and message when possible.\n      if (error instanceof SidetreeError) {\n        console.info(`Sidetree error: ${error.code} ${error.message}`);\n        return {\n          status: ResponseStatus.BadRequest,\n          body: { code: error.code, message: error.message },\n        };\n      }\n\n      console.info(`Unexpected error: ${error}`);\n      return {\n        status: ResponseStatus.ServerError,\n      };\n    }\n  }\n\n  private async handleCreateRequest(\n    operationModel: OperationModel\n  ): Promise<ResponseModel> {\n    const didState = await this.applyCreateOperation(operationModel);\n\n    // Should be an impossible condition, but we defensively check and handle.\n    if (didState === undefined) {\n      return {\n        status: ResponseStatus.BadRequest,\n        body: 'Invalid create operation.',\n      };\n    }\n\n    const did = `did:${this.didMethodName}:${operationModel.didUniqueSuffix}`;\n    const document = DocumentComposer.transformToExternalDocument(\n      didState,\n      did\n    );\n\n    return {\n      status: ResponseStatus.Succeeded,\n      body: document,\n    };\n  }\n\n  /**\n   * Handles resolve operation.\n   * @param shortOrLongFormDid Can either be:\n   *   1. A short-form DID. e.g. 'did:<methodName>:abc' or\n   *   2. A long-form DID. e.g. 'did:<methodName>:<unique-portion>?-<methodName>-initial-state=<encoded-original-did-document>'.\n   */\n  public async handleResolveRequest(\n    shortOrLongFormDid: string\n  ): Promise<ResponseModel> {\n    try {\n      console.info(`Handling resolution request for: ${shortOrLongFormDid}...`);\n\n      const did = await Did.create(shortOrLongFormDid, this.didMethodName);\n\n      let didState: DidState | undefined;\n      if (did.isShortForm) {\n        didState = await this.resolver.resolve(did.uniqueSuffix);\n      } else {\n        didState = await this.resolveLongFormDid(did);\n      }\n\n      if (didState === undefined) {\n        return {\n          status: ResponseStatus.NotFound,\n        };\n      }\n\n      const document = DocumentComposer.transformToExternalDocument(\n        didState,\n        shortOrLongFormDid\n      );\n\n      return {\n        status: ResponseStatus.Succeeded,\n        body: document,\n      };\n    } catch (error) {\n      // Give meaningful/specific error code and message when possible.\n      if (error instanceof SidetreeError) {\n        return {\n          status: ResponseStatus.BadRequest,\n          body: { code: error.code, message: error.message },\n        };\n      }\n\n      console.info(`Unexpected error: ${error}`);\n      return {\n        status: ResponseStatus.ServerError,\n      };\n    }\n  }\n\n  /**\n   * Resolves the given long-form DID by resolving using operations found over the network first;\n   * if no operations found, the given create operation will is used to construct the DID state.\n   */\n  private async resolveLongFormDid(did: Did): Promise<DidState | undefined> {\n    // Attempt to resolve the DID by using operations found from the network first.\n    let didState = await this.resolver.resolve(did.uniqueSuffix);\n\n    // If DID state found then return it.\n    if (didState !== undefined) {\n      return didState;\n    }\n\n    // The code reaches here if this DID is not registered on the ledger.\n\n    didState = await this.applyCreateOperation(did.createOperation!);\n\n    return didState;\n  }\n\n  private async applyCreateOperation(\n    createOperation: OperationModel\n  ): Promise<DidState | undefined> {\n    const operationWithMockedAnchorTime = {\n      didUniqueSuffix: createOperation.didUniqueSuffix,\n      type: OperationType.Create,\n      transactionTime: 0,\n      transactionNumber: 0,\n      operationIndex: 0,\n      operationBuffer: createOperation.operationBuffer,\n    }; // NOTE: The transaction timing does not matter here, we are just computing a \"theoretical\" document if it were anchored on blockchain.\n\n    const newDidState = await this.operationProcessor.apply(\n      operationWithMockedAnchorTime,\n      undefined\n    );\n    return newDidState;\n  }\n}\n"],"names":["Did","did","didMethodName","didPrefix","startsWith","SidetreeError","ErrorCode","DidIncorrectPrefix","indexOfQuestionMarkChar","indexOf","isShortForm","uniqueSuffix","this","substring","length","DidNoUniqueSuffix","shortForm","create","didString","initialState","getInitialStateFromDidString","constructCreateOperationFromInitialState","createOperation","Multihash","isValidHash","encodedSuffixData","DidUniqueSuffixFromInitialStateMismatch","methodNameWithNetworkId","didStringUrl","undefined","URL","DidInvalidDidString","initialStateValue","methodName","split","queryParamCounter","searchParams","key","value","DidLongFormOnlyOneQueryParamAllowed","initialStateParameterSuffix","DidLongFormOnlyInitialStateParameterIsAllowed","DidLongFormNoInitialStateFound","firstIndexOfDot","DidInitialStateValueContainsNoDot","lastIndexOf","DidInitialStateValueContainsMoreThanOneDot","DidInitialStateValueDoesNotContainTwoParts","initialStateParts","createOperationRequest","type","OperationType","Create","suffix_data","delta","createOperationBuffer","Buffer","from","JSON","stringify","CreateOperation","parseObject","resolver","operationQueue","operationProcessor","OperationProcessor","handleOperationRequest","request","operationModel","response","status","ResponseStatus","Succeeded","_this2","enqueue","didUniqueSuffix","operationBuffer","console","info","handleCreateRequest","Update","Recover","Deactivate","BadRequest","body","code","RequestHandlerUnknownOperationType","message","error","ServerError","JsonAsync","parse","operationRequest","deltaBuffer","protocolParameters","maxDeltaSizeInBytes","errorMessage","RequestHandlerDeltaExceedsMaximumSize","Operation","contains","QueueingMultipleOperationsPerDidNotAllowed","_this4","applyCreateOperation","didState","document","DocumentComposer","transformToExternalDocument","handleResolveRequest","shortOrLongFormDid","_this6","NotFound","resolve","resolveLongFormDid","_this8","apply","transactionTime","transactionNumber","operationIndex"],"mappings":"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"}