import { d as Operation, a as CreateOperation, l as DocumentComposer, U as UpdateOperation, _ as _catch, R as RecoverOperation, D as DeactivateOperation } from './index-f6e63a58.js';
import { OperationType, SidetreeError, ErrorCode, JsonCanonicalizer, Multihash } from '@sidetree/common';
import 'fast-json-patch';
import 'jose';
import 'bip39';
import '@transmute/did-key-ed25519';
import 'hdkey';
import '@trust/keyto';
import '@transmute/did-key-secp256k1';
import 'time-span';
import 'crypto';

/**
 * Implementation of IOperationProcessor.
 */

var OperationProcessor = /*#__PURE__*/function () {
  function OperationProcessor() {}

  var _proto = OperationProcessor.prototype;

  _proto.apply = function apply(anchoredOperationModel, didState) {
    try {
      var _temp3 = function _temp3(_result) {
        if (_exit2) return _result;

        try {
          // If the operation was not applied, log some info in case needed for debugging.
          if (appliedDidState === undefined || appliedDidState.lastOperationTransactionNumber === previousOperationTransactionNumber) {
            var index = anchoredOperationModel.operationIndex;
            var time = anchoredOperationModel.transactionTime;
            var number = anchoredOperationModel.transactionNumber;
            var didUniqueSuffix = anchoredOperationModel.didUniqueSuffix;
            console.debug("Ignored invalid operation for DID '" + didUniqueSuffix + "' in transaction '" + number + "' at time '" + time + "' at operation index " + index + ".");
          }
        } catch (error) {
          console.log("Failed logging " + error + "."); // If logging fails, just move on.
        }

        return appliedDidState;
      };

      var _exit2 = false;

      var _this2 = this;

      // If DID state is undefined, then the operation given must be a create operation, otherwise the operation cannot be applied.
      if (didState === undefined && anchoredOperationModel.type !== OperationType.Create) {
        return Promise.resolve(undefined);
      }

      var previousOperationTransactionNumber = didState ? didState.lastOperationTransactionNumber : undefined;
      var appliedDidState;

      var _temp4 = function () {
        if (anchoredOperationModel.type === OperationType.Create) {
          return Promise.resolve(_this2.applyCreateOperation(anchoredOperationModel, didState)).then(function (_this$applyCreateOper) {
            appliedDidState = _this$applyCreateOper;
          });
        } else return function () {
          if (anchoredOperationModel.type === OperationType.Update) {
            return Promise.resolve(_this2.applyUpdateOperation(anchoredOperationModel, didState)).then(function (_this$applyUpdateOper) {
              appliedDidState = _this$applyUpdateOper;
            });
          } else return function () {
            if (anchoredOperationModel.type === OperationType.Recover) {
              return Promise.resolve(_this2.applyRecoverOperation(anchoredOperationModel, didState)).then(function (_this$applyRecoverOpe) {
                appliedDidState = _this$applyRecoverOpe;
              });
            } else return function () {
              if (anchoredOperationModel.type === OperationType.Deactivate) {
                return Promise.resolve(_this2.applyDeactivateOperation(anchoredOperationModel, didState)).then(function (_this$applyDeactivate) {
                  appliedDidState = _this$applyDeactivate;
                });
              } else {
                throw new SidetreeError(ErrorCode.OperationProcessorUnknownOperationType);
              }
            }();
          }();
        }();
      }();

      return Promise.resolve(_temp4 && _temp4.then ? _temp4.then(_temp3) : _temp3(_temp4));
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.getRevealValue = function getRevealValue(anchoredOperationModel) {
    try {
      if (anchoredOperationModel.type === OperationType.Create) {
        throw new SidetreeError(ErrorCode.OperationProcessorCreateOperationDoesNotHaveRevealValue);
      }

      return Promise.resolve(Operation.parse(anchoredOperationModel.operationBuffer)).then(function (operation) {
        var revealValueBuffer;

        switch (operation.type) {
          case OperationType.Recover:
            var recoverOperation = operation;
            revealValueBuffer = JsonCanonicalizer.canonicalizeAsBuffer(recoverOperation.signedData.recovery_key);
            return revealValueBuffer;

          case OperationType.Update:
            var updateOperation = operation;
            revealValueBuffer = JsonCanonicalizer.canonicalizeAsBuffer(updateOperation.signedData.update_key);
            return revealValueBuffer;

          default:
            // This is a deactivate.
            var deactivateOperation = operation;
            revealValueBuffer = JsonCanonicalizer.canonicalizeAsBuffer(deactivateOperation.signedData.recovery_key);
            return revealValueBuffer;
        }
      });
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * @returns new DID state if operation is applied successfully; the given DID state otherwise.
   */
  ;

  _proto.applyCreateOperation = function applyCreateOperation(anchoredOperationModel, didState) {
    try {
      // If DID state is already created by a previous create operation, then we cannot apply a create operation again.
      if (didState !== undefined) {
        return Promise.resolve(didState);
      }

      return Promise.resolve(CreateOperation.parse(anchoredOperationModel.operationBuffer)).then(function (operation) {
        // Ensure actual delta hash matches expected delta hash.
        var isMatchingDelta = Multihash.isValidHash(operation.encodedDelta, operation.suffixData.delta_hash);

        if (!isMatchingDelta) {
          return didState;
        } // Apply the given patches against an empty object.


        var delta = operation.delta;
        var document = {};

        try {
          if (delta !== undefined) {
            document = DocumentComposer.applyPatches(document, delta.patches);
          }
        } catch (error) {
          var didUniqueSuffix = anchoredOperationModel.didUniqueSuffix;
          var transactionNumber = anchoredOperationModel.transactionNumber;
          console.debug("Unable to apply document patch in transaction number " + transactionNumber + " for DID " + didUniqueSuffix + ": " + SidetreeError.stringify(error) + "."); // Return the given DID state if error is encountered applying the patches.

          return didState;
        }

        var newDidState = {
          didUniqueSuffix: operation.didUniqueSuffix,
          document: document,
          nextRecoveryCommitmentHash: operation.suffixData.recovery_commitment,
          nextUpdateCommitmentHash: delta ? delta.update_commitment : undefined,
          lastOperationTransactionNumber: anchoredOperationModel.transactionNumber
        };
        return newDidState;
      });
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * @returns new DID state if operation is applied successfully; the given DID state otherwise.
   */
  ;

  _proto.applyUpdateOperation = function applyUpdateOperation(anchoredOperationModel, didState) {
    try {
      return Promise.resolve(UpdateOperation.parse(anchoredOperationModel.operationBuffer)).then(function (operation) {
        // Verify the update key hash.
        var isValidUpdateKey = Multihash.canonicalizeAndVerify(operation.signedData.update_key, didState.nextUpdateCommitmentHash);
        return isValidUpdateKey ? Promise.resolve(operation.signedDataJws.verifySignature(operation.signedData.update_key)).then(function (signatureIsValid) {
          var _exit3 = false;

          function _temp6(_result5) {
            if (_exit3) return _result5;
            var newDidState = {
              nextRecoveryCommitmentHash: didState.nextRecoveryCommitmentHash,
              // New values below.
              document: resultingDocument,
              nextUpdateCommitmentHash: operation.delta.update_commitment,
              lastOperationTransactionNumber: anchoredOperationModel.transactionNumber
            };
            return newDidState;
          }

          if (!signatureIsValid) {
            return didState;
          } // Verify the delta hash against the expected delta hash.


          var isValidDelta = Multihash.isValidHash(operation.encodedDelta, operation.signedData.delta_hash);

          if (!isValidDelta) {
            return didState;
          }

          var resultingDocument;

          var _temp5 = _catch(function () {
            return Promise.resolve(DocumentComposer.applyUpdateOperation(operation, didState.document)).then(function (_DocumentComposer$app) {
              resultingDocument = _DocumentComposer$app;
            });
          }, function (error) {
            var didUniqueSuffix = anchoredOperationModel.didUniqueSuffix;
            var transactionNumber = anchoredOperationModel.transactionNumber;
            console.debug("Unable to apply document patch in transaction number " + transactionNumber + " for DID " + didUniqueSuffix + ": " + SidetreeError.stringify(error) + "."); // Return the given DID state if error is encountered applying the patches.

            _exit3 = true;
            return didState;
          });

          return _temp5 && _temp5.then ? _temp5.then(_temp6) : _temp6(_temp5);
        }) : didState;
      });
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * @returns new DID state if operation is applied successfully; the given DID state otherwise.
   */
  ;

  _proto.applyRecoverOperation = function applyRecoverOperation(anchoredOperationModel, didState) {
    try {
      return Promise.resolve(RecoverOperation.parse(anchoredOperationModel.operationBuffer)).then(function (operation) {
        // Verify the recovery key hash.
        var isValidRecoveryKey = Multihash.canonicalizeAndVerify(operation.signedData.recovery_key, didState.nextRecoveryCommitmentHash);
        return isValidRecoveryKey ? Promise.resolve(operation.signedDataJws.verifySignature(operation.signedData.recovery_key)).then(function (signatureIsValid) {
          if (!signatureIsValid) {
            return didState;
          } // Verify the actual delta hash against the expected delta hash.


          var isMatchingDelta = Multihash.isValidHash(operation.encodedDelta, operation.signedData.delta_hash);

          if (!isMatchingDelta) {
            return didState;
          } // Apply the given patches against an empty object.


          var delta = operation.delta;
          var document = {};

          try {
            if (delta !== undefined) {
              document = DocumentComposer.applyPatches(document, delta.patches);
            }
          } catch (error) {
            var didUniqueSuffix = anchoredOperationModel.didUniqueSuffix;
            var transactionNumber = anchoredOperationModel.transactionNumber;
            console.debug("Unable to apply document patch in transaction number " + transactionNumber + " for DID " + didUniqueSuffix + ": " + SidetreeError.stringify(error) + "."); // Return the given DID state if error is encountered applying the patches.

            return didState;
          }

          var newDidState = {
            didUniqueSuffix: operation.didUniqueSuffix,
            document: document,
            recovery_key: operation.signedData.recovery_key,
            nextRecoveryCommitmentHash: operation.signedData.recovery_commitment,
            nextUpdateCommitmentHash: delta ? delta.update_commitment : undefined,
            lastOperationTransactionNumber: anchoredOperationModel.transactionNumber
          };
          return newDidState;
        }) : didState;
      });
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * @returns new DID state if operation is applied successfully; the given DID state otherwise.
   */
  ;

  _proto.applyDeactivateOperation = function applyDeactivateOperation(anchoredOperationModel, didState) {
    try {
      return Promise.resolve(DeactivateOperation.parse(anchoredOperationModel.operationBuffer)).then(function (operation) {
        // Verify the recovery key hash.
        var isValidRecoveryKey = Multihash.canonicalizeAndVerify(operation.signedData.recovery_key, didState.nextRecoveryCommitmentHash);
        return isValidRecoveryKey ? Promise.resolve(operation.signedDataJws.verifySignature(operation.signedData.recovery_key)).then(function (signatureIsValid) {
          if (!signatureIsValid) {
            return didState;
          } // The operation passes all checks.


          var newDidState = {
            document: didState.document,
            // New values below.
            recovery_key: undefined,
            nextRecoveryCommitmentHash: undefined,
            nextUpdateCommitmentHash: undefined,
            lastOperationTransactionNumber: anchoredOperationModel.transactionNumber
          };
          return newDidState;
        }) : didState;
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  return OperationProcessor;
}();

export default OperationProcessor;
//# sourceMappingURL=OperationProcessor-691a8d37.js.map
