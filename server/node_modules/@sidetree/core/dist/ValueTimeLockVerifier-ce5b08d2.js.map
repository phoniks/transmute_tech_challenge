{"version":3,"file":"ValueTimeLockVerifier-ce5b08d2.js","sources":["../src/FeeManager.ts","../src/ValueTimeLockVerifier.ts"],"sourcesContent":["/*\n * The code in this file originated from\n * @see https://github.com/decentralized-identity/sidetree\n * For the list of changes that was made to the original code\n * @see https://github.com/transmute-industries/sidetree.js/blob/master/reference-implementation-changes.md\n *\n * Copyright 2020 - Transmute Industries Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ErrorCode, protocolParameters, SidetreeError } from '@sidetree/common';\n\n/**\n * Encapsulates the functionality to calculate and verify the blockchain transaction fees.\n */\nexport default class FeeManager {\n  /**\n   * Converts the normalized fee (returned by the blockchain) into the transaction fee to be paid when writing\n   * the current transaction.\n   *\n   * @param normalizedFee The normalized fee for the current transaction.\n   * @param numberOfOperations The number of operations to write.\n   * @param feeMarkupFactor Markup to be added to the calculated fee.\n   *\n   * @throws if the number of operations are <= 0.\n   */\n  public static computeMinimumTransactionFee(\n    normalizedFee: number,\n    numberOfOperations: number\n  ): number {\n    if (numberOfOperations <= 0) {\n      throw new SidetreeError(\n        ErrorCode.OperationCountLessThanZero,\n        `Fee cannot be calculated for the given number of operations: ${numberOfOperations}`\n      );\n    }\n\n    const feePerOperation =\n      normalizedFee *\n      protocolParameters.normalizedFeeToPerOperationFeeMultiplier;\n    const feeForAllOperations = feePerOperation * numberOfOperations;\n\n    // If our calculated-fee is lower than the normalized fee (which can happen if the number of operations is\n    // very low) then the calculated-fee will be ignored by the blockchain miners ... so make sure that we\n    // return at-least the normalized fee.\n    const transactionFee = Math.max(feeForAllOperations, normalizedFee);\n\n    return transactionFee;\n  }\n\n  /**\n   * Verifies that the fee paid for the given transaction is valid; throws if it is not valid.\n   *\n   * @param transactionFeePaid The actual fee paid for that transaction.\n   * @param numberOfOperations The number of operations written.\n   * @param normalizedFee The normalized fee for that transaction.\n   *\n   * @throws if the number of operations is <= 0; if the feepaid is invalid.\n   */\n  public static verifyTransactionFeeAndThrowOnError(\n    transactionFeePaid: number,\n    numberOfOperations: number,\n    normalizedFee: number\n  ): void {\n    // If there are no operations written then someone wrote incorrect data and we are going to throw\n    if (numberOfOperations <= 0) {\n      throw new SidetreeError(\n        ErrorCode.OperationCountLessThanZero,\n        `The number of operations: ${numberOfOperations} must be greater than 0`\n      );\n    }\n\n    if (transactionFeePaid < normalizedFee) {\n      throw new SidetreeError(\n        ErrorCode.TransactionFeePaidLessThanNormalizedFee,\n        `The actual fee paid: ${transactionFeePaid} should be greater than or equal to the normalized fee: ${normalizedFee}`\n      );\n    }\n\n    const actualFeePerOperation = transactionFeePaid / numberOfOperations;\n    const expectedFeePerOperation =\n      normalizedFee *\n      protocolParameters.normalizedFeeToPerOperationFeeMultiplier;\n\n    if (actualFeePerOperation < expectedFeePerOperation) {\n      throw new SidetreeError(\n        ErrorCode.TransactionFeePaidInvalid,\n        `The actual fee paid: ${transactionFeePaid} per number of operations: ${numberOfOperations} should be at least ${expectedFeePerOperation}.`\n      );\n    }\n  }\n}\n","/*\n * The code in this file originated from\n * @see https://github.com/decentralized-identity/sidetree\n * For the list of changes that was made to the original code\n * @see https://github.com/transmute-industries/sidetree.js/blob/master/reference-implementation-changes.md\n *\n * Copyright 2020 - Transmute Industries Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  ErrorCode,\n  IVersionMetadataFetcher,\n  protocolParameters,\n  SidetreeError,\n  ValueTimeLockModel,\n} from '@sidetree/common';\n\n/**\n * Encapsulates the functionality to compute and verify the value time lock amounts.\n */\nexport default class ValueTimeLockVerifier {\n  /**\n   * Calculates the maximum number of operations allowed to be written for the given lock information. If\n   * there is no lock then it returns the number of operations which do not require a lock.\n   *\n   * @param valueTimeLock The lock object if exists\n   * @param versionMetadataFetcher The mapper from transaction time to version metadata\n   */\n  public static calculateMaxNumberOfOperationsAllowed(\n    valueTimeLock: ValueTimeLockModel | undefined,\n    versionMetadataFetcher: IVersionMetadataFetcher\n  ) {\n    if (valueTimeLock === undefined) {\n      return protocolParameters.maxNumberOfOperationsForNoValueTimeLock;\n    }\n\n    const versionMetadata = versionMetadataFetcher.getVersionMetadata(\n      valueTimeLock.lockTransactionTime\n    );\n    const normalizedFeeToPerOperationFeeMultiplier =\n      versionMetadata.normalizedFeeToPerOperationFeeMultiplier;\n    const valueTimeLockAmountMultiplier =\n      versionMetadata.valueTimeLockAmountMultiplier;\n\n    // Using the following formula:\n    //  requiredLockAmount = normalizedfee * normalizedFeeMultipier * numberOfOps * valueTimeLockMultiplier\n    //\n    // We are going to find the numberOfOps given the requiredLockAmount\n    const feePerOperation =\n      valueTimeLock.normalizedFee * normalizedFeeToPerOperationFeeMultiplier;\n    const numberOfOpsAllowed =\n      valueTimeLock.amountLocked /\n      (feePerOperation * valueTimeLockAmountMultiplier);\n\n    // Make sure that we are returning an integer; rounding down to make sure that we are not going above\n    // the max limit.\n    const numberOfOpsAllowedInt = Math.floor(numberOfOpsAllowed);\n\n    // Return at least the 'free' operations\n    return Math.max(\n      numberOfOpsAllowedInt,\n      protocolParameters.maxNumberOfOperationsForNoValueTimeLock\n    );\n  }\n\n  /**\n   * Verifies that the value lock object (amount, transaction time range) is correct for the specified number\n   * of operations.\n   *\n   * @param valueTimeLock The value time lock object used for verificiation.\n   * @param numberOfOperations The target number of operations.\n   * @param sidetreeTransactionTime The transaction time where the operations were written.\n   * @param sidetreeTransactionWriter The writer of the transaction.\n   * @param versionMetadataFetcher The mapper from transaction time to version metadata\n   */\n  public static verifyLockAmountAndThrowOnError(\n    valueTimeLock: ValueTimeLockModel | undefined,\n    numberOfOperations: number,\n    sidetreeTransactionTime: number,\n    sidetreeTransactionWriter: string,\n    versionMetadataFetcher: IVersionMetadataFetcher\n  ): void {\n    // If the number of written operations were under the free limit then there's nothing to check\n    if (\n      numberOfOperations <=\n      protocolParameters.maxNumberOfOperationsForNoValueTimeLock\n    ) {\n      return;\n    }\n\n    if (valueTimeLock) {\n      // Check the lock owner\n      if (valueTimeLock.owner !== sidetreeTransactionWriter) {\n        throw new SidetreeError(\n          ErrorCode.ValueTimeLockVerifierTransactionWriterLockOwnerMismatch,\n          `Sidetree transaction writer: ${sidetreeTransactionWriter} - Lock owner: ${valueTimeLock.owner}`\n        );\n      }\n\n      // Check the lock duration\n      if (\n        sidetreeTransactionTime < valueTimeLock.lockTransactionTime ||\n        sidetreeTransactionTime >= valueTimeLock.unlockTransactionTime\n      ) {\n        throw new SidetreeError(\n          ErrorCode.ValueTimeLockVerifierTransactionTimeOutsideLockRange,\n          // tslint:disable-next-line: max-line-length\n          `Sidetree transaction block: ${sidetreeTransactionTime}; lock start time: ${valueTimeLock.lockTransactionTime}; unlock time: ${valueTimeLock.unlockTransactionTime}`\n        );\n      }\n    }\n\n    const maxNumberOfOpsAllowed = this.calculateMaxNumberOfOperationsAllowed(\n      valueTimeLock,\n      versionMetadataFetcher\n    );\n\n    if (numberOfOperations > maxNumberOfOpsAllowed) {\n      throw new SidetreeError(\n        ErrorCode.ValueTimeLockVerifierInvalidNumberOfOperations,\n        `Max number of ops allowed: ${maxNumberOfOpsAllowed}; actual number of ops: ${numberOfOperations}`\n      );\n    }\n  }\n}\n"],"names":["FeeManager","computeMinimumTransactionFee","normalizedFee","numberOfOperations","SidetreeError","ErrorCode","OperationCountLessThanZero","feePerOperation","protocolParameters","normalizedFeeToPerOperationFeeMultiplier","feeForAllOperations","transactionFee","Math","max","verifyTransactionFeeAndThrowOnError","transactionFeePaid","TransactionFeePaidLessThanNormalizedFee","actualFeePerOperation","expectedFeePerOperation","TransactionFeePaidInvalid","ValueTimeLockVerifier","calculateMaxNumberOfOperationsAllowed","valueTimeLock","versionMetadataFetcher","undefined","maxNumberOfOperationsForNoValueTimeLock","versionMetadata","getVersionMetadata","lockTransactionTime","valueTimeLockAmountMultiplier","numberOfOpsAllowed","amountLocked","numberOfOpsAllowedInt","floor","verifyLockAmountAndThrowOnError","sidetreeTransactionTime","sidetreeTransactionWriter","owner","ValueTimeLockVerifierTransactionWriterLockOwnerMismatch","unlockTransactionTime","ValueTimeLockVerifierTransactionTimeOutsideLockRange","maxNumberOfOpsAllowed","ValueTimeLockVerifierInvalidNumberOfOperations"],"mappings":"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"}