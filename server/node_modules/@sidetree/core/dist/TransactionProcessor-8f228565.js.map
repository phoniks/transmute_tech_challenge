{"version":3,"file":"TransactionProcessor-8f228565.js","sources":["../src/TransactionProcessor.ts"],"sourcesContent":["/*\n * The code in this file originated from\n * @see https://github.com/decentralized-identity/sidetree\n * For the list of changes that was made to the original code\n * @see https://github.com/transmute-industries/sidetree.js/blob/master/reference-implementation-changes.md\n *\n * Copyright 2020 - Transmute Industries Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  AnchoredDataSerializer,\n  AnchoredOperationModel,\n  ChunkFileModel,\n  ErrorCode,\n  FetchResultCode,\n  IBlockchain,\n  IOperationStore,\n  ITransactionProcessor,\n  IVersionMetadataFetcher,\n  protocolParameters,\n  SidetreeError,\n  TransactionModel,\n} from '@sidetree/common';\nimport AnchorFile from './write/AnchorFile';\nimport ArrayMethods from './util/ArrayMethods';\nimport ChunkFile from './write/ChunkFile';\nimport DownloadManager from './DownloadManager';\nimport FeeManager from './FeeManager';\nimport JsonAsync from './util/JsonAsync';\nimport MapFile from './write/MapFile';\nimport ValueTimeLockVerifier from './ValueTimeLockVerifier';\n\n/**\n * Implementation of the `ITransactionProcessor`.\n */\nexport default class TransactionProcessor implements ITransactionProcessor {\n  public constructor(\n    private downloadManager: DownloadManager,\n    private operationStore: IOperationStore,\n    private blockchain: IBlockchain,\n    private versionMetadataFetcher: IVersionMetadataFetcher\n  ) {}\n\n  public async processTransaction(\n    transaction: TransactionModel\n  ): Promise<boolean> {\n    try {\n      // Decode the anchor string.\n      const anchoredData = AnchoredDataSerializer.deserialize(\n        transaction.anchorString\n      );\n\n      // Verify enough fee paid.\n      FeeManager.verifyTransactionFeeAndThrowOnError(\n        transaction.transactionFeePaid,\n        anchoredData.numberOfOperations,\n        transaction.normalizedTransactionFee\n      );\n\n      // Download and verify anchor file.\n      const anchorFile = await this.downloadAndVerifyAnchorFile(\n        transaction,\n        anchoredData.anchorFileHash,\n        anchoredData.numberOfOperations\n      );\n\n      // Download and verify map file.\n      const mapFile = await this.downloadAndVerifyMapFile(\n        anchorFile,\n        anchoredData.numberOfOperations\n      );\n\n      // Download and verify chunk file.\n      const chunkFileModel = await this.downloadAndVerifyChunkFile(mapFile);\n\n      // Compose into operations from all the files downloaded.\n      const operations = await this.composeAnchoredOperationModels(\n        transaction,\n        anchorFile,\n        mapFile,\n        chunkFileModel\n      );\n\n      // If the code reaches here, it means that the batch of operations is valid, store the operations.\n      await this.operationStore.put(operations);\n\n      return true;\n    } catch (error) {\n      if (error instanceof SidetreeError) {\n        // If error is potentially related to CAS network connectivity issues, we need to return false to retry later.\n        if (\n          error.code === ErrorCode.CasNotReachable ||\n          error.code === ErrorCode.CasFileNotFound\n        ) {\n          return false;\n        }\n\n        console.info(`Ignoring error: ${error.message}`);\n        return true;\n      } else {\n        console.error(\n          `Unexpected error processing transaction, MUST investigate and fix: ${error.message}`\n        );\n        return false;\n      }\n    }\n  }\n\n  /**\n   * @param batchSize The size of the batch in number of operations.\n   */\n  private async downloadAndVerifyAnchorFile(\n    transaction: TransactionModel,\n    anchorFileHash: string,\n    paidOperationCount: number\n  ): Promise<AnchorFile> {\n    // Verify the number of paid operations does not exceed the maximum allowed limit.\n    if (paidOperationCount > protocolParameters.maxOperationsPerBatch) {\n      throw new SidetreeError(\n        ErrorCode.TransactionProcessorPaidOperationCountExceedsLimit,\n        `Paid batch size of ${paidOperationCount} operations exceeds the allowed limit of ${protocolParameters.maxOperationsPerBatch}.`\n      );\n    }\n\n    console.info(\n      `Downloading anchor file '${anchorFileHash}', max file size limit ${protocolParameters.maxAnchorFileSizeInBytes} bytes...`\n    );\n\n    const fileBuffer = await this.downloadFileFromCas(\n      anchorFileHash,\n      protocolParameters.maxAnchorFileSizeInBytes\n    );\n    const anchorFile = await AnchorFile.parse(fileBuffer);\n\n    const operationCountInAnchorFile = anchorFile.didUniqueSuffixes.length;\n    if (operationCountInAnchorFile > paidOperationCount) {\n      throw new SidetreeError(\n        ErrorCode.AnchorFileOperationCountExceededPaidLimit,\n        `Operation count ${operationCountInAnchorFile} in anchor file exceeded limit of : ${paidOperationCount}`\n      );\n    }\n\n    // Verify required lock if one was needed.\n    const valueTimeLock = anchorFile.model.writer_lock_id\n      ? await this.blockchain.getValueTimeLock(anchorFile.model.writer_lock_id)\n      : undefined;\n    ValueTimeLockVerifier.verifyLockAmountAndThrowOnError(\n      valueTimeLock,\n      paidOperationCount,\n      transaction.transactionTime,\n      transaction.writer,\n      this.versionMetadataFetcher\n    );\n\n    return anchorFile;\n  }\n\n  /**\n   * NOTE: In order to be forward-compatable with data-pruning feature,\n   * we must continue to process the operations declared in the anchor file even if the map/chunk file is invalid.\n   * This means that this method MUST ONLY throw errors that are retryable (e.g. network or file not found errors),\n   * It is a design choice to hide the complexity of map file downloading and construction within this method,\n   * instead of throwing errors and letting the caller handle them.\n   * @returns `MapFile` if downloaded file is valid; `undefined` otherwise.\n   * @throws SidetreeErrors that are retryable.\n   */\n  private async downloadAndVerifyMapFile(\n    anchorFile: AnchorFile,\n    paidOperationCount: number\n  ): Promise<MapFile | undefined> {\n    try {\n      const anchorFileModel = anchorFile.model;\n      console.info(\n        `Downloading map file '${anchorFileModel.map_file_uri}', max file size limit ${protocolParameters.maxMapFileSizeInBytes}...`\n      );\n\n      const fileBuffer = await this.downloadFileFromCas(\n        anchorFileModel.map_file_uri,\n        protocolParameters.maxMapFileSizeInBytes\n      );\n      const mapFile = await MapFile.parse(fileBuffer);\n\n      // Calulate the max paid update operation count.\n      const operationCountInAnchorFile = anchorFile.didUniqueSuffixes.length;\n      const maxPaidUpdateOperationCount =\n        paidOperationCount - operationCountInAnchorFile;\n\n      // If the actual update operation count is greater than the max paid update operation count, the map file is invalid.\n      const updateOperationCount = mapFile.updateOperations\n        ? mapFile.updateOperations.length\n        : 0;\n      if (updateOperationCount > maxPaidUpdateOperationCount) {\n        return undefined;\n      }\n\n      // If we find operations for the same DID between anchor and map files, the map file is invalid.\n      if (\n        !ArrayMethods.areMutuallyExclusive(\n          anchorFile.didUniqueSuffixes,\n          mapFile.didUniqueSuffixes\n        )\n      ) {\n        return undefined;\n      }\n\n      return mapFile;\n    } catch (error) {\n      if (error instanceof SidetreeError) {\n        // If error is related to CAS network issues, we will surface them so retry can happen.\n        if (\n          error.code === ErrorCode.CasNotReachable ||\n          error.code === ErrorCode.CasFileNotFound\n        ) {\n          throw error;\n        }\n\n        return undefined;\n      } else {\n        console.error(\n          `Unexpected error fetching map file ${\n            anchorFile.model.map_file_uri\n          }, MUST investigate and fix: ${SidetreeError.stringify(error)}`\n        );\n        return undefined;\n      }\n    }\n  }\n\n  /**\n   * NOTE: In order to be forward-compatable with data-pruning feature,\n   * we must continue to process the operations declared in the anchor file even if the map/chunk file is invalid.\n   * This means that this method MUST ONLY throw errors that are retryable (e.g. network or file not found errors),\n   * It is a design choice to hide the complexity of chunk file downloading and construction within this method,\n   * instead of throwing errors and letting the caller handle them.\n   * @returns `ChunkFileModel` if downloaded file is valid; `undefined` otherwise.\n   * @throws SidetreeErrors that are retryable.\n   */\n  private async downloadAndVerifyChunkFile(\n    mapFile: MapFile | undefined\n  ): Promise<ChunkFileModel | undefined> {\n    // Can't download chunk file if map file is not given.\n    if (mapFile === undefined) {\n      return undefined;\n    }\n\n    let chunkFileHash;\n    try {\n      chunkFileHash = mapFile.model.chunks[0].chunk_file_uri;\n      console.info(\n        `Downloading chunk file '${chunkFileHash}', max size limit ${protocolParameters.maxChunkFileSizeInBytes}...`\n      );\n\n      const fileBuffer = await this.downloadFileFromCas(\n        chunkFileHash,\n        protocolParameters.maxChunkFileSizeInBytes\n      );\n      const chunkFileModel = await ChunkFile.parse(fileBuffer);\n\n      return chunkFileModel;\n    } catch (error) {\n      if (error instanceof SidetreeError) {\n        // If error is related to CAS network issues, we will surface them so retry can happen.\n        if (\n          error.code === ErrorCode.CasNotReachable ||\n          error.code === ErrorCode.CasFileNotFound\n        ) {\n          throw error;\n        }\n\n        return undefined;\n      } else {\n        console.error(\n          `Unexpected error fetching chunk file ${chunkFileHash}, MUST investigate and fix: ${SidetreeError.stringify(\n            error\n          )}`\n        );\n        return undefined;\n      }\n    }\n  }\n\n  private async composeAnchoredOperationModels(\n    transaction: TransactionModel,\n    anchorFile: AnchorFile,\n    mapFile: MapFile | undefined,\n    chunkFile: ChunkFileModel | undefined\n  ): Promise<AnchoredOperationModel[]> {\n    const createOperations = anchorFile.createOperations;\n    const recoverOperations = anchorFile.recoverOperations;\n    const deactivateOperations = anchorFile.deactivateOperations;\n    const updateOperations =\n      mapFile && mapFile.updateOperations ? mapFile.updateOperations : [];\n\n    // Add the operations in the following order of types: create, recover, update, deactivate.\n    const operations = [];\n    operations.push(...createOperations);\n    operations.push(...recoverOperations);\n    operations.push(...updateOperations);\n    operations.push(...deactivateOperations);\n\n    // If chunk file is found/given, we need to add `type` and `delta` from chunk file to each operation.\n    // NOTE: there is no delta for deactivate operations.\n    const patchedOperationBuffers: Buffer[] = [];\n    if (chunkFile !== undefined) {\n      // TODO: https://github.com/decentralized-identity/sidetree/issues/442\n      // Use actual operation request object instead of buffer.\n\n      const operationCountExcludingDeactivates =\n        createOperations.length +\n        recoverOperations.length +\n        updateOperations.length;\n      for (\n        let i = 0;\n        i < operationCountExcludingDeactivates && i < chunkFile.deltas.length;\n        i++\n      ) {\n        const operation = operations[i];\n        const operationJsonString = operation.operationBuffer.toString();\n        const operationObject = await JsonAsync.parse(operationJsonString);\n        operationObject.type = operation.type;\n        operationObject.delta = chunkFile.deltas[i];\n\n        const patchedOperationBuffer = Buffer.from(\n          JSON.stringify(operationObject)\n        );\n        patchedOperationBuffers.push(patchedOperationBuffer);\n      }\n    }\n\n    for (let i = 0; i < deactivateOperations.length; i++) {\n      const operation = deactivateOperations[i];\n      const operationJsonString = operation.operationBuffer.toString();\n      const operationObject = await JsonAsync.parse(operationJsonString);\n      operationObject.type = operation.type;\n\n      const patchedOperationBuffer = Buffer.from(\n        JSON.stringify(operationObject)\n      );\n      patchedOperationBuffers.push(patchedOperationBuffer);\n    }\n\n    // Add anchored timestamp to each operation.\n    const anchoredOperationModels = [];\n    for (let i = 0; i < operations.length; i++) {\n      const operation = operations[i];\n\n      const anchoredOperationModel: AnchoredOperationModel = {\n        didUniqueSuffix: operation.didUniqueSuffix,\n        type: operation.type,\n        operationBuffer: patchedOperationBuffers[i],\n        operationIndex: i,\n        transactionNumber: transaction.transactionNumber,\n        transactionTime: transaction.transactionTime,\n      };\n\n      anchoredOperationModels.push(anchoredOperationModel);\n    }\n    return anchoredOperationModels;\n  }\n\n  private async downloadFileFromCas(\n    fileHash: string,\n    maxFileSizeInBytes: number\n  ): Promise<Buffer> {\n    console.info(\n      `Downloading file '${fileHash}', max size limit ${maxFileSizeInBytes}...`\n    );\n\n    const fileFetchResult = await this.downloadManager.download(\n      fileHash,\n      maxFileSizeInBytes\n    );\n\n    if (fileFetchResult.code === FetchResultCode.InvalidHash) {\n      throw new SidetreeError(\n        ErrorCode.CasFileHashNotValid,\n        `File hash '${fileHash}' is not a valid hash.`\n      );\n    }\n\n    if (fileFetchResult.code === FetchResultCode.MaxSizeExceeded) {\n      throw new SidetreeError(\n        ErrorCode.CasFileTooLarge,\n        `File '${fileHash}' exceeded max size limit of ${maxFileSizeInBytes} bytes.`\n      );\n    }\n\n    if (fileFetchResult.code === FetchResultCode.NotAFile) {\n      throw new SidetreeError(\n        ErrorCode.CasFileNotAFile,\n        `File hash '${fileHash}' points to a content that is not a file.`\n      );\n    }\n\n    if (fileFetchResult.code === FetchResultCode.CasNotReachable) {\n      throw new SidetreeError(\n        ErrorCode.CasNotReachable,\n        `CAS not reachable for file '${fileHash}'.`\n      );\n    }\n\n    if (fileFetchResult.code === FetchResultCode.NotFound) {\n      throw new SidetreeError(\n        ErrorCode.CasFileNotFound,\n        `File '${fileHash}' not found.`\n      );\n    }\n\n    console.info(\n      `File '${fileHash}' of size ${\n        fileFetchResult.content!.length\n      } downloaded.`\n    );\n\n    return fileFetchResult.content!;\n  }\n}\n"],"names":["TransactionProcessor","downloadManager","operationStore","blockchain","versionMetadataFetcher","processTransaction","transaction","anchoredData","AnchoredDataSerializer","deserialize","anchorString","FeeManager","verifyTransactionFeeAndThrowOnError","transactionFeePaid","numberOfOperations","normalizedTransactionFee","downloadAndVerifyAnchorFile","anchorFileHash","anchorFile","downloadAndVerifyMapFile","mapFile","downloadAndVerifyChunkFile","chunkFileModel","composeAnchoredOperationModels","operations","put","error","SidetreeError","code","ErrorCode","CasNotReachable","CasFileNotFound","console","info","message","paidOperationCount","protocolParameters","maxOperationsPerBatch","TransactionProcessorPaidOperationCountExceedsLimit","maxAnchorFileSizeInBytes","downloadFileFromCas","fileBuffer","AnchorFile","parse","valueTimeLock","ValueTimeLockVerifier","verifyLockAmountAndThrowOnError","transactionTime","writer","operationCountInAnchorFile","didUniqueSuffixes","length","AnchorFileOperationCountExceededPaidLimit","model","writer_lock_id","getValueTimeLock","undefined","anchorFileModel","map_file_uri","maxMapFileSizeInBytes","MapFile","maxPaidUpdateOperationCount","updateOperationCount","updateOperations","ArrayMethods","areMutuallyExclusive","stringify","chunkFileHash","chunks","chunk_file_uri","maxChunkFileSizeInBytes","ChunkFile","chunkFile","anchoredOperationModels","i","operation","anchoredOperationModel","didUniqueSuffix","type","operationBuffer","patchedOperationBuffers","operationIndex","transactionNumber","push","deactivateOperations","operationJsonString","toString","JsonAsync","operationObject","patchedOperationBuffer","Buffer","from","JSON","createOperations","recoverOperations","operationCountExcludingDeactivates","deltas","delta","fileHash","maxFileSizeInBytes","download","fileFetchResult","FetchResultCode","InvalidHash","CasFileHashNotValid","MaxSizeExceeded","CasFileTooLarge","NotAFile","CasFileNotAFile","NotFound","content"],"mappings":"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"}