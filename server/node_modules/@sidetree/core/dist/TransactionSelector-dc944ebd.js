import { k as _createForOfIteratorHelperLoose } from './index-f6e63a58.js';
import { SidetreeError, ErrorCode, AnchoredDataSerializer, protocolParameters } from '@sidetree/common';
import 'fast-json-patch';
import 'jose';
import 'bip39';
import '@transmute/did-key-ed25519';
import 'hdkey';
import '@trust/keyto';
import '@transmute/did-key-secp256k1';
import 'time-span';
import 'crypto';
import PriorityQueue from 'priorityqueue';

/**
 * rate limits how many operations is valid per block
 */

var TransactionSelector = /*#__PURE__*/function () {
  function TransactionSelector(transactionStore) {
    this.transactionStore = transactionStore;
    this.maxNumberOfOperationsPerBlock = protocolParameters.maxNumberOfOperationsPerTransactionTime;
    this.maxNumberOfTransactionsPerBlock = protocolParameters.maxNumberOfTransactionsPerTransactionTime;
  }

  TransactionSelector.getTransactionPriorityQueue = function getTransactionPriorityQueue() {
    var comparator = function comparator(a, b) {
      // higher fee comes first. If fees are the same, earlier transaction comes first
      return a.transactionFeePaid - b.transactionFeePaid || b.transactionNumber - a.transactionNumber;
    };

    return new PriorityQueue({
      comparator: comparator
    });
  }
  /**
   * Returns an array of transactions that should be processed. Ranked by highest fee paid per transaction and up to the
   * max number of operations per block
   * @param transactions The transactions that should be ranked and considered to process
   */
  ;

  var _proto = TransactionSelector.prototype;

  _proto.selectQualifiedTransactions = function selectQualifiedTransactions(transactions) {
    try {
      var _this2 = this;

      if (!transactions.length) {
        return Promise.resolve([]);
      }

      var transactionsPriorityQueue = TransactionSelector.getTransactionPriorityQueue();
      var currentTransactionTime = transactions[0].transactionTime;
      TransactionSelector.validateTransactions(transactions, currentTransactionTime);
      TransactionSelector.enqueueFirstTransactionFromEachWriter(transactions, currentTransactionTime, transactionsPriorityQueue);
      return Promise.resolve(_this2.getNumberOfOperationsAndTransactionsAlreadyInTransactionTime(currentTransactionTime)).then(function (_ref) {
        var numberOfOperations = _ref[0],
            numberOfTransactions = _ref[1];
        var numberOfOperationsToQualify = _this2.maxNumberOfOperationsPerBlock - numberOfOperations;
        var numberOfTransactionsToQualify = _this2.maxNumberOfTransactionsPerBlock - numberOfTransactions;
        var transactionsToReturn = TransactionSelector.getHighestFeeTransactionsFromCurrentTransactionTime(numberOfOperationsToQualify, numberOfTransactionsToQualify, transactionsPriorityQueue);
        return transactionsToReturn;
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  TransactionSelector.validateTransactions = function validateTransactions(transactions, currentTransactionTime) {
    for (var _iterator = _createForOfIteratorHelperLoose(transactions), _step; !(_step = _iterator()).done;) {
      var transaction = _step.value;

      // expect all transactions to be in the same transaction time
      if (transaction.transactionTime !== currentTransactionTime) {
        throw new SidetreeError(ErrorCode.TransactionsNotInSameBlock, 'transaction must be in the same block to perform rate limiting, investigate and fix');
      }
    }
  };

  TransactionSelector.enqueueFirstTransactionFromEachWriter = function enqueueFirstTransactionFromEachWriter(transactions, currentTransactionTime, transactionsPriorityQueue) {
    var writerToTransactionNumberMap = new Map(); // if multiple transactions have the same writer, take the first one in the array and enqueue into transactionPriorityQueue

    for (var _iterator2 = _createForOfIteratorHelperLoose(transactions), _step2; !(_step2 = _iterator2()).done;) {
      var transaction = _step2.value;

      // only 1 transaction is allowed per writer
      if (writerToTransactionNumberMap.has(transaction.writer)) {
        var acceptedTransactionNumber = writerToTransactionNumberMap.get(transaction.writer); // tslint:disable-next-line:max-line-length

        console.info("Multiple transactions found in transaction time " + currentTransactionTime + " from writer " + transaction.writer + ", considering transaction " + acceptedTransactionNumber + " and ignoring " + transaction.transactionNumber);
      } else {
        transactionsPriorityQueue.push(transaction);
        writerToTransactionNumberMap.set(transaction.writer, transaction.transactionNumber);
      }
    }
  };

  _proto.getNumberOfOperationsAndTransactionsAlreadyInTransactionTime = function getNumberOfOperationsAndTransactionsAlreadyInTransactionTime(transactionTime) {
    try {
      var _this4 = this;

      return Promise.resolve(_this4.transactionStore.getTransactionsStartingFrom(transactionTime, transactionTime)).then(function (transactions) {
        var numberOfOperations = 0;

        if (transactions) {
          for (var _iterator3 = _createForOfIteratorHelperLoose(transactions), _step3; !(_step3 = _iterator3()).done;) {
            var transaction = _step3.value;

            try {
              var numOfOperationsInCurrentTransaction = AnchoredDataSerializer.deserialize(transaction.anchorString).numberOfOperations;
              numberOfOperations += numOfOperationsInCurrentTransaction;
            } catch (e) {
              console.debug("Error thrown in TransactionSelector: " + JSON.stringify(e, Object.getOwnPropertyNames(e)));
              console.info("Transaction with anchor string " + transaction.anchorString + " not considered as selected.");
            }
          }
        }

        var numberOfTransactions = transactions ? transactions.length : 0;
        return [numberOfOperations, numberOfTransactions];
      });
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * Given transactions within a block, return the ones that should be processed.
   */
  ;

  TransactionSelector.getHighestFeeTransactionsFromCurrentTransactionTime = function getHighestFeeTransactionsFromCurrentTransactionTime(numberOfOperationsToQualify, numberOfTransactionsToQualify, transactionsPriorityQueue) {
    var numberOfOperationsSeen = 0;
    var transactionsToReturn = [];

    while (transactionsToReturn.length < numberOfTransactionsToQualify && numberOfOperationsSeen < numberOfOperationsToQualify && transactionsPriorityQueue.length > 0) {
      var currentTransaction = transactionsPriorityQueue.pop();

      try {
        var numOfOperationsInCurrentTransaction = AnchoredDataSerializer.deserialize(currentTransaction.anchorString).numberOfOperations;
        numberOfOperationsSeen += numOfOperationsInCurrentTransaction;

        if (numberOfOperationsSeen <= numberOfOperationsToQualify) {
          transactionsToReturn.push(currentTransaction);
        }
      } catch (e) {
        console.debug("Error thrown in TransactionSelector: " + JSON.stringify(e, Object.getOwnPropertyNames(e)));
        console.info("Transaction with anchor string " + currentTransaction.anchorString + " not selected");
      }
    } // sort based on transaction number ascending


    return transactionsToReturn;
  };

  return TransactionSelector;
}();

export default TransactionSelector;
//# sourceMappingURL=TransactionSelector-dc944ebd.js.map
