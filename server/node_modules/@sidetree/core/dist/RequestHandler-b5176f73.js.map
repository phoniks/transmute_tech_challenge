{"version":3,"file":"RequestHandler-b5176f73.js","sources":["../src/Did.ts","../src/RequestHandler.ts"],"sourcesContent":["/*\n * The code in this file originated from\n * @see https://github.com/decentralized-identity/sidetree\n * For the list of changes that was made to the original code\n * @see https://github.com/transmute-industries/sidetree.js/blob/master/reference-implementation-changes.md\n *\n * Copyright 2020 - Transmute Industries Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  ErrorCode,\n  Multihash,\n  OperationType,\n  SidetreeError,\n} from '@sidetree/common';\nimport CreateOperation from './CreateOperation';\nimport { URL } from 'url';\n\n/**\n * Class containing reusable Sidetree DID related operations.\n */\nexport default class Did {\n  private static readonly initialStateParameterSuffix = 'initial-state';\n\n  /** `true` if DID is short form; `false` if DID is long-form. */\n  public isShortForm: boolean;\n  /** DID method name. */\n  public didMethodName: string;\n  /** DID unique suffix. */\n  public uniqueSuffix: string;\n  /** The create operation if the DID given is long-form, `undefined` otherwise. */\n  public createOperation?: CreateOperation;\n  /** The short form. */\n  public shortForm: string;\n\n  /**\n   * Parses the input string as Sidetree DID.\n   * NOTE: Must not call this constructor directly, use the factory `create` method instead.\n   * @param did Short or long-form DID string.\n   * @param didMethodName The expected DID method given in the DID string. The method throws SidetreeError if mismatch.\n   */\n  private constructor(did: string, didMethodName: string) {\n    this.didMethodName = didMethodName;\n    const didPrefix = `did:${didMethodName}:`;\n\n    if (!did.startsWith(didPrefix)) {\n      throw new SidetreeError(ErrorCode.DidIncorrectPrefix);\n    }\n\n    const indexOfQuestionMarkChar = did.indexOf('?');\n    // If there is no question mark, then DID can only be in short-form.\n    if (indexOfQuestionMarkChar < 0) {\n      this.isShortForm = true;\n    } else {\n      this.isShortForm = false;\n    }\n\n    if (this.isShortForm) {\n      this.uniqueSuffix = did.substring(didPrefix.length);\n    } else {\n      // This is long-form.\n      this.uniqueSuffix = did.substring(\n        didPrefix.length,\n        indexOfQuestionMarkChar\n      );\n    }\n\n    if (this.uniqueSuffix.length === 0) {\n      throw new SidetreeError(ErrorCode.DidNoUniqueSuffix);\n    }\n\n    this.shortForm = didPrefix + this.uniqueSuffix;\n  }\n\n  /**\n   * Parses the input string as Sidetree DID.\n   * @param didString Short or long-form DID string.\n   */\n  public static async create(\n    didString: string,\n    didMethodName: string\n  ): Promise<Did> {\n    const did = new Did(didString, didMethodName);\n\n    // If DID is long-form, ensure the unique suffix constructed from the suffix data matches the short-form DID and populate the `createOperation` property.\n    if (!did.isShortForm) {\n      const initialState = Did.getInitialStateFromDidString(\n        didString,\n        didMethodName\n      );\n      const createOperation = await Did.constructCreateOperationFromInitialState(\n        initialState\n      );\n\n      // NOTE: we cannot use the unique suffix directly from `createOperation.didUniqueSuffix` for comparison,\n      // becasue a given long-form DID may have been created long ago,\n      // thus this version of `CreateOperation.parse()` maybe using a different hashing algorithm than that of the unique DID suffix (short-form).\n      // So we compute the suffix data hash again using the hashing algorithm used by the given unique DID suffix (short-form).\n      const suffixDataHashMatchesUniqueSuffix = Multihash.isValidHash(\n        createOperation.encodedSuffixData,\n        did.uniqueSuffix\n      );\n\n      // If the computed suffix data hash is not the same as the unique suffix given in the DID string, the DID is not valid.\n      if (!suffixDataHashMatchesUniqueSuffix) {\n        throw new SidetreeError(\n          ErrorCode.DidUniqueSuffixFromInitialStateMismatch\n        );\n      }\n\n      did.createOperation = createOperation;\n    }\n\n    return did;\n  }\n\n  private static getInitialStateFromDidString(\n    didString: string,\n    methodNameWithNetworkId: string\n  ): string {\n    let didStringUrl = undefined;\n    try {\n      didStringUrl = new URL(didString);\n    } catch {\n      throw new SidetreeError(ErrorCode.DidInvalidDidString);\n    }\n\n    // TODO: #470 - Support/disambiguate \"network ID\" in method name.\n\n    // Stripping away the potential network ID portion. e.g. 'sidetree:test' -> 'sidetree'\n    const methodName = methodNameWithNetworkId.split(':')[0];\n\n    let queryParamCounter = 0;\n    let initialStateValue;\n\n    // Verify that `-<method-name>-initial-state` is the one and only parameter.\n    for (const [key, value] of didStringUrl.searchParams) {\n      queryParamCounter += 1;\n      if (queryParamCounter > 1) {\n        throw new SidetreeError(ErrorCode.DidLongFormOnlyOneQueryParamAllowed);\n      }\n\n      // expect key to be -<method-name>-initial-state\n      const expectedKey = `-${methodName}-${Did.initialStateParameterSuffix}`;\n      if (key !== expectedKey) {\n        throw new SidetreeError(\n          ErrorCode.DidLongFormOnlyInitialStateParameterIsAllowed\n        );\n      }\n\n      initialStateValue = value;\n    }\n\n    if (initialStateValue === undefined) {\n      throw new SidetreeError(ErrorCode.DidLongFormNoInitialStateFound);\n    }\n\n    return initialStateValue;\n  }\n\n  private static async constructCreateOperationFromInitialState(\n    initialState: string\n  ): Promise<CreateOperation> {\n    // Initial state should be in the format: <suffix-data>.<delta>\n    const firstIndexOfDot = initialState.indexOf('.');\n    if (firstIndexOfDot === -1) {\n      throw new SidetreeError(ErrorCode.DidInitialStateValueContainsNoDot);\n    }\n\n    const lastIndexOfDot = initialState.lastIndexOf('.');\n    if (lastIndexOfDot !== firstIndexOfDot) {\n      throw new SidetreeError(\n        ErrorCode.DidInitialStateValueContainsMoreThanOneDot\n      );\n    }\n\n    if (firstIndexOfDot === initialState.length - 1 || firstIndexOfDot === 0) {\n      throw new SidetreeError(\n        ErrorCode.DidInitialStateValueDoesNotContainTwoParts\n      );\n    }\n\n    const initialStateParts = initialState.split('.');\n    const suffixData = initialStateParts[0];\n    const delta = initialStateParts[1];\n    const createOperationRequest = {\n      type: OperationType.Create,\n      suffix_data: suffixData,\n      delta,\n    };\n    const createOperationBuffer = Buffer.from(\n      JSON.stringify(createOperationRequest)\n    );\n    const createOperation = await CreateOperation.parseObject(\n      createOperationRequest,\n      createOperationBuffer,\n      false\n    );\n\n    return createOperation;\n  }\n}\n","/*\n * The code in this file originated from\n * @see https://github.com/decentralized-identity/sidetree\n * For the list of changes that was made to the original code\n * @see https://github.com/transmute-industries/sidetree.js/blob/master/reference-implementation-changes.md\n *\n * Copyright 2020 - Transmute Industries Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  DidState,\n  ErrorCode,\n  IOperationQueue,\n  IRequestHandler,\n  OperationModel,\n  OperationType,\n  protocolParameters,\n  ResponseModel,\n  ResponseStatus,\n  SidetreeError,\n} from '@sidetree/common';\nimport Did from './Did';\nimport DocumentComposer from './DocumentComposer';\nimport JsonAsync from './util/JsonAsync';\nimport Operation from './Operation';\nimport OperationProcessor from './OperationProcessor';\nimport Resolver from './Resolver';\n\n/**\n * Sidetree operation request handler.\n */\nexport default class RequestHandler implements IRequestHandler {\n  private operationProcessor: OperationProcessor;\n\n  public constructor(\n    private resolver: Resolver,\n    private operationQueue: IOperationQueue,\n    private didMethodName: string\n  ) {\n    this.operationProcessor = new OperationProcessor();\n  }\n\n  /**\n   * Handles an operation request.\n   */\n  public async handleOperationRequest(request: Buffer): Promise<ResponseModel> {\n    console.info(\n      `Handling operation request of size ${request.length} bytes...`\n    );\n\n    // Perform common validation for any write request and parse it into an `OperationModel`.\n    let operationModel: OperationModel;\n    try {\n      const operationRequest = await JsonAsync.parse(request);\n\n      // Check `delta` property data size if they exist in the operation.\n      if (\n        operationRequest.type === OperationType.Create ||\n        operationRequest.type === OperationType.Recover ||\n        operationRequest.type === OperationType.Update\n      ) {\n        const deltaBuffer = Buffer.from(operationRequest.delta);\n        if (deltaBuffer.length > protocolParameters.maxDeltaSizeInBytes) {\n          const errorMessage = `operationDdata byte size of ${deltaBuffer.length} exceeded limit of ${protocolParameters.maxDeltaSizeInBytes}`;\n          console.info(errorMessage);\n          throw new SidetreeError(\n            ErrorCode.RequestHandlerDeltaExceedsMaximumSize,\n            errorMessage\n          );\n        }\n      }\n\n      operationModel = await Operation.parse(request);\n\n      // Reject operation if there is already an operation for the same DID waiting to be batched and anchored.\n      if (await this.operationQueue.contains(operationModel.didUniqueSuffix)) {\n        const errorMessage = `An operation request already exists in queue for DID '${operationModel.didUniqueSuffix}', only one is allowed at a time.`;\n        throw new SidetreeError(\n          ErrorCode.QueueingMultipleOperationsPerDidNotAllowed,\n          errorMessage\n        );\n      }\n    } catch (error) {\n      // Give meaningful/specific error code and message when possible.\n      if (error instanceof SidetreeError) {\n        console.info(`Bad request: ${error.code}`);\n        console.info(`Error message: ${error.message}`);\n        return {\n          status: ResponseStatus.BadRequest,\n          body: { code: error.code, message: error.message },\n        };\n      }\n\n      // Else we give a generic bad request response.\n      console.info(`Bad request: ${error}`);\n      return {\n        status: ResponseStatus.BadRequest,\n      };\n    }\n\n    try {\n      console.info(\n        `Operation type: '${operationModel.type}', DID unique suffix: '${operationModel.didUniqueSuffix}'`\n      );\n\n      // Passed common operation validation, hand off to specific operation handler.\n      let response: ResponseModel;\n      switch (operationModel.type) {\n        case OperationType.Create:\n          response = await this.handleCreateRequest(operationModel);\n          break;\n        // these cases do nothing because we do not know the latest document state unless we resolve.\n        case OperationType.Update:\n        case OperationType.Recover:\n        case OperationType.Deactivate:\n          response = {\n            status: ResponseStatus.Succeeded,\n          };\n          break;\n        default:\n          // Should be an impossible condition, but we defensively check and handle.\n          response = {\n            status: ResponseStatus.BadRequest,\n            body: {\n              code: ErrorCode.RequestHandlerUnknownOperationType,\n              message: `Unsupported operation type '${operationModel.type}'.`,\n            },\n          };\n      }\n\n      // if the operation was processed successfully, queue the original request buffer for batching.\n      if (response.status === ResponseStatus.Succeeded) {\n        await this.operationQueue.enqueue(\n          operationModel.didUniqueSuffix,\n          operationModel.operationBuffer\n        );\n      }\n\n      return response;\n    } catch (error) {\n      // Give meaningful/specific error code and message when possible.\n      if (error instanceof SidetreeError) {\n        console.info(`Sidetree error: ${error.code} ${error.message}`);\n        return {\n          status: ResponseStatus.BadRequest,\n          body: { code: error.code, message: error.message },\n        };\n      }\n\n      console.info(`Unexpected error: ${error}`);\n      return {\n        status: ResponseStatus.ServerError,\n      };\n    }\n  }\n\n  private async handleCreateRequest(\n    operationModel: OperationModel\n  ): Promise<ResponseModel> {\n    const didState = await this.applyCreateOperation(operationModel);\n\n    // Should be an impossible condition, but we defensively check and handle.\n    if (didState === undefined) {\n      return {\n        status: ResponseStatus.BadRequest,\n        body: 'Invalid create operation.',\n      };\n    }\n\n    const did = `did:${this.didMethodName}:${operationModel.didUniqueSuffix}`;\n    const document = DocumentComposer.transformToExternalDocument(\n      didState,\n      did\n    );\n\n    return {\n      status: ResponseStatus.Succeeded,\n      body: document,\n    };\n  }\n\n  /**\n   * Handles resolve operation.\n   * @param shortOrLongFormDid Can either be:\n   *   1. A short-form DID. e.g. 'did:<methodName>:abc' or\n   *   2. A long-form DID. e.g. 'did:<methodName>:<unique-portion>?-<methodName>-initial-state=<encoded-original-did-document>'.\n   */\n  public async handleResolveRequest(\n    shortOrLongFormDid: string\n  ): Promise<ResponseModel> {\n    try {\n      console.info(`Handling resolution request for: ${shortOrLongFormDid}...`);\n\n      const did = await Did.create(shortOrLongFormDid, this.didMethodName);\n\n      let didState: DidState | undefined;\n      if (did.isShortForm) {\n        didState = await this.resolver.resolve(did.uniqueSuffix);\n      } else {\n        didState = await this.resolveLongFormDid(did);\n      }\n\n      if (didState === undefined) {\n        return {\n          status: ResponseStatus.NotFound,\n        };\n      }\n\n      const document = DocumentComposer.transformToExternalDocument(\n        didState,\n        shortOrLongFormDid\n      );\n\n      return {\n        status: ResponseStatus.Succeeded,\n        body: document,\n      };\n    } catch (error) {\n      // Give meaningful/specific error code and message when possible.\n      if (error instanceof SidetreeError) {\n        return {\n          status: ResponseStatus.BadRequest,\n          body: { code: error.code, message: error.message },\n        };\n      }\n\n      console.info(`Unexpected error: ${error}`);\n      return {\n        status: ResponseStatus.ServerError,\n      };\n    }\n  }\n\n  /**\n   * Resolves the given long-form DID by resolving using operations found over the network first;\n   * if no operations found, the given create operation will is used to construct the DID state.\n   */\n  private async resolveLongFormDid(did: Did): Promise<DidState | undefined> {\n    // Attempt to resolve the DID by using operations found from the network first.\n    let didState = await this.resolver.resolve(did.uniqueSuffix);\n\n    // If DID state found then return it.\n    if (didState !== undefined) {\n      return didState;\n    }\n\n    // The code reaches here if this DID is not registered on the ledger.\n\n    didState = await this.applyCreateOperation(did.createOperation!);\n\n    return didState;\n  }\n\n  private async applyCreateOperation(\n    createOperation: OperationModel\n  ): Promise<DidState | undefined> {\n    const operationWithMockedAnchorTime = {\n      didUniqueSuffix: createOperation.didUniqueSuffix,\n      type: OperationType.Create,\n      transactionTime: 0,\n      transactionNumber: 0,\n      operationIndex: 0,\n      operationBuffer: createOperation.operationBuffer,\n    }; // NOTE: The transaction timing does not matter here, we are just computing a \"theoretical\" document if it were anchored on blockchain.\n\n    const newDidState = await this.operationProcessor.apply(\n      operationWithMockedAnchorTime,\n      undefined\n    );\n    return newDidState;\n  }\n}\n"],"names":["Did","did","didMethodName","didPrefix","startsWith","SidetreeError","ErrorCode","DidIncorrectPrefix","indexOfQuestionMarkChar","indexOf","isShortForm","uniqueSuffix","substring","length","DidNoUniqueSuffix","shortForm","create","didString","initialState","getInitialStateFromDidString","constructCreateOperationFromInitialState","createOperation","suffixDataHashMatchesUniqueSuffix","Multihash","isValidHash","encodedSuffixData","DidUniqueSuffixFromInitialStateMismatch","methodNameWithNetworkId","didStringUrl","undefined","URL","DidInvalidDidString","methodName","split","queryParamCounter","initialStateValue","searchParams","key","value","DidLongFormOnlyOneQueryParamAllowed","expectedKey","initialStateParameterSuffix","DidLongFormOnlyInitialStateParameterIsAllowed","DidLongFormNoInitialStateFound","firstIndexOfDot","DidInitialStateValueContainsNoDot","lastIndexOfDot","lastIndexOf","DidInitialStateValueContainsMoreThanOneDot","DidInitialStateValueDoesNotContainTwoParts","initialStateParts","suffixData","delta","createOperationRequest","type","OperationType","Create","suffix_data","createOperationBuffer","Buffer","from","JSON","stringify","CreateOperation","parseObject","RequestHandler","resolver","operationQueue","operationProcessor","OperationProcessor","handleOperationRequest","request","response","status","ResponseStatus","Succeeded","enqueue","operationModel","didUniqueSuffix","operationBuffer","console","info","handleCreateRequest","Update","Recover","Deactivate","BadRequest","body","code","RequestHandlerUnknownOperationType","message","error","ServerError","JsonAsync","parse","operationRequest","deltaBuffer","protocolParameters","maxDeltaSizeInBytes","errorMessage","RequestHandlerDeltaExceedsMaximumSize","Operation","contains","QueueingMultipleOperationsPerDidNotAllowed","applyCreateOperation","didState","document","DocumentComposer","transformToExternalDocument","handleResolveRequest","shortOrLongFormDid","NotFound","resolve","resolveLongFormDid","operationWithMockedAnchorTime","transactionTime","transactionNumber","operationIndex","apply"],"mappings":"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"}