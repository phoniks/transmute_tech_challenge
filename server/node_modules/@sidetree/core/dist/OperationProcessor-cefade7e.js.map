{"version":3,"file":"OperationProcessor-cefade7e.js","sources":["../src/OperationProcessor.ts"],"sourcesContent":["/*\n * The code in this file originated from\n * @see https://github.com/decentralized-identity/sidetree\n * For the list of changes that was made to the original code\n * @see https://github.com/transmute-industries/sidetree.js/blob/master/reference-implementation-changes.md\n *\n * Copyright 2020 - Transmute Industries Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/* eslint-disable no-case-declarations */\nimport {\n  AnchoredOperationModel,\n  DidState,\n  ErrorCode,\n  IOperationProcessor,\n  JsonCanonicalizer,\n  Multihash,\n  OperationType,\n  SidetreeError,\n} from '@sidetree/common';\nimport CreateOperation from './CreateOperation';\nimport DeactivateOperation from './DeactivateOperation';\nimport DocumentComposer from './DocumentComposer';\nimport Operation from './Operation';\nimport RecoverOperation from './RecoverOperation';\nimport UpdateOperation from './UpdateOperation';\n\n/**\n * Implementation of IOperationProcessor.\n */\nexport default class OperationProcessor implements IOperationProcessor {\n  public async apply(\n    anchoredOperationModel: AnchoredOperationModel,\n    didState: DidState | undefined\n  ): Promise<DidState | undefined> {\n    // If DID state is undefined, then the operation given must be a create operation, otherwise the operation cannot be applied.\n    if (\n      didState === undefined &&\n      anchoredOperationModel.type !== OperationType.Create\n    ) {\n      return undefined;\n    }\n\n    const previousOperationTransactionNumber = didState\n      ? didState.lastOperationTransactionNumber\n      : undefined;\n\n    let appliedDidState: DidState | undefined;\n    if (anchoredOperationModel.type === OperationType.Create) {\n      appliedDidState = await this.applyCreateOperation(\n        anchoredOperationModel,\n        didState\n      );\n    } else if (anchoredOperationModel.type === OperationType.Update) {\n      appliedDidState = await this.applyUpdateOperation(\n        anchoredOperationModel,\n        didState!\n      );\n    } else if (anchoredOperationModel.type === OperationType.Recover) {\n      appliedDidState = await this.applyRecoverOperation(\n        anchoredOperationModel,\n        didState!\n      );\n    } else if (anchoredOperationModel.type === OperationType.Deactivate) {\n      appliedDidState = await this.applyDeactivateOperation(\n        anchoredOperationModel,\n        didState!\n      );\n    } else {\n      throw new SidetreeError(ErrorCode.OperationProcessorUnknownOperationType);\n    }\n\n    try {\n      // If the operation was not applied, log some info in case needed for debugging.\n      if (\n        appliedDidState === undefined ||\n        appliedDidState.lastOperationTransactionNumber ===\n          previousOperationTransactionNumber\n      ) {\n        const index = anchoredOperationModel.operationIndex;\n        const time = anchoredOperationModel.transactionTime;\n        const number = anchoredOperationModel.transactionNumber;\n        const didUniqueSuffix = anchoredOperationModel.didUniqueSuffix;\n        console.debug(\n          `Ignored invalid operation for DID '${didUniqueSuffix}' in transaction '${number}' at time '${time}' at operation index ${index}.`\n        );\n      }\n    } catch (error) {\n      console.log(`Failed logging ${error}.`);\n      // If logging fails, just move on.\n    }\n\n    return appliedDidState;\n  }\n\n  public async getRevealValue(\n    anchoredOperationModel: AnchoredOperationModel\n  ): Promise<Buffer> {\n    if (anchoredOperationModel.type === OperationType.Create) {\n      throw new SidetreeError(\n        ErrorCode.OperationProcessorCreateOperationDoesNotHaveRevealValue\n      );\n    }\n\n    const operation = await Operation.parse(\n      anchoredOperationModel.operationBuffer\n    );\n\n    let revealValueBuffer;\n    switch (operation.type) {\n      case OperationType.Recover:\n        const recoverOperation = operation as RecoverOperation;\n        revealValueBuffer = JsonCanonicalizer.canonicalizeAsBuffer(\n          recoverOperation.signedData.recovery_key\n        );\n        return revealValueBuffer;\n      case OperationType.Update:\n        const updateOperation = operation as UpdateOperation;\n        revealValueBuffer = JsonCanonicalizer.canonicalizeAsBuffer(\n          updateOperation.signedData.update_key\n        );\n        return revealValueBuffer;\n      default:\n        // This is a deactivate.\n        const deactivateOperation = operation as DeactivateOperation;\n        revealValueBuffer = JsonCanonicalizer.canonicalizeAsBuffer(\n          deactivateOperation.signedData.recovery_key\n        );\n        return revealValueBuffer;\n    }\n  }\n\n  /**\n   * @returns new DID state if operation is applied successfully; the given DID state otherwise.\n   */\n  private async applyCreateOperation(\n    anchoredOperationModel: AnchoredOperationModel,\n    didState: DidState | undefined\n  ): Promise<DidState | undefined> {\n    // If DID state is already created by a previous create operation, then we cannot apply a create operation again.\n    if (didState !== undefined) {\n      return didState;\n    }\n\n    const operation = await CreateOperation.parse(\n      anchoredOperationModel.operationBuffer\n    );\n\n    // Ensure actual delta hash matches expected delta hash.\n    const isMatchingDelta = Multihash.isValidHash(\n      operation.encodedDelta,\n      operation.suffixData.delta_hash\n    );\n    if (!isMatchingDelta) {\n      return didState;\n    }\n\n    // Apply the given patches against an empty object.\n    const delta = operation.delta;\n    let document = {};\n    try {\n      if (delta !== undefined) {\n        document = DocumentComposer.applyPatches(document, delta.patches);\n      }\n    } catch (error) {\n      const didUniqueSuffix = anchoredOperationModel.didUniqueSuffix;\n      const transactionNumber = anchoredOperationModel.transactionNumber;\n      console.debug(\n        `Unable to apply document patch in transaction number ${transactionNumber} for DID ${didUniqueSuffix}: ${SidetreeError.stringify(\n          error\n        )}.`\n      );\n\n      // Return the given DID state if error is encountered applying the patches.\n      return didState;\n    }\n\n    const newDidState = {\n      didUniqueSuffix: operation.didUniqueSuffix,\n      document,\n      nextRecoveryCommitmentHash: operation.suffixData.recovery_commitment,\n      nextUpdateCommitmentHash: delta ? delta.update_commitment : undefined,\n      lastOperationTransactionNumber: anchoredOperationModel.transactionNumber,\n    };\n\n    return newDidState;\n  }\n\n  /**\n   * @returns new DID state if operation is applied successfully; the given DID state otherwise.\n   */\n  private async applyUpdateOperation(\n    anchoredOperationModel: AnchoredOperationModel,\n    didState: DidState\n  ): Promise<DidState> {\n    const operation = await UpdateOperation.parse(\n      anchoredOperationModel.operationBuffer\n    );\n\n    // Verify the update key hash.\n    const isValidUpdateKey = Multihash.canonicalizeAndVerify(\n      operation.signedData.update_key,\n      didState.nextUpdateCommitmentHash!\n    );\n\n    if (!isValidUpdateKey) {\n      return didState;\n    }\n\n    // Verify the signature.\n    const signatureIsValid = await operation.signedDataJws.verifySignature(\n      operation.signedData.update_key\n    );\n\n    if (!signatureIsValid) {\n      return didState;\n    }\n\n    // Verify the delta hash against the expected delta hash.\n    const isValidDelta = Multihash.isValidHash(\n      operation.encodedDelta,\n      operation.signedData.delta_hash\n    );\n\n    if (!isValidDelta) {\n      return didState;\n    }\n\n    let resultingDocument;\n    try {\n      resultingDocument = await DocumentComposer.applyUpdateOperation(\n        operation,\n        didState.document\n      );\n    } catch (error) {\n      const didUniqueSuffix = anchoredOperationModel.didUniqueSuffix;\n      const transactionNumber = anchoredOperationModel.transactionNumber;\n      console.debug(\n        `Unable to apply document patch in transaction number ${transactionNumber} for DID ${didUniqueSuffix}: ${SidetreeError.stringify(\n          error\n        )}.`\n      );\n\n      // Return the given DID state if error is encountered applying the patches.\n      return didState;\n    }\n\n    const newDidState = {\n      nextRecoveryCommitmentHash: didState.nextRecoveryCommitmentHash,\n      // New values below.\n      document: resultingDocument,\n      nextUpdateCommitmentHash: operation.delta!.update_commitment,\n      lastOperationTransactionNumber: anchoredOperationModel.transactionNumber,\n    };\n\n    return newDidState;\n  }\n\n  /**\n   * @returns new DID state if operation is applied successfully; the given DID state otherwise.\n   */\n  private async applyRecoverOperation(\n    anchoredOperationModel: AnchoredOperationModel,\n    didState: DidState\n  ): Promise<DidState> {\n    const operation = await RecoverOperation.parse(\n      anchoredOperationModel.operationBuffer\n    );\n\n    // Verify the recovery key hash.\n    const isValidRecoveryKey = Multihash.canonicalizeAndVerify(\n      operation.signedData.recovery_key,\n      didState.nextRecoveryCommitmentHash!\n    );\n    if (!isValidRecoveryKey) {\n      return didState;\n    }\n\n    // Verify the signature.\n    const signatureIsValid = await operation.signedDataJws.verifySignature(\n      operation.signedData.recovery_key\n    );\n    if (!signatureIsValid) {\n      return didState;\n    }\n\n    // Verify the actual delta hash against the expected delta hash.\n    const isMatchingDelta = Multihash.isValidHash(\n      operation.encodedDelta,\n      operation.signedData.delta_hash\n    );\n    if (!isMatchingDelta) {\n      return didState;\n    }\n\n    // Apply the given patches against an empty object.\n    const delta = operation.delta;\n    let document = {};\n    try {\n      if (delta !== undefined) {\n        document = DocumentComposer.applyPatches(document, delta.patches);\n      }\n    } catch (error) {\n      const didUniqueSuffix = anchoredOperationModel.didUniqueSuffix;\n      const transactionNumber = anchoredOperationModel.transactionNumber;\n      console.debug(\n        `Unable to apply document patch in transaction number ${transactionNumber} for DID ${didUniqueSuffix}: ${SidetreeError.stringify(\n          error\n        )}.`\n      );\n\n      // Return the given DID state if error is encountered applying the patches.\n      return didState;\n    }\n\n    const newDidState = {\n      didUniqueSuffix: operation.didUniqueSuffix,\n      document,\n      recovery_key: operation.signedData.recovery_key,\n      nextRecoveryCommitmentHash: operation.signedData.recovery_commitment,\n      nextUpdateCommitmentHash: delta ? delta.update_commitment : undefined,\n      lastOperationTransactionNumber: anchoredOperationModel.transactionNumber,\n    };\n\n    return newDidState;\n  }\n\n  /**\n   * @returns new DID state if operation is applied successfully; the given DID state otherwise.\n   */\n  private async applyDeactivateOperation(\n    anchoredOperationModel: AnchoredOperationModel,\n    didState: DidState\n  ): Promise<DidState> {\n    const operation = await DeactivateOperation.parse(\n      anchoredOperationModel.operationBuffer\n    );\n\n    // Verify the recovery key hash.\n    const isValidRecoveryKey = Multihash.canonicalizeAndVerify(\n      operation.signedData.recovery_key,\n      didState.nextRecoveryCommitmentHash!\n    );\n    if (!isValidRecoveryKey) {\n      return didState;\n    }\n\n    // Verify the signature.\n    const signatureIsValid = await operation.signedDataJws.verifySignature(\n      operation.signedData.recovery_key\n    );\n    if (!signatureIsValid) {\n      return didState;\n    }\n\n    // The operation passes all checks.\n    const newDidState = {\n      document: didState.document,\n      // New values below.\n      recovery_key: undefined,\n      nextRecoveryCommitmentHash: undefined,\n      nextUpdateCommitmentHash: undefined,\n      lastOperationTransactionNumber: anchoredOperationModel.transactionNumber,\n    };\n    return newDidState;\n  }\n}\n"],"names":["apply","anchoredOperationModel","didState","undefined","appliedDidState","lastOperationTransactionNumber","previousOperationTransactionNumber","console","debug","didUniqueSuffix","transactionNumber","transactionTime","operationIndex","error","log","this","type","OperationType","Create","_this2","applyCreateOperation","Update","applyUpdateOperation","Recover","applyRecoverOperation","Deactivate","applyDeactivateOperation","SidetreeError","ErrorCode","OperationProcessorUnknownOperationType","getRevealValue","OperationProcessorCreateOperationDoesNotHaveRevealValue","Operation","parse","operationBuffer","operation","JsonCanonicalizer","canonicalizeAsBuffer","signedData","recovery_key","update_key","CreateOperation","Multihash","isValidHash","encodedDelta","suffixData","delta_hash","delta","document","DocumentComposer","applyPatches","patches","stringify","nextRecoveryCommitmentHash","recovery_commitment","nextUpdateCommitmentHash","update_commitment","UpdateOperation","canonicalizeAndVerify","signedDataJws","verifySignature","signatureIsValid","resultingDocument","RecoverOperation","DeactivateOperation"],"mappings":"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"}