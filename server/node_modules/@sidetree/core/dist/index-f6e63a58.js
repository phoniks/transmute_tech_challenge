import { PublicKeyPurpose, SidetreeError, ErrorCode, Encoder, Multihash, OperationType, protocolParameters, TransactionProcessingStatus, SharedErrorCode, AbstractVersionMetadata, CoreErrorCode } from '@sidetree/common';
import jsonpatch from 'fast-json-patch';
import { JWK } from 'jose';
import { mnemonicToSeed } from 'bip39';
import { Ed25519KeyPair, EdDSA } from '@transmute/did-key-ed25519';
import hdkey from 'hdkey';
import { from } from '@trust/keyto';
import { ES256K } from '@transmute/did-key-secp256k1';
import timeSpan from 'time-span';
import { randomBytes } from 'crypto';

// A type of promise-like that resolves synchronously and supports only one observer
const _Pact = /*#__PURE__*/(function() {
	function _Pact() {}
	_Pact.prototype.then = function(onFulfilled, onRejected) {
		const result = new _Pact();
		const state = this.s;
		if (state) {
			const callback = state & 1 ? onFulfilled : onRejected;
			if (callback) {
				try {
					_settle(result, 1, callback(this.v));
				} catch (e) {
					_settle(result, 2, e);
				}
				return result;
			} else {
				return this;
			}
		}
		this.o = function(_this) {
			try {
				const value = _this.v;
				if (_this.s & 1) {
					_settle(result, 1, onFulfilled ? onFulfilled(value) : value);
				} else if (onRejected) {
					_settle(result, 1, onRejected(value));
				} else {
					_settle(result, 2, value);
				}
			} catch (e) {
				_settle(result, 2, e);
			}
		};
		return result;
	};
	return _Pact;
})();

// Settles a pact synchronously
function _settle(pact, state, value) {
	if (!pact.s) {
		if (value instanceof _Pact) {
			if (value.s) {
				if (state & 1) {
					state = value.s;
				}
				value = value.v;
			} else {
				value.o = _settle.bind(null, pact, state);
				return;
			}
		}
		if (value && value.then) {
			value.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));
			return;
		}
		pact.s = state;
		pact.v = value;
		const observer = pact.o;
		if (observer) {
			observer(pact);
		}
	}
}

function _isSettledPact(thenable) {
	return thenable instanceof _Pact && thenable.s & 1;
}

// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)
function _forTo(array, body, check) {
	var i = -1, pact, reject;
	function _cycle(result) {
		try {
			while (++i < array.length && (!check || !check())) {
				result = body(i);
				if (result && result.then) {
					if (_isSettledPact(result)) {
						result = result.v;
					} else {
						result.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));
						return;
					}
				}
			}
			if (pact) {
				_settle(pact, 1, result);
			} else {
				pact = result;
			}
		} catch (e) {
			_settle(pact || (pact = new _Pact()), 2, e);
		}
	}
	_cycle();
	return pact;
}

const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== "undefined" ? (Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator"))) : "@@iterator";

// Asynchronously iterate through an object's values
// Uses for...of if the runtime supports it, otherwise iterates until length on a copy
function _forOf(target, body, check) {
	if (typeof target[_iteratorSymbol] === "function") {
		var iterator = target[_iteratorSymbol](), step, pact, reject;
		function _cycle(result) {
			try {
				while (!(step = iterator.next()).done && (!check || !check())) {
					result = body(step.value);
					if (result && result.then) {
						if (_isSettledPact(result)) {
							result = result.v;
						} else {
							result.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));
							return;
						}
					}
				}
				if (pact) {
					_settle(pact, 1, result);
				} else {
					pact = result;
				}
			} catch (e) {
				_settle(pact || (pact = new _Pact()), 2, e);
			}
		}
		_cycle();
		if (iterator.return) {
			var _fixup = function(value) {
				try {
					if (!step.done) {
						iterator.return();
					}
				} catch(e) {
				}
				return value;
			};
			if (pact && pact.then) {
				return pact.then(_fixup, function(e) {
					throw _fixup(e);
				});
			}
			_fixup();
		}
		return pact;
	}
	// No support for Symbol.iterator
	if (!("length" in target)) {
		throw new TypeError("Object is not iterable");
	}
	// Handle live collections properly
	var values = [];
	for (var i = 0; i < target.length; i++) {
		values.push(target[i]);
	}
	return _forTo(values, function(i) { return body(values[i]); }, check);
}

const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== "undefined" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol("Symbol.asyncIterator"))) : "@@asyncIterator";

// Asynchronously implement a generic for loop
function _for(test, update, body) {
	var stage;
	for (;;) {
		var shouldContinue = test();
		if (_isSettledPact(shouldContinue)) {
			shouldContinue = shouldContinue.v;
		}
		if (!shouldContinue) {
			return result;
		}
		if (shouldContinue.then) {
			stage = 0;
			break;
		}
		var result = body();
		if (result && result.then) {
			if (_isSettledPact(result)) {
				result = result.s;
			} else {
				stage = 1;
				break;
			}
		}
		if (update) {
			var updateValue = update();
			if (updateValue && updateValue.then && !_isSettledPact(updateValue)) {
				stage = 2;
				break;
			}
		}
	}
	var pact = new _Pact();
	var reject = _settle.bind(null, pact, 2);
	(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);
	return pact;
	function _resumeAfterBody(value) {
		result = value;
		do {
			if (update) {
				updateValue = update();
				if (updateValue && updateValue.then && !_isSettledPact(updateValue)) {
					updateValue.then(_resumeAfterUpdate).then(void 0, reject);
					return;
				}
			}
			shouldContinue = test();
			if (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {
				_settle(pact, 1, result);
				return;
			}
			if (shouldContinue.then) {
				shouldContinue.then(_resumeAfterTest).then(void 0, reject);
				return;
			}
			result = body();
			if (_isSettledPact(result)) {
				result = result.v;
			}
		} while (!result || !result.then);
		result.then(_resumeAfterBody).then(void 0, reject);
	}
	function _resumeAfterTest(shouldContinue) {
		if (shouldContinue) {
			result = body();
			if (result && result.then) {
				result.then(_resumeAfterBody).then(void 0, reject);
			} else {
				_resumeAfterBody(result);
			}
		} else {
			_settle(pact, 1, result);
		}
	}
	function _resumeAfterUpdate() {
		if (shouldContinue = test()) {
			if (shouldContinue.then) {
				shouldContinue.then(_resumeAfterTest).then(void 0, reject);
			} else {
				_resumeAfterTest(shouldContinue);
			}
		} else {
			_settle(pact, 1, result);
		}
	}
}

// Asynchronously implement a do ... while loop
function _do(body, test) {
	var awaitBody;
	do {
		var result = body();
		if (result && result.then) {
			if (_isSettledPact(result)) {
				result = result.v;
			} else {
				awaitBody = true;
				break;
			}
		}
		var shouldContinue = test();
		if (_isSettledPact(shouldContinue)) {
			shouldContinue = shouldContinue.v;
		}
		if (!shouldContinue) {
			return result;
		}
	} while (!shouldContinue.then);
	const pact = new _Pact();
	const reject = _settle.bind(null, pact, 2);
	(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);
	return pact;
	function _resumeAfterBody(value) {
		result = value;
		for (;;) {
			shouldContinue = test();
			if (_isSettledPact(shouldContinue)) {
				shouldContinue = shouldContinue.v;
			}
			if (!shouldContinue) {
				break;
			}
			if (shouldContinue.then) {
				shouldContinue.then(_resumeAfterTest).then(void 0, reject);
				return;
			}
			result = body();
			if (result && result.then) {
				if (_isSettledPact(result)) {
					result = result.v;
				} else {
					result.then(_resumeAfterBody).then(void 0, reject);
					return;
				}
			}
		}
		_settle(pact, 1, result);
	}
	function _resumeAfterTest(shouldContinue) {
		if (shouldContinue) {
			do {
				result = body();
				if (result && result.then) {
					if (_isSettledPact(result)) {
						result = result.v;
					} else {
						result.then(_resumeAfterBody).then(void 0, reject);
						return;
					}
				}
				shouldContinue = test();
				if (_isSettledPact(shouldContinue)) {
					shouldContinue = shouldContinue.v;
				}
				if (!shouldContinue) {
					_settle(pact, 1, result);
					return;
				}
			} while (!shouldContinue.then);
			shouldContinue.then(_resumeAfterTest).then(void 0, reject);
		} else {
			_settle(pact, 1, result);
		}
	}
}

// Asynchronously implement a switch statement
function _switch(discriminant, cases) {
	var dispatchIndex = -1;
	var awaitBody;
	outer: {
		for (var i = 0; i < cases.length; i++) {
			var test = cases[i][0];
			if (test) {
				var testValue = test();
				if (testValue && testValue.then) {
					break outer;
				}
				if (testValue === discriminant) {
					dispatchIndex = i;
					break;
				}
			} else {
				// Found the default case, set it as the pending dispatch case
				dispatchIndex = i;
			}
		}
		if (dispatchIndex !== -1) {
			do {
				var body = cases[dispatchIndex][1];
				while (!body) {
					dispatchIndex++;
					body = cases[dispatchIndex][1];
				}
				var result = body();
				if (result && result.then) {
					awaitBody = true;
					break outer;
				}
				var fallthroughCheck = cases[dispatchIndex][2];
				dispatchIndex++;
			} while (fallthroughCheck && !fallthroughCheck());
			return result;
		}
	}
	const pact = new _Pact();
	const reject = _settle.bind(null, pact, 2);
	(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);
	return pact;
	function _resumeAfterTest(value) {
		for (;;) {
			if (value === discriminant) {
				dispatchIndex = i;
				break;
			}
			if (++i === cases.length) {
				if (dispatchIndex !== -1) {
					break;
				} else {
					_settle(pact, 1, result);
					return;
				}
			}
			test = cases[i][0];
			if (test) {
				value = test();
				if (value && value.then) {
					value.then(_resumeAfterTest).then(void 0, reject);
					return;
				}
			} else {
				dispatchIndex = i;
			}
		}
		do {
			var body = cases[dispatchIndex][1];
			while (!body) {
				dispatchIndex++;
				body = cases[dispatchIndex][1];
			}
			var result = body();
			if (result && result.then) {
				result.then(_resumeAfterBody).then(void 0, reject);
				return;
			}
			var fallthroughCheck = cases[dispatchIndex][2];
			dispatchIndex++;
		} while (fallthroughCheck && !fallthroughCheck());
		_settle(pact, 1, result);
	}
	function _resumeAfterBody(result) {
		for (;;) {
			var fallthroughCheck = cases[dispatchIndex][2];
			if (!fallthroughCheck || fallthroughCheck()) {
				break;
			}
			dispatchIndex++;
			var body = cases[dispatchIndex][1];
			while (!body) {
				dispatchIndex++;
				body = cases[dispatchIndex][1];
			}
			result = body();
			if (result && result.then) {
				result.then(_resumeAfterBody).then(void 0, reject);
				return;
			}
		}
		_settle(pact, 1, result);
	}
}

// Asynchronously call a function and send errors to recovery continuation
function _catch(body, recover) {
	try {
		var result = body();
	} catch(e) {
		return recover(e);
	}
	if (result && result.then) {
		return result.then(void 0, recover);
	}
	return result;
}

// Asynchronously await a promise and pass the result to a finally continuation
function _finallyRethrows(body, finalizer) {
	try {
		var result = body();
	} catch (e) {
		return finalizer(true, e);
	}
	if (result && result.then) {
		return result.then(finalizer.bind(null, false), finalizer.bind(null, true));
	}
	return finalizer(false, result);
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it;

  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      return function () {
        if (i >= o.length) return {
          done: true
        };
        return {
          done: false,
          value: o[i++]
        };
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  it = o[Symbol.iterator]();
  return it.next.bind(it);
}

/*
 * The code in this file originated from
 * @see https://github.com/decentralized-identity/sidetree
 * For the list of changes that was made to the original code
 * @see https://github.com/transmute-industries/sidetree.js/blob/master/reference-implementation-changes.md
 *
 * Copyright 2020 - Transmute Industries Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Class containing methods that operates against an array.
 */
var ArrayMethods = /*#__PURE__*/function () {
  function ArrayMethods() {}

  /**
   * Checkes to see if there are duplicates in the given array.
   */
  ArrayMethods.hasDuplicates = function hasDuplicates(array) {
    var uniqueValues = new Set();

    for (var i = 0; i < array.length; i++) {
      var value = array[i];

      if (uniqueValues.has(value)) {
        return true;
      }

      uniqueValues.add(value);
    }

    return false;
  }
  /**
   * Checks that entries in array 2 is not in array 1.
   */
  ;

  ArrayMethods.areMutuallyExclusive = function areMutuallyExclusive(array1, array2) {
    var valuesInArray1 = new Set(array1);

    for (var _iterator = _createForOfIteratorHelperLoose(array2), _step; !(_step = _iterator()).done;) {
      var value = _step.value;

      if (valuesInArray1.has(value)) {
        return false;
      }
    }

    return true;
  };

  return ArrayMethods;
}();

/*
 * The code in this file originated from
 * @see https://github.com/decentralized-identity/sidetree
 * For the list of changes that was made to the original code
 * @see https://github.com/transmute-industries/sidetree.js/blob/master/reference-implementation-changes.md
 *
 * Copyright 2020 - Transmute Industries Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var pako = /*#__PURE__*/require('pako');
/**
 * Encapsulates functionality to compress/decompress data.
 */


var Compressor = /*#__PURE__*/function () {
  function Compressor() {}

  /**
   * Compresses the data in gzip and return it as buffer.
   * @param inputAsBuffer The input string to be compressed.
   */
  Compressor.compress = function compress(inputAsBuffer) {
    try {
      var result = pako.deflate(Buffer.from(inputAsBuffer));
      return Promise.resolve(Buffer.from(result));
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * Decompresses the input and returns it as buffer.
   * @param inputAsBuffer The gzip compressed data.
   */
  ;

  Compressor.decompress = function decompress(inputAsBuffer) {
    try {
      var result = pako.inflate(inputAsBuffer);
      return Promise.resolve(Buffer.from(result));
    } catch (e) {
      return Promise.reject(e);
    }
  };

  return Compressor;
}();

/**
 * Class that handles the composition of operations into final external-facing document.
 */

var DocumentComposer = /*#__PURE__*/function () {
  function DocumentComposer() {}

  /**
   * Transforms the given DID state into a DID Document.
   */
  DocumentComposer.transformToExternalDocument = function transformToExternalDocument(didState, did) {
    // If the DID is deactivated.
    if (didState.nextRecoveryCommitmentHash === undefined) {
      return {
        status: 'deactivated'
      };
    }

    var document = didState.document;
    var shortFormDid = did.split('?')[0]; // Only populate `publicKey` if general purpose exists.
    // Only populate `authentication` if auth purpose exists.

    var authentication = [];
    var assertionMethod = [];
    var capabilityInvocation = [];
    var capabilityDelegation = [];
    var keyAgreement = [];
    var public_keys = [];

    if (Array.isArray(document.public_keys)) {
      for (var _iterator = _createForOfIteratorHelperLoose(document.public_keys), _step; !(_step = _iterator()).done;) {
        var publicKey = _step.value;
        var id = '#' + publicKey.id;
        var didDocumentPublicKey = {
          id: id,
          controller: shortFormDid,
          type: publicKey.type,
          publicKeyJwk: publicKey.jwk
        };
        var purposeSet = new Set(publicKey.purpose);

        if (purposeSet.has(PublicKeyPurpose.General)) {
          public_keys.push(didDocumentPublicKey);

          if (purposeSet.has(PublicKeyPurpose.Auth)) {
            authentication.push(id);
          }

          if (purposeSet.has(PublicKeyPurpose.AssertionMethod)) {
            assertionMethod.push(id);
          }

          if (purposeSet.has(PublicKeyPurpose.CapabilityInvocation)) {
            capabilityInvocation.push(id);
          }

          if (purposeSet.has(PublicKeyPurpose.CapabilityDelegation)) {
            capabilityDelegation.push(id);
          }

          if (purposeSet.has(PublicKeyPurpose.KeyAgreement)) {
            keyAgreement.push(id);
          }
        } else if (purposeSet.has(PublicKeyPurpose.Auth)) {
          authentication.push(didDocumentPublicKey);
        } else if (purposeSet.has(PublicKeyPurpose.AssertionMethod)) {
          assertionMethod.push(assertionMethod);
        } else if (purposeSet.has(PublicKeyPurpose.CapabilityInvocation)) {
          capabilityInvocation.push(didDocumentPublicKey);
        } else if (purposeSet.has(PublicKeyPurpose.CapabilityDelegation)) {
          capabilityDelegation.push(didDocumentPublicKey);
        } else if (purposeSet.has(PublicKeyPurpose.KeyAgreement)) {
          keyAgreement.push(didDocumentPublicKey);
        }
      }
    } // Only update `service_endpoints` if the array is present


    var service_endpoints = [];

    if (Array.isArray(document.service_endpoints)) {
      for (var _iterator2 = _createForOfIteratorHelperLoose(document.service_endpoints), _step2; !(_step2 = _iterator2()).done;) {
        var serviceEndpoint = _step2.value;
        var didDocumentServiceEndpoint = {
          id: '#' + serviceEndpoint.id,
          type: serviceEndpoint.type,
          serviceEndpoint: serviceEndpoint.endpoint
        };
        service_endpoints.push(didDocumentServiceEndpoint);
      }
    }

    var didDocument = {
      id: shortFormDid,
      '@context': ['https://www.w3.org/ns/did/v1', {
        '@base': shortFormDid
      }]
    };

    if (public_keys.length !== 0) {
      didDocument.publicKey = public_keys;
    }

    if (authentication.length !== 0) {
      didDocument.authentication = authentication;
    }

    if (assertionMethod.length !== 0) {
      didDocument.assertionMethod = assertionMethod;
    }

    if (capabilityInvocation.length !== 0) {
      didDocument.capabilityInvocation = capabilityInvocation;
    }

    if (capabilityDelegation.length !== 0) {
      didDocument.capabilityDelegation = capabilityDelegation;
    }

    if (keyAgreement.length !== 0) {
      didDocument.keyAgreement = keyAgreement;
    }

    if (service_endpoints.length !== 0) {
      didDocument.service = service_endpoints;
    }

    var didResolutionResult = {
      '@context': 'https://www.w3.org/ns/did-resolution/v1',
      didDocument: didDocument,
      methodMetadata: {
        recoveryCommitment: didState.nextRecoveryCommitmentHash,
        updateCommitment: didState.nextUpdateCommitmentHash
      }
    };
    return JSON.parse(JSON.stringify(didResolutionResult));
  }
  /**
   * Applies the update operation to the given document.
   * @returns The resultant document.
   * @throws SidetreeError if invalid operation is given.
   */
  ;

  DocumentComposer.applyUpdateOperation = function applyUpdateOperation(operation, document) {
    try {
      var resultantDocument = DocumentComposer.applyPatches(document, operation.delta.patches);
      return Promise.resolve(resultantDocument);
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * Validates the schema of the given full document.
   * @throws SidetreeError if given document patch fails validation.
   */
  ;

  DocumentComposer.validateDocument = function validateDocument(document) {
    if (document === undefined) {
      throw new SidetreeError(ErrorCode.DocumentComposerDocumentMissing);
    }

    var allowedProperties = new Set(['public_keys', 'service_endpoints']);

    for (var property in document) {
      if (!allowedProperties.has(property)) {
        throw new SidetreeError(ErrorCode.DocumentComposerUnknownPropertyInDocument, "Unexpected property " + property + " in document.");
      }
    } // Verify 'public_keys' property if it exists.


    if (Object.prototype.hasOwnProperty.call(document, 'public_keys')) {
      DocumentComposer.validatePublicKeys(document.public_keys);
    } // Verify 'service_endpoints' property if it exists.


    if (Object.prototype.hasOwnProperty.call(document, 'service_endpoints')) {
      // Verify each endpoint entry in service_endpoints.
      DocumentComposer.validateServiceEndpoints(document.service_endpoints);
    }
  }
  /**
   * Validates the schema of the given update document patch.
   * @throws SidetreeError if given document patch fails validation.
   */
  ;

  DocumentComposer.validateDocumentPatches = function validateDocumentPatches(patches) {
    if (!Array.isArray(patches)) {
      throw new SidetreeError(ErrorCode.DocumentComposerUpdateOperationDocumentPatchesNotArray);
    }

    for (var _iterator3 = _createForOfIteratorHelperLoose(patches), _step3; !(_step3 = _iterator3()).done;) {
      var patch = _step3.value;
      DocumentComposer.validatePatch(patch);
    }
  };

  DocumentComposer.validatePatch = function validatePatch(patch) {
    var action = patch.action;

    switch (action) {
      case 'replace':
        DocumentComposer.validateDocument(patch.document);
        break;

      case 'add-public-keys':
        DocumentComposer.validateAddPublicKeysPatch(patch);
        break;

      case 'remove-public-keys':
        DocumentComposer.validateRemovePublicKeysPatch(patch);
        break;

      case 'add-service-endpoints':
        DocumentComposer.validateAddServiceEndpointsPatch(patch);
        break;

      case 'remove-service-endpoints':
        DocumentComposer.validateRemoveServiceEndpointsPatch(patch);
        break;

      case 'ietf-json-patch':
        DocumentComposer.validateIetfJsonPatch(patch);
        break;

      default:
        throw new SidetreeError(ErrorCode.DocumentComposerPatchMissingOrUnknownAction);
    }
  };

  DocumentComposer.validateIetfJsonPatch = function validateIetfJsonPatch(patch) {
    var patchProperties = Object.keys(patch);

    if (patchProperties.length !== 2) {
      throw new SidetreeError(ErrorCode.DocumentComposerPatchMissingOrUnknownProperty);
    }

    var error = jsonpatch.validate(patch.patches);

    if (error) {
      console.warn(error);
      throw new SidetreeError(error.name);
    }
  };

  DocumentComposer.validateAddPublicKeysPatch = function validateAddPublicKeysPatch(patch) {
    var patchProperties = Object.keys(patch);

    if (patchProperties.length !== 2) {
      throw new SidetreeError(ErrorCode.DocumentComposerPatchMissingOrUnknownProperty);
    }

    DocumentComposer.validatePublicKeys(patch.public_keys);
  };

  DocumentComposer.validatePublicKeys = function validatePublicKeys(public_keys) {
    if (!Array.isArray(public_keys)) {
      throw new SidetreeError(ErrorCode.DocumentComposerPublicKeysNotArray);
    }

    var publicKeyIdSet = new Set();

    for (var _iterator4 = _createForOfIteratorHelperLoose(public_keys), _step4; !(_step4 = _iterator4()).done;) {
      var publicKey = _step4.value;
      var publicKeyProperties = Object.keys(publicKey); // the expected fields are id, purpose, type and jwk

      if (publicKeyProperties.length !== 4) {
        throw new SidetreeError(ErrorCode.DocumentComposerPublicKeyMissingOrUnknownProperty);
      }

      if (typeof publicKey.jwk !== 'object' || Array.isArray(publicKey.jwk)) {
        throw new SidetreeError(ErrorCode.DocumentComposerPublicKeyJwkMissingOrIncorrectType);
      }

      if (typeof publicKey.type !== 'string') {
        throw new SidetreeError(ErrorCode.DocumentComposerPublicKeyTypeMissingOrIncorrectType);
      }

      DocumentComposer.validateId(publicKey.id); // 'id' must be unique

      if (publicKeyIdSet.has(publicKey.id)) {
        throw new SidetreeError(ErrorCode.DocumentComposerPublicKeyIdDuplicated);
      }

      publicKeyIdSet.add(publicKey.id);

      if (!Array.isArray(publicKey.purpose) || publicKey.purpose.length === 0) {
        throw new SidetreeError(ErrorCode.DocumentComposerPublicKeyPurposeMissingOrUnknown);
      }

      if (publicKey.purpose.length > Object.values(PublicKeyPurpose).length) {
        throw new SidetreeError(ErrorCode.DocumentComposerPublicKeyPurposeExceedsMaxLength);
      }

      var validPurposes = new Set(Object.values(PublicKeyPurpose)); // Purpose must be one of the valid ones in KeyPurpose

      for (var _iterator5 = _createForOfIteratorHelperLoose(publicKey.purpose), _step5; !(_step5 = _iterator5()).done;) {
        var purpose = _step5.value;

        if (!validPurposes.has(purpose)) {
          throw new SidetreeError(ErrorCode.DocumentComposerPublicKeyInvalidPurpose);
        }
      }
    }
  };

  DocumentComposer.validateRemovePublicKeysPatch = function validateRemovePublicKeysPatch(patch) {
    var patchProperties = Object.keys(patch);

    if (patchProperties.length !== 2) {
      throw new SidetreeError(ErrorCode.DocumentComposerPatchMissingOrUnknownProperty);
    }

    if (!Array.isArray(patch.public_keys)) {
      throw new SidetreeError(ErrorCode.DocumentComposerPatchPublicKeyIdsNotArray);
    }

    for (var _iterator6 = _createForOfIteratorHelperLoose(patch.public_keys), _step6; !(_step6 = _iterator6()).done;) {
      var publicKeyId = _step6.value;

      if (typeof publicKeyId !== 'string') {
        throw new SidetreeError(ErrorCode.DocumentComposerPatchPublicKeyIdNotString);
      }
    }
  }
  /**
   * validate update patch for removing service endpoints
   */
  ;

  DocumentComposer.validateRemoveServiceEndpointsPatch = function validateRemoveServiceEndpointsPatch(patch) {
    var patchProperties = Object.keys(patch);

    if (patchProperties.length !== 2) {
      throw new SidetreeError(ErrorCode.DocumentComposerPatchMissingOrUnknownProperty);
    }

    if (!Array.isArray(patch.ids)) {
      throw new SidetreeError(ErrorCode.DocumentComposerPatchServiceEndpointIdsNotArray);
    }

    for (var _iterator7 = _createForOfIteratorHelperLoose(patch.ids), _step7; !(_step7 = _iterator7()).done;) {
      var id = _step7.value;
      DocumentComposer.validateId(id);
    }
  }
  /**
   * Validates update patch for adding service endpoints.
   */
  ;

  DocumentComposer.validateAddServiceEndpointsPatch = function validateAddServiceEndpointsPatch(patch) {
    var patchProperties = Object.keys(patch);

    if (patchProperties.length !== 2) {
      throw new SidetreeError(ErrorCode.DocumentComposerPatchMissingOrUnknownProperty);
    }

    if (!Array.isArray(patch.service_endpoints)) {
      throw new SidetreeError(ErrorCode.DocumentComposerPatchServiceEndpointsNotArray);
    }

    DocumentComposer.validateServiceEndpoints(patch.service_endpoints);
  }
  /**
   * Validates and parses services endpoints
   * @param service_endpoints the service endpoints to validate and parse
   */
  ;

  DocumentComposer.validateServiceEndpoints = function validateServiceEndpoints(service_endpoints) {
    if (!Array.isArray(service_endpoints)) {
      throw new SidetreeError(ErrorCode.DocumentComposerPatchServiceEndpointsNotArray);
    }

    for (var _iterator8 = _createForOfIteratorHelperLoose(service_endpoints), _step8; !(_step8 = _iterator8()).done;) {
      var serviceEndpoint = _step8.value;
      var serviceEndpointProperties = Object.keys(serviceEndpoint);

      if (serviceEndpointProperties.length !== 3) {
        // type, id, and endpoint
        throw new SidetreeError(ErrorCode.DocumentComposerServiceEndpointMissingOrUnknownProperty);
      }

      DocumentComposer.validateId(serviceEndpoint.id);

      if (typeof serviceEndpoint.type !== 'string') {
        throw new SidetreeError(ErrorCode.DocumentComposerPatchServiceEndpointTypeNotString);
      }

      if (serviceEndpoint.type.length > 30) {
        throw new SidetreeError(ErrorCode.DocumentComposerPatchServiceEndpointTypeTooLong);
      }

      if (typeof serviceEndpoint.endpoint !== 'string') {
        throw new SidetreeError(ErrorCode.DocumentComposerPatchServiceEndpointServiceEndpointNotString);
      }

      if (serviceEndpoint.endpoint.length > 100) {
        throw new SidetreeError(ErrorCode.DocumentComposerPatchServiceEndpointServiceEndpointTooLong);
      }

      try {
        // just want to validate url, no need to assign to variable, it will throw if not valid
        // tslint:disable-next-line
        new URL(serviceEndpoint.endpoint);
      } catch (_unused) {
        throw new SidetreeError(ErrorCode.DocumentComposerPatchServiceEndpointServiceEndpointNotValidUrl);
      }
    }
  };

  DocumentComposer.validateId = function validateId(id) {
    if (typeof id !== 'string') {
      throw new SidetreeError(ErrorCode.DocumentComposerIdNotString, "ID not string: " + JSON.stringify(id) + " is of type '" + typeof id + "'");
    }

    if (id.length > 50) {
      throw new SidetreeError(ErrorCode.DocumentComposerIdTooLong);
    }

    if (!Encoder.isBase64UrlString(id)) {
      throw new SidetreeError(ErrorCode.DocumentComposerIdNotUsingBase64UrlCharacterSet);
    }
  }
  /**
   * Applies the given patches in order to the given document.
   * NOTE: Assumes no schema validation is needed, since validation should've already occurred at the time of the operation being parsed.
   * @returns The resultant document.
   */
  ;

  DocumentComposer.applyPatches = function applyPatches(document, patches) {
    // Loop through and apply all patches.
    var resultantDocument = document;

    for (var _iterator9 = _createForOfIteratorHelperLoose(patches), _step9; !(_step9 = _iterator9()).done;) {
      var patch = _step9.value;
      resultantDocument = DocumentComposer.applyPatchToDidDocument(resultantDocument, patch);
    }

    return resultantDocument;
  }
  /**
   * Applies the given patch to the given DID Document.
   */
  ;

  DocumentComposer.applyPatchToDidDocument = function applyPatchToDidDocument(document, patch) {
    if (patch.action === 'replace') {
      return patch.document;
    } else if (patch.action === 'add-public-keys') {
      return DocumentComposer.addPublicKeys(document, patch);
    } else if (patch.action === 'remove-public-keys') {
      return DocumentComposer.removePublicKeys(document, patch);
    } else if (patch.action === 'add-service-endpoints') {
      return DocumentComposer.addServiceEndpoints(document, patch);
    } else if (patch.action === 'remove-service-endpoints') {
      return DocumentComposer.removeServiceEndpoints(document, patch);
    } else if (patch.action === 'ietf-json-patch') {
      return DocumentComposer.applyIetfJsonPatch(document, patch);
    }
  };

  DocumentComposer.applyIetfJsonPatch = function applyIetfJsonPatch(document, patch) {
    var res = jsonpatch.applyPatch(_extends({}, document), patch.patches);
    return res.newDocument;
  }
  /**
   * Adds public keys to document.
   */
  ;

  DocumentComposer.addPublicKeys = function addPublicKeys(document, patch) {
    var publicKeyMap = new Map((document.public_keys || []).map(function (publicKey) {
      return [publicKey.id, publicKey];
    })); // Loop through all given public keys and add them if they don't exist already.

    for (var _iterator10 = _createForOfIteratorHelperLoose(patch.public_keys), _step10; !(_step10 = _iterator10()).done;) {
      var publicKey = _step10.value;
      // NOTE: If a key ID already exists, we will just replace the existing key.
      // Not throwing error will minimize the need (thus risk) of reusing exposed update reveal value.
      publicKeyMap.set(publicKey.id, publicKey);
    }

    document.public_keys = Array.from(publicKeyMap.entries()).map(function (pkm) {
      return pkm[1];
    });
    return document;
  }
  /**
   * Removes public keys from document.
   */
  ;

  DocumentComposer.removePublicKeys = function removePublicKeys(document, patch) {
    var publicKeyMap = new Map((document.public_keys || []).map(function (publicKey) {
      return [publicKey.id, publicKey];
    })); // Loop through all given public key IDs and delete them from the existing public key only if it is not a recovery key.

    for (var _iterator11 = _createForOfIteratorHelperLoose(patch.public_keys), _step11; !(_step11 = _iterator11()).done;) {
      var publicKey = _step11.value;
      var existingKey = publicKeyMap.get(publicKey);

      if (existingKey !== undefined) {
        publicKeyMap["delete"](publicKey);
      } // NOTE: Else we will just treat this key removal as a no-op.
      // Not throwing error will minimize the need (thus risk) of reusing exposed update reveal value.

    }

    document.public_keys = Array.from(publicKeyMap.entries()).map(function (pkm) {
      return pkm[1];
    });
    return document;
  };

  DocumentComposer.addServiceEndpoints = function addServiceEndpoints(document, patch) {
    var service_endpoints = patch.service_endpoints;

    if (document.service_endpoints === undefined) {
      // create a new array if service did not exist
      document.service_endpoints = [];
    }

    var idToIndexMapper = new Map(); // map all id and their index

    for (var idx in document.service_endpoints) {
      idToIndexMapper.set(document.service_endpoints[idx].id, idx);
    }

    for (var _iterator12 = _createForOfIteratorHelperLoose(service_endpoints), _step12; !(_step12 = _iterator12()).done;) {
      var serviceEndpoint = _step12.value;

      if (idToIndexMapper.has(serviceEndpoint.id)) {
        var _idx = idToIndexMapper.get(serviceEndpoint.id);

        document.service_endpoints[_idx] = serviceEndpoint;
      } else {
        document.service_endpoints.push(serviceEndpoint);
      }
    }

    return document;
  };

  DocumentComposer.removeServiceEndpoints = function removeServiceEndpoints(document, patch) {
    if (document.service_endpoints === undefined) {
      return document;
    }

    var idsToRemove = new Set(patch.ids);
    document.service_endpoints = document.service_endpoints.filter(function (serviceEndpoint) {
      return !idsToRemove.has(serviceEndpoint.id);
    });
    return document;
  };

  return DocumentComposer;
}();

/*
 * The code in this file originated from
 * @see https://github.com/decentralized-identity/sidetree
 * For the list of changes that was made to the original code
 * @see https://github.com/transmute-industries/sidetree.js/blob/master/reference-implementation-changes.md
 *
 * Copyright 2020 - Transmute Industries Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var yieldableJson = /*#__PURE__*/require('yieldable-json');
/**
 * A JSON library that performs operations asynchronously.
 */


var JsonAsync = /*#__PURE__*/function () {
  function JsonAsync() {}

  /**
   * Parses the given operation into a JavaScript object asynchronously,
   * to allow the event loop a chance to handle requests.
   */
  JsonAsync.parse = function parse(jsonData) {
    try {
      // Create a promise to wrap the successful/failed read events.
      var jsonParsePromise = new Promise(function (resolve, reject) {
        yieldableJson.parseAsync(jsonData, function (err, data) {
          if (err) {
            reject(err);
          } else {
            resolve(data);
          }
        });
      }); // Wait until the JSON parsing is completed.

      return Promise.resolve(jsonParsePromise);
    } catch (e) {
      return Promise.reject(e);
    }
  };

  return JsonAsync;
}();

/*
 * The code in this file originated from
 * @see https://github.com/decentralized-identity/sidetree
 * For the list of changes that was made to the original code
 * @see https://github.com/transmute-industries/sidetree.js/blob/master/reference-implementation-changes.md
 *
 * Copyright 2020 - Transmute Industries Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * A class that contains Sidetree operation utility methods.
 */

var OperationUtils = /*#__PURE__*/function () {
  function OperationUtils() {}

  /**
   * Parses the given encoded delta string into an internal `DeltaModel`.
   */
  OperationUtils.parseDelta = function parseDelta(deltaEncodedString) {
    try {
      if (typeof deltaEncodedString !== 'string') {
        throw new SidetreeError(ErrorCode.DeltaMissingOrNotString);
      }

      var deltaJsonString = Encoder.decodeAsString(deltaEncodedString);
      return Promise.resolve(JsonAsync.parse(deltaJsonString)).then(function (delta) {
        var properties = Object.keys(delta);

        if (properties.length !== 2) {
          throw new SidetreeError(ErrorCode.DeltaMissingOrUnknownProperty);
        }

        if (delta.patches === undefined) {
          throw new SidetreeError(ErrorCode.OperationDocumentPatchesMissing);
        } // Validate `patches` property using the DocumentComposer.


        DocumentComposer.validateDocumentPatches(delta.patches);
        var nextUpdateCommitment = Encoder.decodeAsBuffer(delta.update_commitment);
        Multihash.verifyHashComputedUsingLatestSupportedAlgorithm(nextUpdateCommitment);
        return {
          patches: delta.patches,
          update_commitment: delta.update_commitment
        };
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  return OperationUtils;
}();

/**
 * A class that represents a create operation.
 */

var CreateOperation = /*#__PURE__*/function () {
  /**
   * NOTE: should only be used by `parse()` and `parseObject()` else the contructed instance could be invalid.
   */
  function CreateOperation(operationBuffer, didUniqueSuffix, encodedSuffixData, suffixData, encodedDelta, delta) {
    this.didUniqueSuffix = didUniqueSuffix;
    this.type = OperationType.Create;
    this.operationBuffer = operationBuffer;
    this.encodedSuffixData = encodedSuffixData;
    this.suffixData = suffixData;
    this.encodedDelta = encodedDelta;
    this.delta = delta;
  }
  /**
   * Computes the DID unique suffix given the encoded suffix data string.
   */


  CreateOperation.computeDidUniqueSuffix = function computeDidUniqueSuffix(encodedSuffixData) {
    var suffixDataBuffer = Encoder.decodeAsBuffer(encodedSuffixData);
    var multihash = Multihash.hash(suffixDataBuffer);
    var encodedMultihash = Encoder.encode(multihash);
    return encodedMultihash;
  }
  /**
   * Parses the given input as a create operation entry in the anchor file.
   */
  ;

  CreateOperation.parseOperationFromAnchorFile = function parseOperationFromAnchorFile(input) {
    try {
      // Issue #442 - Replace `operationBuffer` in `OperationModel` and `AnchoredOperationModel` with actual operation request
      var operationBuffer = Buffer.from(JSON.stringify(input));
      return Promise.resolve(CreateOperation.parseObject(input, operationBuffer, true));
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * Parses the given buffer as a `CreateOperation`.
   */
  ;

  CreateOperation.parse = function parse(operationBuffer) {
    try {
      var operationJsonString = operationBuffer.toString();
      return Promise.resolve(JsonAsync.parse(operationJsonString)).then(function (operationObject) {
        return Promise.resolve(CreateOperation.parseObject(operationObject, operationBuffer, false));
      });
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * Parses the given operation object as a `CreateOperation`.
   * The `operationBuffer` given is assumed to be valid and is assigned to the `operationBuffer` directly.
   * NOTE: This method is purely intended to be used as an optimization method over the `parse` method in that
   * JSON parsing is not required to be performed more than once when an operation buffer of an unknown operation type is given.
   * @param anchorFileMode If set to true, then `delta` and `type` properties are expected to be absent.
   */
  ;

  CreateOperation.parseObject = function parseObject(operationObject, operationBuffer, anchorFileMode) {
    try {
      var expectedPropertyCount = 3;

      if (anchorFileMode) {
        expectedPropertyCount = 1;
      }

      var properties = Object.keys(operationObject);

      if (properties.length !== expectedPropertyCount) {
        throw new SidetreeError(ErrorCode.CreateOperationMissingOrUnknownProperty);
      }

      var encodedSuffixData = operationObject.suffix_data;
      return Promise.resolve(CreateOperation.parseSuffixData(encodedSuffixData)).then(function (suffixData) {
        var _exit = false;

        function _temp3(_result) {
          if (_exit) return _result;
          var didUniqueSuffix = CreateOperation.computeDidUniqueSuffix(operationObject.suffix_data);
          return new CreateOperation(operationBuffer, didUniqueSuffix, encodedSuffixData, suffixData, encodedDelta, delta);
        }

        // If not in anchor file mode, we need to validate `type` and `delta` properties.
        var encodedDelta = undefined;
        var delta = undefined;

        var _temp2 = function () {
          if (!anchorFileMode) {
            if (operationObject.type !== OperationType.Create) {
              throw new SidetreeError(ErrorCode.CreateOperationTypeIncorrect);
            }

            encodedDelta = operationObject.delta;

            var _temp4 = _catch(function () {
              return Promise.resolve(OperationUtils.parseDelta(operationObject.delta)).then(function (_OperationUtils$parse) {
                delta = _OperationUtils$parse;
              });
            }, function () {});

            if (_temp4 && _temp4.then) return _temp4.then(function () {});
          }
        }();

        return _temp2 && _temp2.then ? _temp2.then(_temp3) : _temp3(_temp2);
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  CreateOperation.parseSuffixData = function parseSuffixData(suffixDataEncodedString) {
    try {
      if (typeof suffixDataEncodedString !== 'string') {
        throw new SidetreeError(ErrorCode.CreateOperationSuffixDataMissingOrNotString);
      }

      var suffixDataJsonString = Encoder.decodeAsString(suffixDataEncodedString);
      return Promise.resolve(JsonAsync.parse(suffixDataJsonString)).then(function (suffixData) {
        var properties = Object.keys(suffixData);

        if (properties.length !== 2) {
          throw new SidetreeError(ErrorCode.CreateOperationSuffixDataMissingOrUnknownProperty);
        }

        var delta_hash = Encoder.decodeAsBuffer(suffixData.delta_hash);
        var nextRecoveryCommitment = Encoder.decodeAsBuffer(suffixData.recovery_commitment);
        Multihash.verifyHashComputedUsingLatestSupportedAlgorithm(delta_hash);
        Multihash.verifyHashComputedUsingLatestSupportedAlgorithm(nextRecoveryCommitment);
        return {
          delta_hash: suffixData.delta_hash,
          recovery_commitment: suffixData.recovery_commitment
        };
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  return CreateOperation;
}();

/*
 * The code in this file originated from
 * @see https://github.com/decentralized-identity/sidetree
 * For the list of changes that was made to the original code
 * @see https://github.com/transmute-industries/sidetree.js/blob/master/reference-implementation-changes.md
 *
 * Copyright 2020 - Transmute Industries Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Class containing reusable JWK operations.
 */

var Jwk = /*#__PURE__*/function () {
  function Jwk() {}

  /**
   * Generates ED25519 key pair.
   * Mainly used for testing.
   * @returns [publicKey, privateKey]
   */
  Jwk.generateEd25519KeyPair = function generateEd25519KeyPair() {
    try {
      return Promise.resolve(JWK.generate('OKP', 'Ed25519')).then(function (keyPair) {
        var privateKey = keyPair.toJWK(true);
        var publicKey = keyPair.toJWK(false);
        return [publicKey, privateKey];
      });
    } catch (e) {
      return Promise.reject(e);
    }
  } // Helper method to generate keys from a mnemonic
  ;

  Jwk.getBufferAtIndex = function getBufferAtIndex(mnemonic, index) {
    try {
      return Promise.resolve(mnemonicToSeed(mnemonic)).then(function (seed) {
        var root = hdkey.fromMasterSeed(seed); // TODO: 60 is specific to ethereum, we could use another value unique to sidetree

        var hdPath = "m/44'/60'/0'/0/" + index;
        var addrNode = root.derive(hdPath);
        return addrNode.privateKey;
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  Jwk.generateEd25519KeyPairFromMnemonic = function generateEd25519KeyPairFromMnemonic(mnemonic, index) {
    try {
      return Promise.resolve(Jwk.getBufferAtIndex(mnemonic, index)).then(function (privateKeyBuffer) {
        return Promise.resolve(Ed25519KeyPair.generate({
          seed: privateKeyBuffer
        })).then(function (keyPair) {
          var ed25519KeyPair = new Ed25519KeyPair(keyPair);
          return Promise.resolve(ed25519KeyPair.toJwk(false)).then(function (publicKeyJwk) {
            return Promise.resolve(ed25519KeyPair.toJwk(true)).then(function (privateKeyJwk) {
              return [publicKeyJwk, privateKeyJwk];
            });
          });
        });
      });
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * Generates SECP256K1 key pair.
   * Mainly used for testing.
   * @returns [publicKey, privateKey]
   */
  ;

  Jwk.generateSecp256k1KeyPair = function generateSecp256k1KeyPair() {
    try {
      return Promise.resolve(JWK.generate('EC', 'secp256k1')).then(function (keyPair) {
        var publicKey = keyPair.toJWK(false);
        var privateKey = keyPair.toJWK(true);
        return [publicKey, privateKey];
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  Jwk.generateJwkKeyPairFromMnemonic = function generateJwkKeyPairFromMnemonic(keyType, mnemonic, index) {
    try {
      var _this2 = this;

      switch (keyType) {
        case 'secp256k1':
          return Promise.resolve(_this2.generateSecp256k1KeyPairFromMnemonic(mnemonic, index));

        case 'ed25519':
          return Promise.resolve(_this2.generateEd25519KeyPairFromMnemonic(mnemonic, index));

        default:
          throw new Error('Invalid key type');
      }
    } catch (e) {
      return Promise.reject(e);
    }
  };

  Jwk.generateSecp256k1KeyPairFromMnemonic = function generateSecp256k1KeyPairFromMnemonic(mnemonic, index) {
    try {
      return Promise.resolve(Jwk.getBufferAtIndex(mnemonic, index)).then(function (privateKeyBuffer) {
        var publicKeyJwk = from(privateKeyBuffer, 'blk').toJwk('public');
        publicKeyJwk.crv = 'secp256k1';
        var privateKeyJwk = from(privateKeyBuffer, 'blk').toJwk('private');
        privateKeyJwk.crv = 'secp256k1';
        return [publicKeyJwk, privateKeyJwk];
      });
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * Validates the given key is a public key in JWK format allowed by Sidetree.
   * @throws SidetreeError if given object is not a key in JWK format allowed by Sidetree.
   */
  ;

  Jwk.validatePublicJwk = function validatePublicJwk(jwk) {
    if (jwk === undefined) {
      throw new SidetreeError(ErrorCode.JwkUndefined);
    } // TODO: Check validity with JSON schema...


    var allowedProperties = new Set(['kty', 'crv', 'x', 'y', 'kid']);

    for (var property in jwk) {
      if (!allowedProperties.has(property)) {
        throw new SidetreeError(ErrorCode.JwkHasUnknownProperty);
      }
    }

    switch (jwk.crv) {
      case 'Ed25519':
        if (jwk.kty !== 'OKP') {
          throw new SidetreeError(ErrorCode.JwkMissingOrInvalidKty);
        }

        if (typeof jwk.x !== 'string') {
          throw new SidetreeError(ErrorCode.JwkMissingOrInvalidTypeX);
        }

        break;

      case 'secp256k1':
        if (jwk.kty !== 'EC') {
          throw new SidetreeError(ErrorCode.JwkMissingOrInvalidKty);
        }

        if (typeof jwk.x !== 'string') {
          throw new SidetreeError(ErrorCode.JwkMissingOrInvalidTypeX);
        }

        if (typeof jwk.y !== 'string') {
          throw new SidetreeError(ErrorCode.JwkMissingOrInvalidTypeY);
        }

        break;

      default:
        throw new SidetreeError(ErrorCode.JwkMissingOrInvalidCrv);
    }
  }
  /**
   * Gets the public key given the private ES256K key.
   * Mainly used for testing purposes.
   */
  ;

  Jwk.getCurve25519PublicKey = function getCurve25519PublicKey(privateKey) {
    var keyCopy = Object.assign({}, privateKey); // Delete the private key portion.

    delete keyCopy.d;
    return keyCopy;
  };

  return Jwk;
}();

/**
 * Class containing reusable JWS operations.
 */

var Jws = /*#__PURE__*/function () {
  /**
   * Constructs a JWS object.
   * @param compactJws Input should be a compact JWS string.
   */
  function Jws(compactJws) {
    if (typeof compactJws !== 'string') {
      throw new SidetreeError(ErrorCode.JwsCompactJwsNotString);
    }

    var parts = compactJws.split('.');

    if (parts.length !== 3) {
      throw new SidetreeError(ErrorCode.JwsCompactJwsInvalid);
    }

    var protectedHeader = parts[0];
    var payload = parts[1];
    var signature = parts[2];
    var decodedProtectedHeadJsonString = Encoder.decodeBase64UrlAsString(protectedHeader);
    var decodedProtectedHeader = JSON.parse(decodedProtectedHeadJsonString);
    var expectedHeaderPropertyCount = 1; // By default we must have header property is `alg`.

    var headerProperties = Object.keys(decodedProtectedHeader);

    if (headerProperties.length !== expectedHeaderPropertyCount) {
      throw new SidetreeError(ErrorCode.JwsProtectedHeaderMissingOrUnknownProperty);
    } // Protected header must contain 'alg' property with value 'EdDSA'.


    if (decodedProtectedHeader.alg !== 'EdDSA' && decodedProtectedHeader.alg !== 'ES256K') {
      throw new SidetreeError(ErrorCode.JwsProtectedHeaderMissingOrIncorrectAlg);
    } // Must contain Base64URL string 'signature' property.


    if (!Encoder.isBase64UrlString(signature)) {
      throw new SidetreeError(ErrorCode.JwsSignatureNotBase64UrlString);
    } // Must contain Base64URL string 'payload' property.


    if (!Encoder.isBase64UrlString(payload)) {
      throw new SidetreeError(ErrorCode.JwsPayloadNotBase64UrlString);
    }

    this["protected"] = protectedHeader;
    this.payload = payload;
    this.signature = signature;
  }
  /**
   * Converts this object to a compact JWS string.
   */


  var _proto = Jws.prototype;

  _proto.toCompactJws = function toCompactJws() {
    return Jws.createCompactJws(this["protected"], this.payload, this.signature);
  }
  /**
   * Verifies the JWS signature.
   * @returns true if signature is successfully verified, false otherwise.
   */
  ;

  _proto.verifySignature = function verifySignature(publicKey) {
    try {
      var _this2 = this;

      return Promise.resolve(Jws.verifySignature(_this2["protected"], _this2.payload, _this2.signature, publicKey));
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * Verifies the JWS signature.
   * @returns true if signature is successfully verified, false otherwise.
   */
  ;

  Jws.verifySignature = function verifySignature(encodedProtectedHeader, encodedPayload, signature, publicKey) {
    try {
      var jwsSigningInput = encodedProtectedHeader + '.' + encodedPayload + '.' + signature;
      return Promise.resolve(Jws.verifyCompactJws(jwsSigningInput, publicKey));
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * Verifies the compact JWS string using the given JWK key.
   * @returns true if signature is valid; else otherwise.
   */
  ;

  Jws.verifyCompactJws = function verifyCompactJws(compactJws, jwk) {
    try {
      var _exit2 = false;
      return Promise.resolve(_catch(function () {
        var _temp = function () {
          if (jwk.crv === 'Ed25519') {
            return Promise.resolve(EdDSA.verify(compactJws, jwk)).then(function () {});
          } else return function () {
            if (jwk.crv === 'secp256k1') {
              return Promise.resolve(ES256K.verify(compactJws, jwk)).then(function () {});
            } else {
              _exit2 = true;
              return false;
            }
          }();
        }();

        return _temp && _temp.then ? _temp.then(function (_result) {
          return _exit2 ? _result : true;
        }) : _exit2 ? _temp : true;
      }, function (error) {
        console.log("Input '" + compactJws + "' failed signature verification: " + SidetreeError.createFromError(ErrorCode.JwsFailedSignatureValidation, error));
        return false;
      }));
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * Signs the given payload as a compact JWS string.
   * This is mainly used by tests to create valid test data.
   */
  ;

  Jws.signAsCompactJws = function signAsCompactJws(payload, privateKey, protectedHeader) {
    try {
      var _temp4 = function _temp4(_result3) {
        return _exit4 ? _result3 : Promise.resolve(EdDSA.sign(payload, privateKey, header));
      };

      var _exit4 = false;
      var alg;

      if (protectedHeader && protectedHeader.alg) {
        alg = protectedHeader.alg;
      } else {
        if (privateKey.crv === 'Ed25519') {
          alg = 'EdDSA';
        } else {
          alg = 'ES256K';
        }
      }

      var header = _extends({}, protectedHeader, {
        alg: alg
      });

      var _temp5 = function () {
        if (privateKey.crv === 'secp256k1') {
          _exit4 = true;
          return Promise.resolve(ES256K.sign(payload, privateKey, header));
        }
      }();

      return Promise.resolve(_temp5 && _temp5.then ? _temp5.then(_temp4) : _temp4(_temp5));
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * Parses the input as a `Jws` object.
   */
  ;

  Jws.parseCompactJws = function parseCompactJws(compactJws) {
    return new Jws(compactJws);
  }
  /**
   * Creates a compact JWS string using the given input. No string validation is performed.
   */
  ;

  Jws.createCompactJws = function createCompactJws(protectedHeader, payload, signature) {
    return protectedHeader + '.' + payload + '.' + signature;
  };

  return Jws;
}();

/*
 * The code in this file originated from
 * @see https://github.com/decentralized-identity/sidetree
 * For the list of changes that was made to the original code
 * @see https://github.com/transmute-industries/sidetree.js/blob/master/reference-implementation-changes.md
 *
 * Copyright 2020 - Transmute Industries Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * A class that represents a deactivate operation.
 */

var DeactivateOperation = /*#__PURE__*/function () {
  /**
   * NOTE: should only be used by `parse()` and `parseObject()` else the contructed instance could be invalid.
   */
  function DeactivateOperation(operationBuffer, didUniqueSuffix, signedDataJws, signedData) {
    this.operationBuffer = operationBuffer;
    this.type = OperationType.Deactivate;
    this.didUniqueSuffix = didUniqueSuffix;
    this.signedDataJws = signedDataJws;
    this.signedData = signedData;
  }
  /**
   * Parses the given input as a deactivate operation entry in the anchor file.
   */


  DeactivateOperation.parseOperationFromAnchorFile = function parseOperationFromAnchorFile(input) {
    try {
      var operationBuffer = Buffer.from(JSON.stringify(input));
      return Promise.resolve(DeactivateOperation.parseObject(input, operationBuffer, true));
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * Parses the given buffer as a `UpdateOperation`.
   */
  ;

  DeactivateOperation.parse = function parse(operationBuffer) {
    try {
      var operationJsonString = operationBuffer.toString();
      return Promise.resolve(JsonAsync.parse(operationJsonString)).then(function (operationObject) {
        return Promise.resolve(DeactivateOperation.parseObject(operationObject, operationBuffer, false));
      });
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * Parses the given operation object as a `DeactivateOperation`.
   * The `operationBuffer` given is assumed to be valid and is assigned to the `operationBuffer` directly.
   * NOTE: This method is purely intended to be used as an optimization method over the `parse` method in that
   * JSON parsing is not required to be performed more than once when an operation buffer of an unknown operation type is given.
   * @param anchorFileMode If set to true, then `type` is expected to be absent.
   */
  ;

  DeactivateOperation.parseObject = function parseObject(operationObject, operationBuffer, anchorFileMode) {
    try {
      var expectedPropertyCount = 3;

      if (anchorFileMode) {
        expectedPropertyCount = 2;
      }

      var properties = Object.keys(operationObject);

      if (properties.length !== expectedPropertyCount) {
        throw new SidetreeError(ErrorCode.DeactivateOperationMissingOrUnknownProperty);
      }

      if (typeof operationObject.did_suffix !== 'string') {
        throw new SidetreeError(ErrorCode.DeactivateOperationMissingOrInvalidDidUniqueSuffix);
      }

      var signedDataJws = Jws.parseCompactJws(operationObject.signed_data);
      return Promise.resolve(DeactivateOperation.parseSignedDataPayload(signedDataJws.payload, operationObject.did_suffix)).then(function (signedData) {
        // If not in anchor file mode, we need to validate `type` property.
        if (!anchorFileMode) {
          if (operationObject.type !== OperationType.Deactivate) {
            throw new SidetreeError(ErrorCode.DeactivateOperationTypeIncorrect);
          }
        }

        return new DeactivateOperation(operationBuffer, operationObject.did_suffix, signedDataJws, signedData);
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  DeactivateOperation.parseSignedDataPayload = function parseSignedDataPayload(deltaEncodedString, expectedDidUniqueSuffix) {
    try {
      var signedDataJsonString = Encoder.decodeAsString(deltaEncodedString);
      return Promise.resolve(JsonAsync.parse(signedDataJsonString)).then(function (signedData) {
        var properties = Object.keys(signedData);

        if (properties.length !== 2) {
          throw new SidetreeError(ErrorCode.DeactivateOperationSignedDataMissingOrUnknownProperty);
        }

        if (signedData.did_suffix !== expectedDidUniqueSuffix) {
          throw new SidetreeError(ErrorCode.DeactivateOperationSignedDidUniqueSuffixMismatch);
        }

        Jwk.validatePublicJwk(signedData.recovery_key);
        return {
          didSuffix: signedData.did_suffix,
          recovery_key: signedData.recovery_key
        };
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  return DeactivateOperation;
}();

/**
 * A class that represents a recover operation.
 */

var RecoverOperation = /*#__PURE__*/function () {
  /**
   * NOTE: should only be used by `parse()` and `parseObject()` else the constructed instance could be invalid.
   */
  function RecoverOperation(operationBuffer, didUniqueSuffix, signedDataJws, signedData, encodedDelta, delta) {
    this.operationBuffer = operationBuffer;
    this.type = OperationType.Recover;
    this.didUniqueSuffix = didUniqueSuffix;
    this.signedDataJws = signedDataJws;
    this.signedData = signedData;
    this.encodedDelta = encodedDelta;
    this.delta = delta;
  }
  /**
   * Parses the given input as a recover operation entry in the anchor file.
   */


  RecoverOperation.parseOperationFromAnchorFile = function parseOperationFromAnchorFile(input) {
    try {
      var operationBuffer = Buffer.from(JSON.stringify(input));
      return Promise.resolve(RecoverOperation.parseObject(input, operationBuffer, true));
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * Parses the given buffer as a `UpdateOperation`.
   */
  ;

  RecoverOperation.parse = function parse(operationBuffer) {
    try {
      var operationJsonString = operationBuffer.toString();
      return Promise.resolve(JsonAsync.parse(operationJsonString)).then(function (operationObject) {
        return Promise.resolve(RecoverOperation.parseObject(operationObject, operationBuffer, false));
      });
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * Parses the given operation object as a `RecoverOperation`.
   * The `operationBuffer` given is assumed to be valid and is assigned to the `operationBuffer` directly.
   * NOTE: This method is purely intended to be used as an optimization method over the `parse` method in that
   * JSON parsing is not required to be performed more than once when an operation buffer of an unknown operation type is given.
   * @param anchorFileMode If set to true, then `delta` and `type` properties are expected to be absent.
   */
  ;

  RecoverOperation.parseObject = function parseObject(operationObject, operationBuffer, anchorFileMode) {
    try {
      var expectedPropertyCount = 4;

      if (anchorFileMode) {
        expectedPropertyCount = 2;
      }

      var properties = Object.keys(operationObject);

      if (properties.length !== expectedPropertyCount) {
        throw new SidetreeError(ErrorCode.RecoverOperationMissingOrUnknownProperty);
      }

      if (typeof operationObject.did_suffix !== 'string') {
        throw new SidetreeError(ErrorCode.RecoverOperationMissingOrInvalidDidUniqueSuffix);
      }

      var signedDataJws = Jws.parseCompactJws(operationObject.signed_data);
      return Promise.resolve(RecoverOperation.parseSignedDataPayload(signedDataJws.payload)).then(function (signedData) {
        var _exit = false;

        function _temp3(_result) {
          return _exit ? _result : new RecoverOperation(operationBuffer, operationObject.did_suffix, signedDataJws, signedData, encodedDelta, delta);
        }

        // If not in anchor file mode, we need to validate `type` and `delta` properties.
        var encodedDelta = undefined;
        var delta = undefined;

        var _temp2 = function () {
          if (!anchorFileMode) {
            if (operationObject.type !== OperationType.Recover) {
              throw new SidetreeError(ErrorCode.RecoverOperationTypeIncorrect);
            }

            encodedDelta = operationObject.delta;

            var _temp4 = _catch(function () {
              return Promise.resolve(OperationUtils.parseDelta(operationObject.delta)).then(function (_OperationUtils$parse) {
                delta = _OperationUtils$parse;
              });
            }, function () {});

            if (_temp4 && _temp4.then) return _temp4.then(function () {});
          }
        }();

        return _temp2 && _temp2.then ? _temp2.then(_temp3) : _temp3(_temp2);
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  RecoverOperation.parseSignedDataPayload = function parseSignedDataPayload(signedDataEncodedString) {
    try {
      var signedDataJsonString = Encoder.decodeAsString(signedDataEncodedString);
      return Promise.resolve(JsonAsync.parse(signedDataJsonString)).then(function (signedData) {
        var properties = Object.keys(signedData); // TODO: JSON Schema instead of property count type checking...

        if (properties.length !== 3) {
          throw new SidetreeError(ErrorCode.RecoverOperationSignedDataMissingOrUnknownProperty);
        }

        Jwk.validatePublicJwk(signedData.recovery_key);
        var delta_hash = Encoder.decodeAsBuffer(signedData.delta_hash);
        Multihash.verifyHashComputedUsingLatestSupportedAlgorithm(delta_hash);
        var nextRecoveryCommitmentHash = Encoder.decodeAsBuffer(signedData.recovery_commitment);
        Multihash.verifyHashComputedUsingLatestSupportedAlgorithm(nextRecoveryCommitmentHash);
        return {
          delta_hash: signedData.delta_hash,
          recovery_key: signedData.recovery_key,
          recovery_commitment: signedData.recovery_commitment
        };
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  return RecoverOperation;
}();

/**
 * Class containing Anchor File related operations.
 */

var AnchorFile = /*#__PURE__*/function () {
  /**
   * Class that represents an anchor file.
   * NOTE: this class is introduced as an internal structure in replacement to `AnchorFileModel`
   * to keep useful metadata so that repeated computation can be avoided.
   */
  function AnchorFile(model, didUniqueSuffixes, createOperations, recoverOperations, deactivateOperations) {
    this.model = model;
    this.didUniqueSuffixes = didUniqueSuffixes;
    this.createOperations = createOperations;
    this.recoverOperations = recoverOperations;
    this.deactivateOperations = deactivateOperations;
  }
  /**
   * Parses and validates the given anchor file buffer.
   * @throws `SidetreeError` if failed parsing or validation.
   */


  AnchorFile.parse = function parse(anchorFileBuffer) {
    try {
      var _temp14 = function _temp14(_result) {
        var _exit2 = false;
        if (_exit6) return _result;

        function _temp11(_result2) {
          var _exit3 = false;
          if (_exit2) return _result2;

          function _temp9(_result3) {
            var _exit4 = false;
            if (_exit3) return _result3;

            function _temp7(_result4) {
              var _exit5 = false;
              if (_exit4) return _result4;

              function _temp5(_result5) {
                if (_exit5) return _result5;

                if (ArrayMethods.hasDuplicates(didUniqueSuffixes)) {
                  throw new SidetreeError(ErrorCode.AnchorFileMultipleOperationsForTheSameDid);
                }

                var anchorFile = new AnchorFile(anchorFileModel, didUniqueSuffixes, createOperations, recoverOperations, deactivateOperations);
                return anchorFile;
              }

              // Validate `deactivate` if exists.
              var deactivateOperations = [];

              var _temp4 = function () {
                if (operations.deactivate !== undefined) {
                  if (!Array.isArray(operations.deactivate)) {
                    throw new SidetreeError(ErrorCode.AnchorFileDeactivatePropertyNotArray);
                  } // Validate every operation.


                  var _temp16 = _forOf(operations.deactivate, function (operation) {
                    return Promise.resolve(DeactivateOperation.parseOperationFromAnchorFile(operation)).then(function (deactivateOperation) {
                      deactivateOperations.push(deactivateOperation);
                      didUniqueSuffixes.push(deactivateOperation.didUniqueSuffix);
                    });
                  });

                  if (_temp16 && _temp16.then) return _temp16.then(function () {});
                }
              }();

              return _temp4 && _temp4.then ? _temp4.then(_temp5) : _temp5(_temp4);
            }

            // Validate `recover` if exists.
            var recoverOperations = [];

            var _temp6 = function () {
              if (operations.recover !== undefined) {
                if (!Array.isArray(operations.recover)) {
                  throw new SidetreeError(ErrorCode.AnchorFileRecoverPropertyNotArray);
                } // Validate every recover operation.


                var _temp17 = _forOf(operations.recover, function (operation) {
                  return Promise.resolve(RecoverOperation.parseOperationFromAnchorFile(operation)).then(function (recoverOperation) {
                    recoverOperations.push(recoverOperation);
                    didUniqueSuffixes.push(recoverOperation.didUniqueSuffix);
                  });
                });

                if (_temp17 && _temp17.then) return _temp17.then(function () {});
              }
            }();

            return _temp6 && _temp6.then ? _temp6.then(_temp7) : _temp7(_temp6);
          }

          var allowedProperties = new Set(['map_file_uri', 'operations', 'writer_lock_id']);

          for (var property in anchorFileModel) {
            if (!allowedProperties.has(property)) {
              throw new SidetreeError(ErrorCode.AnchorFileHasUnknownProperty);
            }
          }

          if (!Object.prototype.hasOwnProperty.call(anchorFileModel, 'map_file_uri')) {
            throw new SidetreeError(ErrorCode.AnchorFileMapFileHashMissing);
          }

          if (!Object.prototype.hasOwnProperty.call(anchorFileModel, 'operations')) {
            throw new SidetreeError(ErrorCode.AnchorFileMissingOperationsProperty);
          }

          if (Object.prototype.hasOwnProperty.call(anchorFileModel, 'writer_lock_id') && typeof anchorFileModel.writer_lock_id !== 'string') {
            throw new SidetreeError(ErrorCode.AnchorFileWriterLockIPropertyNotString);
          } // Map file hash validations.


          var mapFileUri = anchorFileModel.map_file_uri;

          if (typeof mapFileUri !== 'string') {
            throw new SidetreeError(ErrorCode.AnchorFileMapFileHashNotString);
          }

          var allowedOperationsProperties = new Set(['create', 'recover', 'deactivate']);
          var operations = anchorFileModel.operations;

          for (var _property in operations) {
            if (!allowedOperationsProperties.has(_property)) {
              throw new SidetreeError(ErrorCode.AnchorFileUnexpectedPropertyInOperations, "Unexpected property " + _property + " in 'operations' property in anchor file.");
            }
          } // Will be populated for later validity check.


          var didUniqueSuffixes = []; // Validate `create` if exists.

          var createOperations = [];

          var _temp8 = function () {
            if (operations.create !== undefined) {
              if (!Array.isArray(operations.create)) {
                throw new SidetreeError(ErrorCode.AnchorFileCreatePropertyNotArray);
              } // Validate every create operation.


              var _temp18 = _forOf(operations.create, function (operation) {
                return Promise.resolve(CreateOperation.parseOperationFromAnchorFile(operation)).then(function (createOperation) {
                  createOperations.push(createOperation);
                  didUniqueSuffixes.push(createOperation.didUniqueSuffix);
                });
              });

              if (_temp18 && _temp18.then) return _temp18.then(function () {});
            }
          }();

          return _temp8 && _temp8.then ? _temp8.then(_temp9) : _temp9(_temp8);
        }

        var anchorFileModel;

        var _temp10 = _catch(function () {
          return Promise.resolve(JsonAsync.parse(anchorFileDecompressedBuffer)).then(function (_JsonAsync$parse) {
            anchorFileModel = _JsonAsync$parse;
          });
        }, function (e) {
          throw SidetreeError.createFromError(ErrorCode.AnchorFileNotJson, e);
        });

        return _temp10 && _temp10.then ? _temp10.then(_temp11) : _temp11(_temp10);
      };

      var _exit6 = false;
      var anchorFileDecompressedBuffer;

      var _temp15 = _catch(function () {
        return Promise.resolve(Compressor.decompress(anchorFileBuffer)).then(function (_Compressor$decompres) {
          anchorFileDecompressedBuffer = _Compressor$decompres;
        });
      }, function (e) {
        throw SidetreeError.createFromError(ErrorCode.AnchorFileDecompressionFailure, e);
      });

      return Promise.resolve(_temp15 && _temp15.then ? _temp15.then(_temp14) : _temp14(_temp15));
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * Creates an `AnchorFileModel`.
   */
  ;

  AnchorFile.createModel = function createModel(writerLockId, mapFileHash, createOperationArray, recoverOperationArray, deactivateOperationArray) {
    try {
      var _createOperations = createOperationArray.map(function (operation) {
        return {
          suffix_data: operation.encodedSuffixData
        };
      });

      var _recoverOperations = recoverOperationArray.map(function (operation) {
        return {
          did_suffix: operation.didUniqueSuffix,
          signed_data: operation.signedDataJws.toCompactJws()
        };
      });

      var _deactivateOperations = deactivateOperationArray.map(function (operation) {
        return {
          did_suffix: operation.didUniqueSuffix,
          signed_data: operation.signedDataJws.toCompactJws()
        };
      });

      var _anchorFileModel = {
        writer_lock_id: writerLockId,
        map_file_uri: mapFileHash,
        operations: {
          create: _createOperations,
          recover: _recoverOperations,
          deactivate: _deactivateOperations
        }
      };
      return Promise.resolve(_anchorFileModel);
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * Creates an anchor file buffer.
   */
  ;

  AnchorFile.createBuffer = function createBuffer(writerLockId, mapFileHash, createOperations, recoverOperations, deactivateOperations) {
    try {
      return Promise.resolve(AnchorFile.createModel(writerLockId, mapFileHash, createOperations, recoverOperations, deactivateOperations)).then(function (anchorFileModel) {
        var anchorFileJson = JSON.stringify(anchorFileModel);
        var anchorFileBuffer = Buffer.from(anchorFileJson);
        return Compressor.compress(anchorFileBuffer);
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  return AnchorFile;
}();

/**
 * Class that performs periodic writing of batches of Sidetree operations to CAS and blockchain.
 */

var BatchScheduler = /*#__PURE__*/function () {
  function BatchScheduler(versionManager, blockchain, batchingIntervalInSeconds) {
    this.versionManager = versionManager;
    this.blockchain = blockchain;
    this.batchingIntervalInSeconds = batchingIntervalInSeconds;
    /**
     * Denotes if the periodic batch writing should continue to occur.
     * Used mainly for test purposes.
     */

    this.continuePeriodicBatchWriting = false;
  }
  /**
   * The function that starts periodically anchoring operation batches to blockchain.
   */


  var _proto = BatchScheduler.prototype;

  _proto.startPeriodicBatchWriting = function startPeriodicBatchWriting() {
    var _this = this;

    this.continuePeriodicBatchWriting = true;
    setImmediate(function () {
      try {
        return Promise.resolve(_this.writeOperationBatch());
      } catch (e) {
        return Promise.reject(e);
      }
    });
  }
  /**
   * Stops periodic batch writing.
   * Mainly used for test purposes.
   */
  ;

  _proto.stopPeriodicBatchWriting = function stopPeriodicBatchWriting() {
    console.info("Stopped periodic batch writing.");
    this.continuePeriodicBatchWriting = false;
  }
  /**
   * Processes the operations in the queue.
   */
  ;

  _proto.writeOperationBatch = function writeOperationBatch() {
    try {
      var _this3 = this;

      var endTimer = timeSpan(); // For calcuating time taken to write operations.

      var _temp2 = _finallyRethrows(function () {
        return _catch(function () {
          console.info('Start operation batch writing...'); // Get the correct version of the `BatchWriter`.

          var currentTime = _this3.blockchain.approximateTime.time;

          var batchWriter = _this3.versionManager.getBatchWriter(currentTime);

          return Promise.resolve(batchWriter.write()).then(function () {});
        }, function (error) {
          console.error('Unexpected and unhandled error during batch writing, investigate and fix:');
          console.error(error);
        });
      }, function (_wasThrown, _result) {
        console.info("End batch writing. Duration: " + endTimer.rounded() + " ms.");

        if (_this3.continuePeriodicBatchWriting) {
          console.info("Waiting for " + _this3.batchingIntervalInSeconds + " seconds before writing another batch.");
          setTimeout(function () {
            try {
              return Promise.resolve(_this3.writeOperationBatch());
            } catch (e) {
              return Promise.reject(e);
            }
          }, _this3.batchingIntervalInSeconds * 1000);
        }

        if (_wasThrown) throw _result;
        return _result;
      });

      return Promise.resolve(_temp2 && _temp2.then ? _temp2.then(function () {}) : void 0);
    } catch (e) {
      return Promise.reject(e);
    }
  };

  return BatchScheduler;
}();

/**
 * Defines schema of a Chunk File and its related operations.
 * NOTE: Must NOT add properties not defined by Sidetree protocol.
 */

var ChunkFile = /*#__PURE__*/function () {
  function ChunkFile() {}

  /**
   * Parses and validates the given chunk file buffer and all the operations within it.
   * @throws SidetreeError if failed parsing or validation.
   */
  ChunkFile.parse = function parse(chunkFileBuffer) {
    try {
      var _this2 = this;

      var endTimer = timeSpan();
      return Promise.resolve(Compressor.decompress(chunkFileBuffer)).then(function (decompressedChunkFileBuffer) {
        return Promise.resolve(JsonAsync.parse(decompressedChunkFileBuffer)).then(function (chunkFileObject) {
          console.info("Parsed chunk file in " + endTimer.rounded() + " ms."); // Ensure only properties specified by Sidetree protocol are given.

          var allowedProperties = new Set(['deltas']);

          for (var property in chunkFileObject) {
            if (!allowedProperties.has(property)) {
              throw new SidetreeError(ErrorCode.ChunkFileUnexpectedProperty, "Unexpected property " + property + " in chunk file.");
            }
          }

          _this2.validateDeltasProperty(chunkFileObject.deltas);

          return chunkFileObject;
        });
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  ChunkFile.validateDeltasProperty = function validateDeltasProperty(deltas) {
    // Make sure deltas is an array.
    if (!(deltas instanceof Array)) {
      throw new SidetreeError(ErrorCode.ChunkFileDeltasPropertyNotArray, 'Invalid chunk file, deltas property is not an array.');
    } // Validate every encoded delta string.


    for (var _iterator = _createForOfIteratorHelperLoose(deltas), _step; !(_step = _iterator()).done;) {
      var encodedDelta = _step.value;

      if (typeof encodedDelta !== 'string') {
        throw new SidetreeError(ErrorCode.ChunkFileDeltasNotArrayOfStrings, 'Invalid chunk file, deltas property is not an array of strings.');
      }

      var deltaBuffer = Buffer.from(encodedDelta); // Verify size of each delta does not exceed the maximum allowed limit.

      if (deltaBuffer.length > protocolParameters.maxDeltaSizeInBytes) {
        throw new SidetreeError(ErrorCode.ChunkFileDeltaSizeExceedsLimit, "Operation size of " + deltaBuffer.length + " bytes exceeds the allowed limit of " + protocolParameters.maxDeltaSizeInBytes + " bytes.");
      }
    }
  }
  /**
   * Creates chunk file buffer.
   */
  ;

  ChunkFile.createBuffer = function createBuffer(createOperations, recoverOperations, updateOperations) {
    try {
      var deltas = [];
      deltas.push.apply(deltas, createOperations.map(function (operation) {
        return operation.encodedDelta;
      }));
      deltas.push.apply(deltas, recoverOperations.map(function (operation) {
        return operation.encodedDelta;
      }));
      deltas.push.apply(deltas, updateOperations.map(function (operation) {
        return operation.encodedDelta;
      }));
      var chunkFileModel = {
        deltas: deltas
      };
      var rawData = Buffer.from(JSON.stringify(chunkFileModel));
      return Promise.resolve(Compressor.compress(Buffer.from(rawData)));
    } catch (e) {
      return Promise.reject(e);
    }
  };

  return ChunkFile;
}();

/**
 * A download manager class that performs multiple downloads at the same time.
 */

var DownloadManager = /*#__PURE__*/function () {
  /**
   * Constructs the download manager.
   * @param cas The Content Adressable Store to use for fetching the actual content.
   */
  function DownloadManager(maxConcurrentDownloads, cas) {
    this.maxConcurrentDownloads = maxConcurrentDownloads;
    this.cas = cas;
    this.pendingDownloads = [];
    this.activeDownloads = new Map();
    this.completedDownloads = new Map(); // If maximum concurrent CAS download count is NaN, set it to a default value.

    if (isNaN(maxConcurrentDownloads)) {
      var defaultmaxConcurrentDownloads = 20;
      console.info("Maximum concurrent CAS download count not given, defaulting to " + defaultmaxConcurrentDownloads + ".");
      this.maxConcurrentDownloads = defaultmaxConcurrentDownloads;
    }
  }
  /**
   * Starts pending downloads if maximum concurrent download count is not reached,
   * and resolve downloads that are completed, then invokes this same method again,
   * thus this method must only be invoked once externally as initialization.
   */


  var _proto = DownloadManager.prototype;

  _proto.start = function start() {
    var _this = this;

    try {
      // Move all completed downloads in `activeDownloads` to the `completedDownloads` map.
      var completedDownloadHandles = [];

      for (var _iterator = _createForOfIteratorHelperLoose(this.activeDownloads), _step; !(_step = _iterator()).done;) {
        var _step$value = _step.value,
            _downloadHandle = _step$value[0],
            _downloadInfo = _step$value[1];

        if (_downloadInfo.completed) {
          this.completedDownloads.set(_downloadHandle, _downloadInfo.fetchResult);
          completedDownloadHandles.push(_downloadHandle); // Resolve the promise associated with the download.

          _downloadInfo.resolve();
        }
      }

      for (var _i = 0, _completedDownloadHan = completedDownloadHandles; _i < _completedDownloadHan.length; _i++) {
        var downloadHandle = _completedDownloadHan[_i];
        this.activeDownloads["delete"](downloadHandle);
      } // If maximum concurrent download count is reached, then we can't schedule more downloads.


      var availableDownloadLanes = this.maxConcurrentDownloads - this.activeDownloads.size;

      if (availableDownloadLanes <= 0) {
        return;
      } // Else we can schedule more downloads, but only if there are pending downloads.


      if (this.pendingDownloads.length === 0) {
        return;
      } // Keep start downloading the next queued item until all download lanes are full or there is no more item to download.


      for (var i = 0; i < this.pendingDownloads.length && i < availableDownloadLanes; i++) {
        var downloadInfo = this.pendingDownloads[i]; // Intentionally not awaiting on a download.

        void this.downloadAsync(downloadInfo);
        this.activeDownloads.set(downloadInfo.handle, downloadInfo);
      } // Remove active downloads from `pendingDownloads` list.


      this.pendingDownloads.splice(0, availableDownloadLanes);
    } catch (error) {
      console.error("Encountered unhandled/unexpected error in DownloadManager, must investigate and fix: " + error);
    } finally {
      setTimeout(function () {
        try {
          return Promise.resolve(_this.start());
        } catch (e) {
          return Promise.reject(e);
        }
      }, 1000);
    }
  }
  /**
   * Downloads the content of the given content hash.
   * @param contentHash Hash of the content to be downloaded.
   */
  ;

  _proto.download = function download(contentHash, maxSizeInBytes) {
    try {
      var _this3 = this;

      var handle = randomBytes(32);
      var fetchPromise = new Promise(function (resolve) {
        var downloadInfo = {
          handle: handle,
          contentHash: contentHash,
          maxSizeInBytes: maxSizeInBytes,
          resolve: resolve,
          completed: false,
          content: undefined
        };

        _this3.pendingDownloads.push(downloadInfo);
      });
      return Promise.resolve(fetchPromise).then(function () {
        var fetchResult = _this3.completedDownloads.get(handle);

        _this3.completedDownloads["delete"](handle);

        return fetchResult;
      });
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * The internal download method that gets called by the main download manager monitoring loop when download lanes are available to download content.
   * NOTE: This method MUST NEVER throw (more accurately: ALWAYS set downloadInfo.completed = true),
   * else it will LEAK the available download lanes and in turn hang the Observer.
   * @param downloadInfo Data structure containing `completed` flag and `fetchResult`,
   *                     used to signal to the main download manager monitoring loop when the requested download is completed.
   */
  ;

  _proto.downloadAsync = function downloadAsync(downloadInfo) {
    try {
      var _this5 = this;

      var contentHash = '';

      var _temp2 = _finallyRethrows(function () {
        return _catch(function () {
          contentHash = downloadInfo.contentHash;
          return Promise.resolve(_this5.cas.read(contentHash // downloadInfo.maxSizeInBytes
          )).then(function (fetchResult) {
            downloadInfo.fetchResult = fetchResult;
          });
        }, function (error) {
          console.error("Unexpected error while downloading '" + contentHash + ", investigate and fix " + error + "'.");
        });
      }, function (_wasThrown, _result) {
        downloadInfo.completed = true;
        if (_wasThrown) throw _result;
        return _result;
      });

      return Promise.resolve(_temp2 && _temp2.then ? _temp2.then(function () {}) : void 0);
    } catch (e) {
      return Promise.reject(e);
    }
  };

  return DownloadManager;
}();

/*
 * The code in this file originated from
 * @see https://github.com/decentralized-identity/sidetree
 * For the list of changes that was made to the original code
 * @see https://github.com/transmute-industries/sidetree.js/blob/master/reference-implementation-changes.md
 *
 * Copyright 2020 - Transmute Industries Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * A class that represents an update operation.
 */

var UpdateOperation = /*#__PURE__*/function () {
  /**
   * NOTE: should only be used by `parse()` and `parseObject()` else the contructed instance could be invalid.
   */
  function UpdateOperation(operationBuffer, didUniqueSuffix, signedDataJws, signedData, encodedDelta, delta) {
    this.operationBuffer = operationBuffer;
    this.type = OperationType.Update;
    this.didUniqueSuffix = didUniqueSuffix;
    this.signedDataJws = signedDataJws;
    this.signedData = signedData;
    this.encodedDelta = encodedDelta;
    this.delta = delta;
  }
  /**
   * Parses the given input as an update operation entry in the map file.
   */


  UpdateOperation.parseOperationFromMapFile = function parseOperationFromMapFile(input) {
    try {
      var operationBuffer = Buffer.from(JSON.stringify(input));
      return Promise.resolve(UpdateOperation.parseObject(input, operationBuffer, true));
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * Parses the given buffer as a `UpdateOperation`.
   */
  ;

  UpdateOperation.parse = function parse(operationBuffer) {
    try {
      var operationJsonString = operationBuffer.toString();
      return Promise.resolve(JsonAsync.parse(operationJsonString)).then(function (operationObject) {
        return Promise.resolve(UpdateOperation.parseObject(operationObject, operationBuffer, false));
      });
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * Parses the given operation object as a `UpdateOperation`.
   * The `operationBuffer` given is assumed to be valid and is assigned to the `operationBuffer` directly.
   * NOTE: This method is purely intended to be used as an optimization method over the `parse` method in that
   * JSON parsing is not required to be performed more than once when an operation buffer of an unknown operation type is given.
   * @param mapFileMode If set to true, then `delta` and `type` properties are expected to be absent.
   */
  ;

  UpdateOperation.parseObject = function parseObject(operationObject, operationBuffer, mapFileMode) {
    try {
      var expectedPropertyCount = 4;

      if (mapFileMode) {
        expectedPropertyCount = 2;
      }

      var properties = Object.keys(operationObject);

      if (properties.length !== expectedPropertyCount) {
        throw new SidetreeError(ErrorCode.UpdateOperationMissingOrUnknownProperty);
      }

      if (typeof operationObject.did_suffix !== 'string') {
        throw new SidetreeError(ErrorCode.UpdateOperationMissingDidUniqueSuffix);
      }

      var signedData = Jws.parseCompactJws(operationObject.signed_data);
      return Promise.resolve(UpdateOperation.parseSignedDataPayload(signedData.payload)).then(function (signedDataModel) {
        var _exit = false;

        function _temp2(_result) {
          return _exit ? _result : new UpdateOperation(operationBuffer, operationObject.did_suffix, signedData, signedDataModel, encodedDelta, delta);
        }

        // If not in map file mode, we need to validate `type` and `delta` properties.
        var encodedDelta = undefined;
        var delta = undefined;

        var _temp = function () {
          if (!mapFileMode) {
            if (operationObject.type !== OperationType.Update) {
              throw new SidetreeError(ErrorCode.UpdateOperationTypeIncorrect);
            }

            encodedDelta = operationObject.delta;
            return Promise.resolve(OperationUtils.parseDelta(encodedDelta)).then(function (_OperationUtils$parse) {
              delta = _OperationUtils$parse;
            });
          }
        }();

        return _temp && _temp.then ? _temp.then(_temp2) : _temp2(_temp);
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  UpdateOperation.parseSignedDataPayload = function parseSignedDataPayload(signedDataEncodedString) {
    try {
      var signedDataJsonString = Encoder.decodeAsString(signedDataEncodedString);
      return Promise.resolve(JsonAsync.parse(signedDataJsonString)).then(function (signedData) {
        var properties = Object.keys(signedData);

        if (properties.length !== 2) {
          throw new SidetreeError(ErrorCode.UpdateOperationSignedDataHasMissingOrUnknownProperty);
        }

        Jwk.validatePublicJwk(signedData.update_key);
        var delta_hash = Encoder.decodeAsBuffer(signedData.delta_hash);
        Multihash.verifyHashComputedUsingLatestSupportedAlgorithm(delta_hash);
        return {
          delta_hash: signedData.delta_hash,
          update_key: signedData.update_key
        };
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  return UpdateOperation;
}();

/**
 * Class containing Map File related operations.
 */

var MapFile = /*#__PURE__*/function () {
  /**
   * Class that represents a map file.
   * NOTE: this class is introduced as an internal structure in replacement to `MapFileModel`
   * to keep useful metadata so that repeated computation can be avoided.
   */
  function MapFile(model, didUniqueSuffixes, updateOperations) {
    this.model = model;
    this.didUniqueSuffixes = didUniqueSuffixes;
    this.updateOperations = updateOperations;
  }
  /**
   * Parses and validates the given map file buffer.
   * @throws `SidetreeError` if failed parsing or validation.
   */


  MapFile.parse = function parse(mapFileBuffer) {
    try {
      var _temp5 = function _temp5(_result) {
        var _exit2 = false;
        if (_exit3) return _result;

        function _temp2(_result2) {
          if (_exit2) return _result2;
          var allowedProperties = new Set(['chunks', 'operations']);

          for (var property in mapFileModel) {
            if (!allowedProperties.has(property)) {
              throw new SidetreeError(ErrorCode.MapFileHasUnknownProperty);
            }
          }

          MapFile.validateChunksProperty(mapFileModel.chunks);
          return Promise.resolve(MapFile.parseOperationsProperty(mapFileModel.operations)).then(function (updateOperations) {
            var didUniqueSuffixes = updateOperations.map(function (operation) {
              return operation.didUniqueSuffix;
            });
            var mapFile = new MapFile(mapFileModel, didUniqueSuffixes, updateOperations);
            return mapFile;
          });
        }

        var mapFileModel;

        var _temp = _catch(function () {
          return Promise.resolve(JsonAsync.parse(decompressedBuffer)).then(function (_JsonAsync$parse) {
            mapFileModel = _JsonAsync$parse;
          });
        }, function (error) {
          throw SidetreeError.createFromError(ErrorCode.MapFileNotJson, error);
        });

        return _temp && _temp.then ? _temp.then(_temp2) : _temp2(_temp);
      };

      var _exit3 = false;
      var decompressedBuffer;

      var _temp6 = _catch(function () {
        return Promise.resolve(Compressor.decompress(mapFileBuffer)).then(function (_Compressor$decompres) {
          decompressedBuffer = _Compressor$decompres;
        });
      }, function (error) {
        throw SidetreeError.createFromError(ErrorCode.MapFileDecompressionFailure, error);
      });

      return Promise.resolve(_temp6 && _temp6.then ? _temp6.then(_temp5) : _temp5(_temp6));
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * Validates the given `operations` property, throws error if the property fails validation.
   */
  ;

  MapFile.parseOperationsProperty = function parseOperationsProperty(operations) {
    try {
      var _temp9 = function _temp9() {
        // Make sure no operation with same DID.
        var didUniqueSuffixes = updateOperations.map(function (operation) {
          return operation.didUniqueSuffix;
        });

        if (ArrayMethods.hasDuplicates(didUniqueSuffixes)) {
          throw new SidetreeError(ErrorCode.MapFileMultipleOperationsForTheSameDid);
        }

        return updateOperations;
      };

      if (operations === undefined) {
        return Promise.resolve([]);
      }

      var properties = Object.keys(operations);

      if (properties.length !== 1) {
        throw new SidetreeError(ErrorCode.MapFileOperationsPropertyHasMissingOrUnknownProperty);
      }

      var updateOperations = [];

      if (!Array.isArray(operations.update)) {
        throw new SidetreeError(ErrorCode.MapFileUpdateOperationsNotArray);
      } // Validate each update operation.


      var _temp10 = _forOf(operations.update, function (operation) {
        return Promise.resolve(UpdateOperation.parseOperationFromMapFile(operation)).then(function (updateOperation) {
          updateOperations.push(updateOperation);
        });
      });

      return Promise.resolve(_temp10 && _temp10.then ? _temp10.then(_temp9) : _temp9(_temp10));
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * Validates the given `chunks` property, throws error if the property fails validation.
   */
  ;

  MapFile.validateChunksProperty = function validateChunksProperty(chunks) {
    if (!Array.isArray(chunks)) {
      throw new SidetreeError(ErrorCode.MapFileChunksPropertyMissingOrIncorrectType);
    } // This version expects only one hash.


    if (chunks.length !== 1) {
      throw new SidetreeError(ErrorCode.MapFileChunksPropertyDoesNotHaveExactlyOneElement);
    }

    var chunk = chunks[0];
    var properties = Object.keys(chunk);

    if (properties.length !== 1) {
      throw new SidetreeError(ErrorCode.MapFileChunkHasMissingOrUnknownProperty);
    }
  }
  /**
   * Creates the Map File buffer.
   */
  ;

  MapFile.createBuffer = function createBuffer(chunkFileHash, updateOperationArray) {
    try {
      var updateOperations = updateOperationArray.map(function (operation) {
        return {
          did_suffix: operation.didUniqueSuffix,
          signed_data: operation.signedDataJws.toCompactJws()
        };
      });
      var _mapFileModel = {
        chunks: [{
          chunk_file_uri: chunkFileHash
        }]
      }; // Only insert an `operations` property if there are update operations.

      if (updateOperations.length > 0) {
        _mapFileModel.operations = {
          update: updateOperations
        };
      }

      var rawData = JSON.stringify(_mapFileModel);
      return Promise.resolve(Compressor.compress(Buffer.from(rawData)));
    } catch (e) {
      return Promise.reject(e);
    }
  };

  return MapFile;
}();

/*
 * The code in this file originated from
 * @see https://github.com/decentralized-identity/sidetree
 * For the list of changes that was made to the original code
 * @see https://github.com/transmute-industries/sidetree.js/blob/master/reference-implementation-changes.md
 *
 * Copyright 2020 - Transmute Industries Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Keeps track of current block and throughput limits based on the state
 */
var ThroughputLimiter = /*#__PURE__*/function () {
  function ThroughputLimiter(versionManager) {
    this.versionManager = versionManager;
  }
  /**
   * given a an array of transactions, return an array of qualified transactions per transaction time.
   * @param transactions array of transactions to filter for
   */


  var _proto = ThroughputLimiter.prototype;

  _proto.getQualifiedTransactions = function getQualifiedTransactions(transactions) {
    try {
      var _this2 = this;

      var currentTransactionTime = undefined;
      var transactionsGroupedByTransactionTime = [];

      for (var _iterator = _createForOfIteratorHelperLoose(transactions), _step; !(_step = _iterator()).done;) {
        var transaction = _step.value;

        // If transaction is transitioning into a new time, create a new grouping.
        if (transaction.transactionTime !== currentTransactionTime) {
          transactionsGroupedByTransactionTime.push([]);
          currentTransactionTime = transaction.transactionTime;
        }

        transactionsGroupedByTransactionTime[transactionsGroupedByTransactionTime.length - 1].push(transaction);
      }

      var qualifiedTransactions = [];

      var _temp2 = _forOf(transactionsGroupedByTransactionTime, function (transactionGroup) {
        var transactionSelector = _this2.versionManager.getTransactionSelector(transactionGroup[0].transactionTime);

        return Promise.resolve(transactionSelector.selectQualifiedTransactions(transactionGroup)).then(function (qualifiedTransactionsInCurrentGroup) {
          qualifiedTransactions.push.apply(qualifiedTransactions, qualifiedTransactionsInCurrentGroup);
        });
      });

      return Promise.resolve(_temp2 && _temp2.then ? _temp2.then(function () {
        return qualifiedTransactions;
      }) : qualifiedTransactions);
    } catch (e) {
      return Promise.reject(e);
    }
  };

  return ThroughputLimiter;
}();

/**
 * Class that performs periodic processing of batches of Sidetree operations anchored to the blockchain.
 */

var Observer = /*#__PURE__*/function () {
  function Observer(versionManager, blockchain, maxConcurrentDownloads, operationStore, transactionStore, unresolvableTransactionStore, observingIntervalInSeconds) {
    this.versionManager = versionManager;
    this.blockchain = blockchain;
    this.maxConcurrentDownloads = maxConcurrentDownloads;
    this.operationStore = operationStore;
    this.transactionStore = transactionStore;
    this.unresolvableTransactionStore = unresolvableTransactionStore;
    this.observingIntervalInSeconds = observingIntervalInSeconds;
    /**
     * Denotes if the periodic transaction processing should continue to occur.
     * Used mainly for test purposes.
     */

    this.continuePeriodicProcessing = false;
    /**
     * The list of transactions that are being downloaded or processed.
     */

    this.transactionsUnderProcessing = [];
    this.throughputLimiter = new ThroughputLimiter(versionManager);
  }

  var _proto = Observer.prototype;

  _proto.refreshLastKnownTransaction = function refreshLastKnownTransaction() {
    try {
      var _this2 = this;

      return Promise.resolve(_this2.transactionStore.getLastTransaction()).then(function (_this$transactionStor) {
        _this2.lastKnownTransaction = _this$transactionStor;
      });
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * The method that starts the periodic polling and processing of Sidetree operations.
   */
  ;

  _proto.startPeriodicProcessing = function startPeriodicProcessing() {
    try {
      var _this4 = this;

      // Initialize the last known transaction before starting processing.
      return Promise.resolve(_this4.refreshLastKnownTransaction()).then(function () {
        console.info("Starting periodic transactions processing.");
        setImmediate(function () {
          try {
            _this4.continuePeriodicProcessing = true; // tslint:disable-next-line:no-floating-promises - this.processTransactions() never throws.

            _this4.processTransactions();

            return Promise.resolve();
          } catch (e) {
            return Promise.reject(e);
          }
        });
      });
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * Stops periodic transaction processing.
   * Mainly used for test purposes.
   */
  ;

  _proto.stopPeriodicProcessing = function stopPeriodicProcessing() {
    console.info("Stopped periodic transactions processing.");
    this.continuePeriodicProcessing = false;
  }
  /**
   * Processes new transactions if any, then reprocess a set of unresolvable transactions if any,
   * then schedules the next round of processing unless `stopPeriodicProcessing()` is invoked.
   */
  ;

  _proto.processTransactions = function processTransactions(awaitTransactionProcessing) {
    if (awaitTransactionProcessing === void 0) {
      awaitTransactionProcessing = false;
    }

    try {
      var _this6 = this;

      return Promise.resolve(_finallyRethrows(function () {
        return _catch(function () {
          return Promise.resolve(_this6.storeConsecutiveTransactionsProcessed()).then(function () {
            var _exit = false;

            function _temp9(_result2) {
              return _exit ? _result2 : Promise.resolve(_this6.storeConsecutiveTransactionsProcessed()).then(function () {
                console.info('Successfully kicked off downloading/processing of all new Sidetree transactions.'); // Continue onto processing unresolvable transactions if any.

                return Promise.resolve(_this6.processUnresolvableTransactions(awaitTransactionProcessing)).then(function () {});
              });
            }

            // Do this in multiple places
            // Keep fetching new Sidetree transactions from blockchain and processing them
            // until there are no more new transactions or there is a block reorganization.
            var moreTransactions = false;

            var _temp8 = _do(function () {
              function _temp7(_result) {
                if (_exit) return _result;
                var transactions = readResult ? readResult.transactions : [];
                moreTransactions = readResult ? readResult.moreTransactions : false;
                return Promise.resolve(_this6.throughputLimiter.getQualifiedTransactions(transactions)).then(function (qualifiedTransactions) {
                  function _temp5() {
                    function _temp3() {
                      if (transactions && transactions.length > 0) {
                        _this6.lastKnownTransaction = transactions[transactions.length - 1];
                      }
                    }

                    // NOTE: Blockchain reorg has happened for sure only if `invalidTransactionNumberOrTimeHash` AND
                    // latest transaction time is less or equal to blockchain service time.
                    // This check will prevent Core from reverting transactions if/when blockchain service is reinitializing its data itself.
                    var blockReorganizationDetected = false;

                    if (invalidTransactionNumberOrTimeHash) {
                      if (lastKnownTransactionTime <= _this6.blockchain.approximateTime.time) {
                        blockReorganizationDetected = true;
                        moreTransactions = true;
                      } else {
                        console.info("Blockchain microservice blockchain time is behind last known transaction time, waiting for blockchain microservice to catch up...");
                      }
                    } // If block reorg is detected, we must wait until no more operation processing is pending,
                    // then revert invalid transaction and operations.


                    var _temp2 = function () {
                      if (blockReorganizationDetected) {
                        console.info("Block reorganization detected.");
                        return Promise.resolve(_this6.waitUntilCountOfTransactionsUnderProcessingIsLessOrEqualTo(0)).then(function () {
                          console.info("Reverting invalid transactions...");
                          return Promise.resolve(_this6.revertInvalidTransactions()).then(function () {
                            console.info("Completed reverting invalid transactions.");
                          });
                        });
                      } else {
                        // Else it means transaction fetch was successful:
                        // We hold off from fetching more transactions if the list of transactions under processing gets too long.
                        // We will wait for count of transaction being processed to fall to the maximum allowed concurrent downloads
                        // before attempting further transaction fetches.
                        return Promise.resolve(_this6.waitUntilCountOfTransactionsUnderProcessingIsLessOrEqualTo(_this6.maxConcurrentDownloads)).then(function () {});
                      }
                    }();

                    return _temp2 && _temp2.then ? _temp2.then(_temp3) : _temp3(_temp2); // Update the last known transaction.
                    // NOTE: In case of block reorg, last known transaction will be updated in `this.RevertInvalidTransactions()` method.
                  }

                  qualifiedTransactions = qualifiedTransactions.sort(function (a, b) {
                    return a.transactionNumber - b.transactionNumber;
                  }); // Queue parallel downloading and processing of chunk files.

                  var _temp4 = _forOf(qualifiedTransactions, function (transaction) {
                    var awaitingTransaction = {
                      transaction: transaction,
                      processingStatus: TransactionProcessingStatus.Pending
                    };

                    _this6.transactionsUnderProcessing.push(awaitingTransaction);

                    var _temp = function () {
                      if (awaitTransactionProcessing) {
                        return Promise.resolve(_this6.processTransaction(transaction, awaitingTransaction)).then(function () {});
                      } else {
                        // Intentionally not awaiting on downloading and processing each operation batch.
                        void _this6.processTransaction(transaction, awaitingTransaction);
                      }
                    }();

                    if (_temp && _temp.then) return _temp.then(function () {});
                  });

                  return _temp4 && _temp4.then ? _temp4.then(_temp5) : _temp5(_temp4);
                });
              }

              // Get the last transaction to be used as a timestamp to fetch new transactions.
              var lastKnownTransactionNumber = _this6.lastKnownTransaction ? _this6.lastKnownTransaction.transactionNumber : undefined;
              var lastKnownTransactionTimeHash = _this6.lastKnownTransaction ? _this6.lastKnownTransaction.transactionTimeHash : undefined;
              var lastKnownTransactionTime = _this6.lastKnownTransaction ? _this6.lastKnownTransaction.transactionTime : 0;
              var invalidTransactionNumberOrTimeHash = false;
              var readResult;
              var endTimer = timeSpan(); // Measure time taken to go blockchain read.

              var _temp6 = _catch(function () {
                console.info('Fetching Sidetree transactions from blockchain service...');
                var nextTransactionNumber = lastKnownTransactionNumber !== undefined ? lastKnownTransactionNumber + 1 : undefined;
                return Promise.resolve(_this6.blockchain.read(nextTransactionNumber, lastKnownTransactionTimeHash)).then(function (_this5$blockchain$rea) {
                  readResult = _this5$blockchain$rea;
                  console.info("Fetched " + readResult.transactions.length + " Sidetree transactions from blockchain service in " + endTimer.rounded() + " ms.");
                });
              }, function (error) {
                if (error instanceof SidetreeError && error.code === SharedErrorCode.InvalidTransactionNumberOrTimeHash) {
                  console.info("Invalid transaction number " + lastKnownTransactionNumber + " or time hash " + lastKnownTransactionTimeHash + " given to blockchain service.");
                  invalidTransactionNumberOrTimeHash = true;
                } else {
                  throw error;
                }
              });

              return _temp6 && _temp6.then ? _temp6.then(_temp7) : _temp7(_temp6);
            }, function () {
              return !_exit && !!moreTransactions;
            });

            return _temp8 && _temp8.then ? _temp8.then(_temp9) : _temp9(_temp8);
          });
        }, function (error) {
          console.error("Encountered unhandled and possibly fatal Observer error, must investigate and fix:");
          console.error(error);
        });
      }, function (_wasThrown, _result3) {
        if (_this6.continuePeriodicProcessing) {
          console.info("Waiting for " + _this6.observingIntervalInSeconds + " seconds before fetching and processing transactions again.");
          setTimeout(function () {
            try {
              return Promise.resolve(_this6.processTransactions());
            } catch (e) {
              return Promise.reject(e);
            }
          }, _this6.observingIntervalInSeconds * 1000);
        }

        if (_wasThrown) throw _result3;
        return _result3;
      }));
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.waitUntilCountOfTransactionsUnderProcessingIsLessOrEqualTo = function waitUntilCountOfTransactionsUnderProcessingIsLessOrEqualTo(count) {
    try {
      var _this8 = this;

      var _temp11 = _for(function () {
        return _this8.transactionsUnderProcessing.length > count;
      }, void 0, function () {
        // Store the consecutively processed transactions in the transaction store.
        return Promise.resolve(_this8.storeConsecutiveTransactionsProcessed()).then(function () {
          // Wait a little before checking again.
          return Promise.resolve(new Promise(function (resolve) {
            return setTimeout(resolve, 1000);
          })).then(function () {});
        });
      });

      return Promise.resolve(_temp11 && _temp11.then ? _temp11.then(function () {}) : void 0);
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * Attempts to fetch and process unresolvable transactions due for retry.
   * Waits until all unresolvable transactions due for retry are processed.
   */
  ;

  _proto.processUnresolvableTransactions = function processUnresolvableTransactions(awaitTransactionProcessing) {
    if (awaitTransactionProcessing === void 0) {
      awaitTransactionProcessing = false;
    }

    try {
      var _this10 = this;

      var endTimer = timeSpan();
      return Promise.resolve(_this10.unresolvableTransactionStore.getUnresolvableTransactionsDueForRetry()).then(function (unresolvableTransactions) {
        function _temp15() {
          var _temp13 = _for(function () {
            return unresolvableTransactionStatus.length > 0;
          }, void 0, function () {
            // Find the index of the first transaction that is not processed yet.
            var i = 0;

            while (i < unresolvableTransactionStatus.length && unresolvableTransactionStatus[i].processingStatus === TransactionProcessingStatus.Processed) {
              i++;
            } // Trim the parallelized transaction list.


            unresolvableTransactionStatus.splice(0, i); // Wait a little before checking again.

            return Promise.resolve(new Promise(function (resolve) {
              return setTimeout(resolve, 1000);
            })).then(function () {});
          });

          if (_temp13 && _temp13.then) return _temp13.then(function () {});
        }

        console.info("Fetched " + unresolvableTransactions.length + " unresolvable transactions to retry in " + endTimer.rounded() + " ms."); // Download and process each unresolvable transactions.

        var unresolvableTransactionStatus = [];

        var _temp14 = _forOf(unresolvableTransactions, function (transaction) {
          var awaitingTransaction = {
            transaction: transaction,
            processingStatus: TransactionProcessingStatus.Pending
          };
          unresolvableTransactionStatus.push(awaitingTransaction); // Intentionally not awaiting on downloading and processing each operation batch.

          var _temp12 = function () {
            if (awaitTransactionProcessing) {
              return Promise.resolve(_this10.processTransaction(transaction, awaitingTransaction)).then(function () {});
            } else {
              // Intentionally not awaiting on downloading and processing each operation batch.
              void _this10.processTransaction(transaction, awaitingTransaction);
            }
          }();

          if (_temp12 && _temp12.then) return _temp12.then(function () {});
        });

        return _temp14 && _temp14.then ? _temp14.then(_temp15) : _temp15(_temp14); // Wait until all unresolvable transactions are processed,
      });
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * Goes through the `transactionsUnderProcessing` in chronological order, records each processed transaction
   * in the transaction store and remove it from `transactionsUnderProcessing` until a transaction that has not been processed yet is hit.
   */
  ;

  _proto.storeConsecutiveTransactionsProcessed = function storeConsecutiveTransactionsProcessed() {
    try {
      var _temp18 = function _temp18() {
        // Trim the transaction list.
        _this12.transactionsUnderProcessing.splice(0, i);
      };

      var _this12 = this;

      var i = 0;

      var _temp19 = _for(function () {
        return i < _this12.transactionsUnderProcessing.length && _this12.transactionsUnderProcessing[i].processingStatus === TransactionProcessingStatus.Processed;
      }, void 0, function () {
        return Promise.resolve(_this12.transactionStore.addTransaction(_this12.transactionsUnderProcessing[i].transaction)).then(function () {
          i++;
        });
      });

      return Promise.resolve(_temp19 && _temp19.then ? _temp19.then(_temp18) : _temp18(_temp19));
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * Processes the given transaction by passing the transaction to the right version of the transaction processor based on the transaction time.
   * The transaction processing generically involves first downloading DID operation data from CAS (Content Addressable Storage),
   * then storing the operations indexed/grouped by DIDs in the persistent operation DB.
   */
  ;

  _proto.processTransaction = function processTransaction(transaction, transactionUnderProcessing) {
    try {
      var _this14 = this;

      var transactionProcessedSuccessfully;

      var _temp23 = _finallyRethrows(function () {
        return _catch(function () {
          var transactionProcessor = _this14.versionManager.getTransactionProcessor(transaction.transactionTime);

          return Promise.resolve(transactionProcessor.processTransaction(transaction)).then(function (_transactionProcessor) {
            transactionProcessedSuccessfully = _transactionProcessor;
          });
        }, function (error) {
          console.error("Unhandled error encountered processing transaction '" + transaction.transactionNumber + "'.");
          console.error(error);
          transactionProcessedSuccessfully = false;
        });
      }, function (_wasThrown2, _result4) {
        function _temp21() {
          if (_wasThrown2) throw _result4;
          return _result4;
        }

        // Purposely setting processing status first before rest of the code to prevent any possibility of deadlocking the Observer.
        console.info("Finished processing transaction '" + transaction.transactionNumber + "'.");
        transactionUnderProcessing.processingStatus = TransactionProcessingStatus.Processed;

        var _temp20 = function () {
          if (transactionProcessedSuccessfully) {
            console.info("Removing transaction '" + transaction.transactionNumber + "' from unresolvable transactions if exists...");
            return Promise.resolve(_this14.unresolvableTransactionStore.removeUnresolvableTransaction(transaction)).then(function () {});
          } else {
            console.info("Recording failed processing attempt for transaction '" + transaction.transactionNumber + "'...");
            return Promise.resolve(_this14.unresolvableTransactionStore.recordUnresolvableTransactionFetchAttempt(transaction)).then(function () {});
          }
        }();

        return _temp20 && _temp20.then ? _temp20.then(_temp21) : _temp21(_temp20);
      });

      return Promise.resolve(_temp23 && _temp23.then ? _temp23.then(function () {}) : void 0);
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * Reverts invalid transactions. Used in the event of a block-reorganization.
   */
  ;

  _proto.revertInvalidTransactions = function revertInvalidTransactions() {
    try {
      var _this16 = this;

      // Compute a list of exponentially-spaced transactions with their index, starting from the last transaction of the processed transactions.
      return Promise.resolve(_this16.transactionStore.getExponentiallySpacedTransactions()).then(function (exponentiallySpacedTransactions) {
        // Find a known valid Sidetree transaction that is prior to the block reorganization.
        return Promise.resolve(_this16.blockchain.getFirstValidTransaction(exponentiallySpacedTransactions)).then(function (bestKnownValidRecentTransaction) {
          var bestKnownValidRecentTransactionNumber = bestKnownValidRecentTransaction === undefined ? undefined : bestKnownValidRecentTransaction.transactionNumber;
          console.info("Best known valid recent transaction: " + bestKnownValidRecentTransactionNumber); // Revert all processed operations that came after the best known valid recent transaction.

          console.info('Reverting operations...');
          return Promise.resolve(_this16.operationStore["delete"](bestKnownValidRecentTransactionNumber)).then(function () {
            // NOTE: MUST do this step LAST to handle incomplete operation rollback due to unexpected scenarios, such as power outage etc.
            return Promise.resolve(_this16.transactionStore.removeTransactionsLaterThan(bestKnownValidRecentTransactionNumber)).then(function () {
              return Promise.resolve(_this16.unresolvableTransactionStore.removeUnresolvableTransactionsLaterThan(bestKnownValidRecentTransactionNumber)).then(function () {
                // Reset the in-memory last known good Transaction so we next processing cycle will fetch from the correct timestamp/maker.
                _this16.lastKnownTransaction = bestKnownValidRecentTransaction;
              });
            });
          });
        });
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  return Observer;
}();

/*
 * The code in this file originated from
 * @see https://github.com/decentralized-identity/sidetree
 * For the list of changes that was made to the original code
 * @see https://github.com/transmute-industries/sidetree.js/blob/master/reference-implementation-changes.md
 *
 * Copyright 2020 - Transmute Industries Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * A class that contains Sidetree operation utility methods.
 */

var Operation = /*#__PURE__*/function () {
  function Operation() {}

  /**
   * Parses the given buffer into an `OperationModel`.
   */
  Operation.parse = function parse(operationBuffer) {
    try {
      // Parse request buffer into a JS object.
      var operationJsonString = operationBuffer.toString();
      var operationObject = JSON.parse(operationJsonString);
      var operationType = operationObject.type;
      var isAnchorFileMode = false;

      if (operationType === OperationType.Create) {
        return Promise.resolve(CreateOperation.parseObject(operationObject, operationBuffer, isAnchorFileMode));
      } else if (operationType === OperationType.Update) {
        return Promise.resolve(UpdateOperation.parseObject(operationObject, operationBuffer, isAnchorFileMode));
      } else if (operationType === OperationType.Recover) {
        return Promise.resolve(RecoverOperation.parseObject(operationObject, operationBuffer, isAnchorFileMode));
      } else if (operationType === OperationType.Deactivate) {
        return Promise.resolve(DeactivateOperation.parseObject(operationObject, operationBuffer, isAnchorFileMode));
      } else {
        throw new SidetreeError(ErrorCode.OperationTypeUnknownOrMissing);
      }
    } catch (e) {
      return Promise.reject(e);
    }
  };

  return Operation;
}();
Operation.maxEncodedRevealValueLength = 50;

/**
 * A class that can generate valid operations.
 * Mainly useful for testing purposes.
 */

var OperationGenerator = /*#__PURE__*/function () {
  function OperationGenerator() {}

  /**
   * Generates random hash.
   */
  OperationGenerator.generateRandomHash = function generateRandomHash() {
    var randomBuffer = randomBytes(32);
    var randomHash = Encoder.encode(Multihash.hash(randomBuffer));
    return randomHash;
  }
  /**
   * Generates Ed25519 key pair to be used in an operation. If purpose not supplied, all purposes will be included
   * Mainly used for testing.
   * @returns [publicKey, privateKey]
   */
  ;

  OperationGenerator.generateKeyPair = function generateKeyPair(id, purpose) {
    try {
      return Promise.resolve(Jwk.generateEd25519KeyPair()).then(function (_ref) {
        var publicKey = _ref[0],
            privateKey = _ref[1];
        var publicKeyModel = {
          id: id,
          type: 'Ed25519VerificationKey2018',
          jwk: publicKey,
          purpose: purpose || Object.values(PublicKeyPurpose)
        };
        return [publicKeyModel, privateKey];
      });
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * Generates an anchored create operation.
   */
  ;

  OperationGenerator.generateAnchoredCreateOperation = function generateAnchoredCreateOperation(input) {
    try {
      return Promise.resolve(OperationGenerator.generateCreateOperation()).then(function (createOperationData) {
        var anchoredOperationModel = {
          type: OperationType.Create,
          didUniqueSuffix: createOperationData.createOperation.didUniqueSuffix,
          operationBuffer: createOperationData.createOperation.operationBuffer,
          transactionNumber: input.transactionNumber,
          transactionTime: input.transactionTime,
          operationIndex: input.operationIndex
        };
        return {
          createOperation: createOperationData.createOperation,
          operationRequest: createOperationData.operationRequest,
          anchoredOperationModel: anchoredOperationModel,
          recoveryPublicKey: createOperationData.recoveryPublicKey,
          recoveryPrivateKey: createOperationData.recoveryPrivateKey,
          updatePublicKey: createOperationData.updatePublicKey,
          updatePrivateKey: createOperationData.updatePrivateKey,
          signingPublicKey: createOperationData.signingPublicKey,
          signingPrivateKey: createOperationData.signingPrivateKey,
          nextUpdateRevealValueEncodedString: createOperationData.nextUpdateRevealValueEncodedString
        };
      });
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * Generates an create operation.
   */
  ;

  OperationGenerator.generateCreateOperation = function generateCreateOperation() {
    try {
      var signingKeyId = 'signingKey';
      return Promise.resolve(Jwk.generateEd25519KeyPair()).then(function (_ref2) {
        var recoveryPublicKey = _ref2[0],
            recoveryPrivateKey = _ref2[1];
        return Promise.resolve(Jwk.generateEd25519KeyPair()).then(function (_ref3) {
          var updatePublicKey = _ref3[0],
              updatePrivateKey = _ref3[1];
          return Promise.resolve(OperationGenerator.generateKeyPair(signingKeyId)).then(function (_ref4) {
            var signingPublicKey = _ref4[0],
                signingPrivateKey = _ref4[1];
            var service = OperationGenerator.generateServiceEndpoints(['serviceEndpointId123']);
            return Promise.resolve(OperationGenerator.generateCreateOperationRequest(recoveryPublicKey, updatePublicKey, [signingPublicKey], service)).then(function (operationRequest) {
              var operationBuffer = Buffer.from(JSON.stringify(operationRequest));
              return Promise.resolve(CreateOperation.parse(operationBuffer)).then(function (createOperation) {
                var nextUpdateRevealValueEncodedString = Multihash.canonicalizeThenHashThenEncode(signingPublicKey.jwk);
                return {
                  createOperation: createOperation,
                  operationRequest: operationRequest,
                  recoveryPublicKey: recoveryPublicKey,
                  recoveryPrivateKey: recoveryPrivateKey,
                  updatePublicKey: updatePublicKey,
                  updatePrivateKey: updatePrivateKey,
                  signingPublicKey: signingPublicKey,
                  signingPrivateKey: signingPrivateKey,
                  nextUpdateRevealValueEncodedString: nextUpdateRevealValueEncodedString
                };
              });
            });
          });
        });
      });
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * Generates a recover operation.
   */
  ;

  OperationGenerator.generateRecoverOperation = function generateRecoverOperation(input) {
    try {
      var newSigningKeyId = 'newSigningKey';
      return Promise.resolve(Jwk.generateEd25519KeyPair()).then(function (_ref5) {
        var newRecoveryPublicKey = _ref5[0],
            newRecoveryPrivateKey = _ref5[1];
        return Promise.resolve(OperationGenerator.generateKeyPair(newSigningKeyId)).then(function (_ref6) {
          var newSigningPublicKey = _ref6[0],
              newSigningPrivateKey = _ref6[1];
          return Promise.resolve(OperationGenerator.generateKeyPair('newKey')).then(function (_ref7) {
            var publicKeyToBeInDocument = _ref7[0];
            var services = OperationGenerator.generateServiceEndpoints(['serviceEndpointId123']); // Generate the next update and recover operation commitment hash reveal value pair.

            return Promise.resolve(OperationGenerator.generateKeyPair('update_key')).then(function (_ref8) {
              var update_key = _ref8[0],
                  updatePrivateKey = _ref8[1];
              return Promise.resolve(OperationGenerator.generateRecoverOperationRequest(input.didUniqueSuffix, input.recoveryPrivateKey, newRecoveryPublicKey, newSigningPublicKey, services, [publicKeyToBeInDocument])).then(function (operationJson) {
                var operationBuffer = Buffer.from(JSON.stringify(operationJson));
                return Promise.resolve(RecoverOperation.parse(operationBuffer)).then(function (recoverOperation) {
                  return {
                    recoverOperation: recoverOperation,
                    operationBuffer: operationBuffer,
                    recoveryPublicKey: newRecoveryPublicKey,
                    recoveryPrivateKey: newRecoveryPrivateKey,
                    signingPublicKey: newSigningPublicKey,
                    signingPrivateKey: newSigningPrivateKey,
                    update_key: update_key,
                    updatePrivateKey: updatePrivateKey
                  };
                });
              });
            });
          });
        });
      });
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * Generates an update operation that adds a new key.
   */
  ;

  OperationGenerator.generateUpdateOperation = function generateUpdateOperation(didUniqueSuffix, updatePublicKey, updatePrivateKey) {
    try {
      var additionalKeyId = "additional-key";
      return Promise.resolve(OperationGenerator.generateKeyPair(additionalKeyId)).then(function (_ref9) {
        var additionalPublicKey = _ref9[0],
            additionalPrivateKey = _ref9[1];
        return Promise.resolve(OperationGenerator.createUpdateOperationRequestForAddingAKey(didUniqueSuffix, updatePublicKey, updatePrivateKey, additionalPublicKey, Multihash.canonicalizeThenHashThenEncode(additionalPublicKey))).then(function (operationJson) {
          var operationBuffer = Buffer.from(JSON.stringify(operationJson));
          return Promise.resolve(UpdateOperation.parse(operationBuffer)).then(function (updateOperation) {
            return {
              updateOperation: updateOperation,
              operationBuffer: operationBuffer,
              additionalKeyId: additionalKeyId,
              additionalPublicKey: additionalPublicKey,
              additionalPrivateKey: additionalPrivateKey,
              nextUpdateKey: additionalPublicKey.jwk
            };
          });
        });
      });
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * Creates a named anchored operation model from `OperationModel`.
   */
  ;

  OperationGenerator.createAnchoredOperationModelFromOperationModel = function createAnchoredOperationModelFromOperationModel(operationModel, transactionTime, transactionNumber, operationIndex) {
    var anchoredOperationModel = {
      didUniqueSuffix: operationModel.didUniqueSuffix,
      type: operationModel.type,
      operationBuffer: operationModel.operationBuffer,
      operationIndex: operationIndex,
      transactionNumber: transactionNumber,
      transactionTime: transactionTime
    };
    return anchoredOperationModel;
  }
  /**
   * Generates a create operation request.
   */
  ;

  OperationGenerator.generateCreateOperationRequest = function generateCreateOperationRequest(recoveryPublicKey, updatePublicKey, otherPublicKeys, service_endpoints) {
    try {
      var document = {
        public_keys: otherPublicKeys,
        service_endpoints: service_endpoints
      };
      var patches = [{
        action: 'replace',
        document: document
      }];
      var delta = {
        update_commitment: Multihash.canonicalizeThenHashThenEncode(updatePublicKey),
        patches: patches
      };
      var deltaBuffer = Buffer.from(JSON.stringify(delta));
      var delta_hash = Encoder.encode(Multihash.hash(deltaBuffer));
      var suffixData = {
        delta_hash: delta_hash,
        recovery_commitment: Multihash.canonicalizeThenHashThenEncode(recoveryPublicKey)
      };
      var suffixDataEncodedString = Encoder.encode(JSON.stringify(suffixData));
      var deltaEncodedString = Encoder.encode(deltaBuffer);
      var operation = {
        type: OperationType.Create,
        suffix_data: suffixDataEncodedString,
        delta: deltaEncodedString
      };
      return Promise.resolve(operation);
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * Generates an update operation request.
   */
  ;

  OperationGenerator.generateUpdateOperationRequest = function generateUpdateOperationRequest(didUniqueSuffix) {
    try {
      if (didUniqueSuffix === undefined) {
        didUniqueSuffix = OperationGenerator.generateRandomHash();
      }

      return Promise.resolve(OperationGenerator.generateKeyPair('nextUpdateKey')).then(function (_ref10) {
        var nextUpdateKey = _ref10[0];
        var nextUpdateCommitmentHash = Multihash.canonicalizeThenHashThenEncode(nextUpdateKey.jwk);
        var anyNewSigningPublicKeyId = 'anyNewKey';
        return Promise.resolve(OperationGenerator.generateKeyPair(anyNewSigningPublicKeyId)).then(function (_ref11) {
          var anyNewSigningKey = _ref11[0];
          var patches = [{
            action: 'add-public-keys',
            public_keys: [anyNewSigningKey]
          }];
          var signingKeyId = 'anySigningKeyId';
          return Promise.resolve(OperationGenerator.generateKeyPair(signingKeyId)).then(function (_ref12) {
            var signingPublicKey = _ref12[0],
                signingPrivateKey = _ref12[1];
            return Promise.resolve(OperationGenerator.createUpdateOperationRequest(didUniqueSuffix, signingPublicKey.jwk, signingPrivateKey, nextUpdateCommitmentHash, patches)).then(function (request) {
              var buffer = Buffer.from(JSON.stringify(request));
              return Promise.resolve(UpdateOperation.parse(buffer)).then(function (updateOperation) {
                return {
                  request: request,
                  buffer: buffer,
                  updateOperation: updateOperation
                };
              });
            });
          });
        });
      });
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * Creates an update operation request.
   */
  ;

  OperationGenerator.createUpdateOperationRequest = function createUpdateOperationRequest(didUniqueSuffix, updatePublicKey, updatePrivateKey, nextUpdateCommitmentHash, patches) {
    try {
      var delta = {
        patches: patches,
        update_commitment: nextUpdateCommitmentHash
      };
      var deltaJsonString = JSON.stringify(delta);
      var delta_hash = Encoder.encode(Multihash.hash(Buffer.from(deltaJsonString)));
      var encodedDeltaString = Encoder.encode(deltaJsonString);
      var signedDataPayloadObject = {
        update_key: updatePublicKey,
        delta_hash: delta_hash
      };
      return Promise.resolve(OperationGenerator.signUsingEd25519(signedDataPayloadObject, updatePrivateKey)).then(function (signedData) {
        var updateOperationRequest = {
          type: OperationType.Update,
          did_suffix: didUniqueSuffix,
          delta: encodedDeltaString,
          signed_data: signedData
        };
        return updateOperationRequest;
      });
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * Generates a recover operation request.
   */
  ;

  OperationGenerator.generateRecoverOperationRequest = function generateRecoverOperationRequest(didUniqueSuffix, recoveryPrivateKey, newRecoveryPublicKey, newSigningPublicKey, service_endpoints, public_keys) {
    try {
      var document = {
        public_keys: public_keys,
        service_endpoints: service_endpoints
      };
      return Promise.resolve(OperationGenerator.createRecoverOperationRequest(didUniqueSuffix, recoveryPrivateKey, newRecoveryPublicKey, Multihash.canonicalizeThenHashThenEncode(newSigningPublicKey.jwk), document));
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * Creates a recover operation request.
   */
  ;

  OperationGenerator.createRecoverOperationRequest = function createRecoverOperationRequest(didUniqueSuffix, recoveryPrivateKey, newRecoveryPublicKey, nextUpdateCommitmentHash, document) {
    try {
      var patches = [{
        action: 'replace',
        document: document
      }];
      var delta = {
        patches: patches,
        update_commitment: nextUpdateCommitmentHash
      };
      var deltaBuffer = Buffer.from(JSON.stringify(delta));
      var delta_hash = Encoder.encode(Multihash.hash(deltaBuffer));
      var signedDataPayloadObject = {
        delta_hash: delta_hash,
        recovery_key: Jwk.getCurve25519PublicKey(recoveryPrivateKey),
        recovery_commitment: Multihash.canonicalizeThenHashThenEncode(newRecoveryPublicKey)
      };
      return Promise.resolve(OperationGenerator.signUsingEd25519(signedDataPayloadObject, recoveryPrivateKey)).then(function (signedData) {
        var deltaEncodedString = Encoder.encode(deltaBuffer);
        var operation = {
          type: OperationType.Recover,
          did_suffix: didUniqueSuffix,
          signed_data: signedData,
          delta: deltaEncodedString
        };
        return operation;
      });
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * Generates a deactivate operation request.
   */
  ;

  OperationGenerator.createDeactivateOperationRequest = function createDeactivateOperationRequest(didUniqueSuffix, recoveryPrivateKey) {
    try {
      var signedDataPayloadObject = {
        did_suffix: didUniqueSuffix,
        recovery_key: Jwk.getCurve25519PublicKey(recoveryPrivateKey)
      };
      return Promise.resolve(OperationGenerator.signUsingEd25519(signedDataPayloadObject, recoveryPrivateKey)).then(function (signedData) {
        var operation = {
          type: OperationType.Deactivate,
          did_suffix: didUniqueSuffix,
          signed_data: signedData
        };
        return operation;
      });
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * Generates a create operation request buffer.
   * @param nextRecoveryCommitmentHash The encoded commitment hash for the next recovery.
   * @param nextUpdateCommitmentHash The encoded commitment hash for the next update.
   */
  ;

  OperationGenerator.generateCreateOperationBuffer = function generateCreateOperationBuffer(recoveryPublicKey, signingPublicKey, service_endpoints) {
    try {
      return Promise.resolve(OperationGenerator.generateCreateOperationRequest(recoveryPublicKey, signingPublicKey.jwk, [signingPublicKey], service_endpoints)).then(function (operation) {
        return Buffer.from(JSON.stringify(operation));
      });
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * Creates an update operation for adding a key.
   */
  ;

  OperationGenerator.createUpdateOperationRequestForAddingAKey = function createUpdateOperationRequestForAddingAKey(didUniqueSuffix, updatePublicKey, updatePrivateKey, newPublicKey, nextUpdateCommitmentHash) {
    try {
      var patches = [{
        action: 'add-public-keys',
        public_keys: [newPublicKey]
      }];
      return Promise.resolve(OperationGenerator.createUpdateOperationRequest(didUniqueSuffix, updatePublicKey, updatePrivateKey, nextUpdateCommitmentHash, patches));
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * Creates an update operation for adding and/or removing hub service endpoints.
   */
  ;

  OperationGenerator.createUpdateOperationRequestForHubEndpoints = function createUpdateOperationRequestForHubEndpoints(didUniqueSuffix, updatePublicKey, updatePrivateKey, nextUpdateCommitmentHash, idOfServiceEndpointToAdd, idsOfServiceEndpointToRemove) {
    try {
      var patches = [];

      if (idOfServiceEndpointToAdd !== undefined) {
        var patch = {
          action: 'add-service-endpoints',
          service_endpoints: OperationGenerator.generateServiceEndpoints([idOfServiceEndpointToAdd])
        };
        patches.push(patch);
      }

      if (idsOfServiceEndpointToRemove.length > 0) {
        var _patch = {
          action: 'remove-service-endpoints',
          ids: idsOfServiceEndpointToRemove
        };
        patches.push(_patch);
      }

      return Promise.resolve(OperationGenerator.createUpdateOperationRequest(didUniqueSuffix, updatePublicKey, updatePrivateKey, nextUpdateCommitmentHash, patches));
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * Signs the given payload as a ed25519 compact JWS.
   */
  ;

  OperationGenerator.signUsingEd25519 = function signUsingEd25519(payload, privateKey) {
    try {
      var protectedHeader = {
        alg: 'EdDSA'
      };
      return Promise.resolve(Jws.signAsCompactJws(payload, privateKey, protectedHeader));
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * Generates a Deactivate Operation data.
   */
  ;

  OperationGenerator.createDeactivateOperation = function createDeactivateOperation(didUniqueSuffix, recoveryPrivateKey) {
    try {
      return Promise.resolve(OperationGenerator.createDeactivateOperationRequest(didUniqueSuffix, recoveryPrivateKey)).then(function (operationRequest) {
        var operationBuffer = Buffer.from(JSON.stringify(operationRequest));
        return Promise.resolve(DeactivateOperation.parse(operationBuffer)).then(function (deactivateOperation) {
          return {
            operationRequest: operationRequest,
            operationBuffer: operationBuffer,
            deactivateOperation: deactivateOperation
          };
        });
      });
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * Generates an array of service endpoints with specified ids
   * @param ids the id field in endpoint.
   */
  ;

  OperationGenerator.generateServiceEndpoints = function generateServiceEndpoints(ids) {
    var service_endpoints = [];

    for (var _iterator = _createForOfIteratorHelperLoose(ids), _step; !(_step = _iterator()).done;) {
      var id = _step.value;
      service_endpoints.push({
        id: id,
        type: 'someType',
        endpoint: 'https://www.url.com'
      });
    }

    return service_endpoints;
  };

  return OperationGenerator;
}();

/**
 * NOTE: Resolver cannot be versioned because it needs to be aware of `VersionManager` to fetch versioned operation processors.
 */

var Resolver = /*#__PURE__*/function () {
  function Resolver(versionManager, operationStore) {
    this.versionManager = versionManager;
    this.operationStore = operationStore;
  }
  /**
   * Resolve the given DID unique suffix to its latest DID state.
   * @param didUniqueSuffix The unique suffix of the DID to resolve. e.g. if 'did:sidetree:abc123' is the DID, the unique suffix would be 'abc123'
   * @returns Final DID state of the DID. Undefined if the unique suffix of the DID is not found or the DID state is not constructable.
   */


  var _proto = Resolver.prototype;

  _proto.resolve = function resolve(didUniqueSuffix) {
    try {
      var _this2 = this;

      console.info("Resolving DID unique suffix '" + didUniqueSuffix + "'...");
      return Promise.resolve(_this2.operationStore.get(didUniqueSuffix)).then(function (operations) {
        var operationsByType = Resolver.categorizeOperationsByType(operations); // Find and apply a valid create operation.

        return Promise.resolve(_this2.applyCreateOperation(operationsByType.createOperations)).then(function (didState) {
          // If can't construct an initial DID state.
          if (didState === undefined) {
            return undefined;
          } // Apply recovery/deactivate operations until an operation matching the next recovery commitment cannot be found.


          var recoverAndDeactivateOperations = operationsByType.recoverOperations.concat(operationsByType.deactivateOperations);
          return Promise.resolve(_this2.constructCommitValueToOperationLookupMap(recoverAndDeactivateOperations)).then(function (recoveryCommitValueToOperationMap) {
            return Promise.resolve(_this2.applyRecoverAndDeactivateOperations(didState, recoveryCommitValueToOperationMap)).then(function (_this$applyRecoverAnd) {
              didState = _this$applyRecoverAnd;
              return didState.nextRecoveryCommitmentHash === undefined ? didState : Promise.resolve(_this2.constructCommitValueToOperationLookupMap(operationsByType.updateOperations)).then(function (updateCommitValueToOperationMap) {
                return Promise.resolve(_this2.applyUpdateOperations(didState, updateCommitValueToOperationMap)).then(function (_this$applyUpdateOper) {
                  didState = _this$applyUpdateOper;
                  return didState;
                });
              });
            }); // If the previous applied operation is a deactivate. No need to continue further.
          });
        });
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  Resolver.categorizeOperationsByType = function categorizeOperationsByType(operations) {
    var createOperations = [];
    var recoverOperations = [];
    var updateOperations = [];
    var deactivateOperations = [];

    for (var _iterator = _createForOfIteratorHelperLoose(operations), _step; !(_step = _iterator()).done;) {
      var operation = _step.value;

      if (operation.type === OperationType.Create) {
        createOperations.push(operation);
      } else if (operation.type === OperationType.Recover) {
        recoverOperations.push(operation);
      } else if (operation.type === OperationType.Update) {
        updateOperations.push(operation);
      } else {
        // This is a deactivate operation.
        deactivateOperations.push(operation);
      }
    }

    return {
      createOperations: createOperations,
      recoverOperations: recoverOperations,
      updateOperations: updateOperations,
      deactivateOperations: deactivateOperations
    };
  }
  /**
   * Iterate through all duplicates of creates until we can construct an initial DID state (some creates maybe incomplete. eg. without `delta`).
   */
  ;

  _proto.applyCreateOperation = function applyCreateOperation(createOperations) {
    try {
      var _interrupt2 = false;

      var _this4 = this;

      var didState;

      var _temp2 = _forOf(createOperations, function (createOperation) {
        return Promise.resolve(_this4.applyOperation(createOperation, undefined)).then(function (_this3$applyOperation) {
          didState = _this3$applyOperation;

          if (didState !== undefined) {
            _interrupt2 = true;
          }
        }); // Exit loop as soon as we can construct an initial state.
      }, function () {
        return _interrupt2;
      });

      return Promise.resolve(_temp2 && _temp2.then ? _temp2.then(function () {
        return didState;
      }) : didState);
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * Apply recovery/deactivate operations until an operation matching the next recovery commitment cannot be found.
   */
  ;

  _proto.applyRecoverAndDeactivateOperations = function applyRecoverAndDeactivateOperations(startingDidState, commitValueToOperationMap) {
    try {
      var _exit2 = false,
          _interrupt4 = false;

      var _this6 = this;

      var didState = startingDidState;

      var _temp4 = _for(function () {
        return !(_interrupt4 || _exit2) && !!commitValueToOperationMap.has(didState.nextRecoveryCommitmentHash);
      }, void 0, function () {
        var operationsWithCorrectRevealValue = commitValueToOperationMap.get(didState.nextRecoveryCommitmentHash); // Sort using blockchain time.

        operationsWithCorrectRevealValue = operationsWithCorrectRevealValue.sort(function (a, b) {
          return a.transactionNumber - b.transactionNumber;
        });
        return Promise.resolve(_this6.applyFirstValidOperation(operationsWithCorrectRevealValue, didState)).then(function (newDidState) {
          // We are done if we can't find a valid recover/deactivate operation to apply.
          if (newDidState === undefined) {
            _interrupt4 = true;
            return;
          } // We reach here if we have successfully computed a new DID state.


          didState = newDidState; // If the previous applied operation is a deactivate. No need to continue further.

          if (didState.nextRecoveryCommitmentHash === undefined) {
            _exit2 = true;
            return didState;
          }
        });
      });

      return Promise.resolve(_temp4 && _temp4.then ? _temp4.then(function (_result) {
        return _exit2 ? _result : didState;
      }) : _exit2 ? _temp4 : didState);
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * Apply update operations until an operation matching the next update commitment cannot be found.
   */
  ;

  _proto.applyUpdateOperations = function applyUpdateOperations(startingDidState, commitValueToOperationMap) {
    try {
      var _interrupt6 = false;

      var _this8 = this;

      var didState = startingDidState;

      var _temp6 = _for(function () {
        return !_interrupt6 && !!commitValueToOperationMap.has(didState.nextUpdateCommitmentHash);
      }, void 0, function () {
        var operationsWithCorrectRevealValue = commitValueToOperationMap.get(didState.nextUpdateCommitmentHash); // Sort using blockchain time.

        operationsWithCorrectRevealValue = operationsWithCorrectRevealValue.sort(function (a, b) {
          return a.transactionNumber - b.transactionNumber;
        });
        return Promise.resolve(_this8.applyFirstValidOperation(operationsWithCorrectRevealValue, didState)).then(function (newDidState) {
          // We are done if we can't find a valid update operation to apply.
          if (newDidState === undefined) {
            _interrupt6 = true;
            return;
          } // We reach here if we have successfully computed a new DID state.


          didState = newDidState;
        });
      });

      return Promise.resolve(_temp6 && _temp6.then ? _temp6.then(function () {
        return didState;
      }) : didState);
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * Applies the given operation to the given DID state.
   * @param operation The operation to be applied.
   * @param didState The DID state to apply the operation on top of.
   * @returns The resultant `DidState`. The given DID state is return if the given operation cannot be applied.
   */
  ;

  _proto.applyOperation = function applyOperation(operation, didState) {
    try {
      var _this10 = this;

      var appliedDidState = didState; // NOTE: MUST NOT throw error, else a bad operation can be used to denial resolution for a DID.

      var _temp8 = _catch(function () {
        var operationProcessor = _this10.versionManager.getOperationProcessor(operation.transactionTime);

        return Promise.resolve(operationProcessor.apply(operation, appliedDidState)).then(function (_operationProcessor$a) {
          appliedDidState = _operationProcessor$a;
        });
      }, function (error) {
        console.log("Skipped bad operation for DID " + operation.didUniqueSuffix + " at time " + operation.transactionTime + ". Error: " + SidetreeError.stringify(error));
      });

      return Promise.resolve(_temp8 && _temp8.then ? _temp8.then(function () {
        return appliedDidState;
      }) : appliedDidState);
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * @returns The new DID State if a valid operation is applied, `undefined` otherwise.
   */
  ;

  _proto.applyFirstValidOperation = function applyFirstValidOperation(operations, originalDidState) {
    try {
      var _exit4 = false;

      var _this12 = this;

      var newDidState = originalDidState; // Stop as soon as an operation is applied successfully.

      var _temp10 = _forOf(operations, function (operation) {
        return Promise.resolve(_this12.applyOperation(operation, newDidState)).then(function (_this11$applyOperatio) {
          newDidState = _this11$applyOperatio;

          if (newDidState.lastOperationTransactionNumber !== originalDidState.lastOperationTransactionNumber) {
            _exit4 = true;
            return newDidState;
          }
        }); // If operation matching the recovery commitment is applied.
      }, function () {
        return _exit4;
      });

      return Promise.resolve(_temp10 && _temp10.then ? _temp10.then(function (_result2) {
        return _exit4 ? _result2 : undefined;
      }) : _exit4 ? _temp10 : undefined); // Else we reach the end of operations without being able to apply any of them.
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * Constructs a single commit value -> operation lookup map by looping through each supported hash algorithm,
   * hashing each operations as key, then adding the result to a map.
   */
  ;

  _proto.constructCommitValueToOperationLookupMap = function constructCommitValueToOperationLookupMap(nonCreateOperations) {
    try {
      var _this14 = this;

      var commitValueToOperationMap = new Map(); // Loop through each supported algorithm and hash each operation.

      var allSupportedHashAlgorithms = _this14.versionManager.allSupportedHashAlgorithms;

      var _temp13 = _forOf(allSupportedHashAlgorithms, function (hashAlgorithm) {
        var _temp11 = _forOf(nonCreateOperations, function (operation) {
          var operationProcessor = _this14.versionManager.getOperationProcessor(operation.transactionTime);

          return Promise.resolve(operationProcessor.getRevealValue(operation)).then(function (revealValueBuffer) {
            var hashOfRevealValue = Multihash.hashThenEncode(revealValueBuffer, hashAlgorithm);

            if (commitValueToOperationMap.has(hashOfRevealValue)) {
              commitValueToOperationMap.get(hashOfRevealValue).push(operation);
            } else {
              commitValueToOperationMap.set(hashOfRevealValue, [operation]);
            }
          });
        });

        if (_temp11 && _temp11.then) return _temp11.then(function () {});
      });

      return Promise.resolve(_temp13 && _temp13.then ? _temp13.then(function () {
        return commitValueToOperationMap;
      }) : commitValueToOperationMap);
    } catch (e) {
      return Promise.reject(e);
    }
  };

  return Resolver;
}();

/*
 * The code in this file originated from
 * @see https://github.com/decentralized-identity/sidetree
 * For the list of changes that was made to the original code
 * @see https://github.com/transmute-industries/sidetree.js/blob/master/reference-implementation-changes.md
 *
 * Copyright 2020 - Transmute Industries Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Encapsulates the functionality to get the information about the service such as
 * version info.
 */
var ServiceInfoProvider = /*#__PURE__*/function () {
  function ServiceInfoProvider(serviceName) {
    this.serviceName = serviceName;
  }
  /**
   * Gets the service version from the package.json file.
   */


  var _proto = ServiceInfoProvider.prototype;

  _proto.getServiceVersion = function getServiceVersion() {
    return {
      name: this.serviceName,
      version: ServiceInfoProvider.packageJson.version
    };
  };

  return ServiceInfoProvider;
}();
ServiceInfoProvider.packageJson = /*#__PURE__*/require('../package.json');

/**
 * The class that handles the loading of different versions of protocol codebase.
 */

var VersionManager = /*#__PURE__*/function () {
  function VersionManager(config, protocolVersions) {
    this.config = config;
    this.allSupportedHashAlgorithms = []; // Reverse sort protocol versions.

    this.protocolVersionsReverseSorted = protocolVersions.sort(function (a, b) {
      return b.startingBlockchainTime - a.startingBlockchainTime;
    });
    this.batchWriters = new Map();
    this.operationProcessors = new Map();
    this.operationQueues = new Map();
    this.requestHandlers = new Map();
    this.transactionProcessors = new Map();
    this.transactionSelectors = new Map();
    this.versionMetadatas = new Map();
  }
  /**
   * Loads all the versions of the protocol codebase.
   */


  var _proto = VersionManager.prototype;

  _proto.initialize = function initialize(blockchain, cas, downloadManager, operationStore, resolver, transactionStore) {
    try {
      var _temp3 = function _temp3(_result) {
        if (_exit2) return _result;
        // Get and cache supported hash algorithms.
        var hashAlgorithmsWithDuplicates = Array.from(_this2.versionMetadatas.values(), function (value) {
          return value.hashAlgorithmInMultihashCode;
        });
        _this2.allSupportedHashAlgorithms = Array.from(new Set(hashAlgorithmsWithDuplicates)); // This line removes duplicates.
      };

      var _exit2 = false;

      var _this2 = this;

      var _temp4 = _forOf(_this2.protocolVersionsReverseSorted, function (protocolVersion) {
        var version = protocolVersion.version;
        /* tslint:disable-next-line */

        return Promise.resolve(_this2.loadDefaultExportsForVersion(version, 'MongoDbOperationQueue')).then(function (MongoDbOperationQueue) {
          var operationQueue = new MongoDbOperationQueue(_this2.config.mongoDbConnectionString, _this2.config.databaseName);
          return Promise.resolve(operationQueue.initialize()).then(function () {
            _this2.operationQueues.set(version, operationQueue);
            /* tslint:disable-next-line */


            return Promise.resolve(_this2.loadDefaultExportsForVersion(version, 'TransactionProcessor')).then(function (TransactionProcessor) {
              var transactionProcessor = new TransactionProcessor(downloadManager, operationStore, blockchain, _this2);

              _this2.transactionProcessors.set(version, transactionProcessor);
              /* tslint:disable-next-line */


              return Promise.resolve(_this2.loadDefaultExportsForVersion(version, 'TransactionSelector')).then(function (TransactionSelector) {
                var transactionSelector = new TransactionSelector(transactionStore);

                _this2.transactionSelectors.set(version, transactionSelector);
                /* tslint:disable-next-line */


                return Promise.resolve(_this2.loadDefaultExportsForVersion(version, 'BatchWriter')).then(function (BatchWriter) {
                  var batchWriter = new BatchWriter(operationQueue, blockchain, cas, _this2);

                  _this2.batchWriters.set(version, batchWriter);
                  /* tslint:disable-next-line */


                  return Promise.resolve(_this2.loadDefaultExportsForVersion(version, 'OperationProcessor')).then(function (OperationProcessor) {
                    var operationProcessor = new OperationProcessor();

                    _this2.operationProcessors.set(version, operationProcessor);
                    /* tslint:disable-next-line */


                    return Promise.resolve(_this2.loadDefaultExportsForVersion(version, 'RequestHandler')).then(function (RequestHandler) {
                      var requestHandler = new RequestHandler(resolver, operationQueue, _this2.config.didMethodName);

                      _this2.requestHandlers.set(version, requestHandler);
                      /* tslint:disable-next-line */


                      return Promise.resolve(_this2.loadDefaultExportsForVersion(version, 'VersionMetadata')).then(function (VersionMetadata) {
                        var versionMetadata = new VersionMetadata();

                        if (!(versionMetadata instanceof AbstractVersionMetadata)) {
                          throw new SidetreeError(CoreErrorCode.VersionManagerVersionMetadataIncorrectType, "make sure VersionMetaData is properly implemented for version " + version);
                        }

                        _this2.versionMetadatas.set(version, versionMetadata);
                      });
                    });
                  });
                });
              });
            });
          });
        });
      }, function () {
        return _exit2;
      });

      // Instantiate rest of the protocol components.
      // NOTE: In principal each version of the interface implemtnations can have different constructors,
      // but we currently keep the constructor signature the same as much as possible for simple instance construction,
      // but it is not inherently "bad" if we have to have conditional constructions for each if we have to.
      return Promise.resolve(_temp4 && _temp4.then ? _temp4.then(_temp3) : _temp3(_temp4));
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * Gets the corresponding version of the `IBatchWriter` based on the given blockchain time.
   */
  ;

  _proto.getBatchWriter = function getBatchWriter(blockchainTime) {
    var version = this.getVersionString(blockchainTime);
    var batchWriter = this.batchWriters.get(version);

    if (batchWriter === undefined) {
      throw new SidetreeError(CoreErrorCode.VersionManagerBatchWriterNotFound, "Batch writer for blockchain time " + blockchainTime + " not found.");
    }

    return batchWriter;
  }
  /**
   * Gets the corresponding version of the `IOperationProcessor` based on the given blockchain time.
   */
  ;

  _proto.getOperationProcessor = function getOperationProcessor(blockchainTime) {
    var version = this.getVersionString(blockchainTime);
    var operationProcessor = this.operationProcessors.get(version);

    if (operationProcessor === undefined) {
      throw new SidetreeError(CoreErrorCode.VersionManagerOperationProcessorNotFound, "Operation processor for blockchain time " + blockchainTime + " not found.");
    }

    return operationProcessor;
  }
  /**
   * Gets the corresponding version of the `IRequestHandler` based on the given blockchain time.
   */
  ;

  _proto.getRequestHandler = function getRequestHandler(blockchainTime) {
    var version = this.getVersionString(blockchainTime);
    var requestHandler = this.requestHandlers.get(version);

    if (requestHandler === undefined) {
      throw new SidetreeError(CoreErrorCode.VersionManagerRequestHandlerNotFound, "Request handler for blockchain time " + blockchainTime + " not found.");
    }

    return requestHandler;
  }
  /**
   * Gets the corresponding version of the `TransactionProcessor` based on the given blockchain time.
   */
  ;

  _proto.getTransactionProcessor = function getTransactionProcessor(blockchainTime) {
    var version = this.getVersionString(blockchainTime);
    var transactionProcessor = this.transactionProcessors.get(version);

    if (transactionProcessor === undefined) {
      throw new SidetreeError(CoreErrorCode.VersionManagerTransactionProcessorNotFound, "Transaction processor for blockchain time " + blockchainTime + " not found.");
    }

    return transactionProcessor;
  }
  /**
   * Gets the corresponding version of the `TransactionSelector` based on the given blockchain time.
   */
  ;

  _proto.getTransactionSelector = function getTransactionSelector(blockchainTime) {
    var version = this.getVersionString(blockchainTime);
    var transactionSelector = this.transactionSelectors.get(version);

    if (transactionSelector === undefined) {
      throw new SidetreeError(CoreErrorCode.VersionManagerTransactionSelectorNotFound, "Transaction selector for blockchain time " + blockchainTime + " not found.");
    }

    return transactionSelector;
  };

  _proto.getVersionMetadata = function getVersionMetadata(blockchainTime) {
    var versionString = this.getVersionString(blockchainTime);
    var versionMetadata = this.versionMetadatas.get(versionString); // this is always be defined because if blockchain time is found, version will be defined

    return versionMetadata;
  };

  _proto.getOperationQueue = function getOperationQueue(blockchainTime) {
    var versionString = this.getVersionString(blockchainTime);
    var operationQueue = this.operationQueues.get(versionString); // this is always be defined because if blockchain time is found, version will be defined

    return operationQueue;
  }
  /**
   * Gets the corresponding protocol version string given the blockchain time.
   */
  ;

  _proto.getVersionString = function getVersionString(blockchainTime) {
    // Iterate through each version to find the right version.
    for (var _iterator = _createForOfIteratorHelperLoose(this.protocolVersionsReverseSorted), _step; !(_step = _iterator()).done;) {
      var protocolVersion = _step.value;

      if (blockchainTime >= protocolVersion.startingBlockchainTime) {
        return protocolVersion.version;
      }
    }

    throw new SidetreeError(CoreErrorCode.VersionManagerVersionStringNotFound, "Unable to find version string for blockchain time " + blockchainTime + ".");
  };

  _proto.loadDefaultExportsForVersion = function loadDefaultExportsForVersion(version, className) {
    try {
      var _temp7 = function _temp7(_result2) {
        return _exit4 ? _result2 : Promise.resolve(import("./versions/" + version + "/" + className)).then(function (_import8) {
          return _import8["default"];
        });
      };

      var _exit4 = false;

      var _temp8 = function () {
        if (version === 'latest') {
          switch (className) {
            case 'MongoDbOperationQueue':
              _exit4 = true;
              return Promise.resolve(import('@sidetree/db')).then(function (_import) {
                return _import.MongoDbOperationQueue;
              });

            case 'TransactionProcessor':
              _exit4 = true;
              return Promise.resolve(import('./TransactionProcessor-8f228565.js')).then(function (_import2) {
                return _import2["default"];
              });

            case 'TransactionSelector':
              _exit4 = true;
              return Promise.resolve(import('./TransactionSelector-dc944ebd.js')).then(function (_import3) {
                return _import3["default"];
              });

            case 'BatchWriter':
              _exit4 = true;
              return Promise.resolve(import('./BatchWriter-8680c7f1.js')).then(function (_import4) {
                return _import4["default"];
              });

            case 'OperationProcessor':
              _exit4 = true;
              return Promise.resolve(import('./OperationProcessor-691a8d37.js')).then(function (_import5) {
                return _import5["default"];
              });

            case 'RequestHandler':
              _exit4 = true;
              return Promise.resolve(import('./RequestHandler-b5176f73.js')).then(function (_import6) {
                return _import6["default"];
              });

            case 'VersionMetadata':
              _exit4 = true;
              return Promise.resolve(import('./VersionMetadata-b5920797.js')).then(function (_import7) {
                return _import7["default"];
              });

            default:
              _exit4 = true;
              return;
          }
        }
      }();

      return Promise.resolve(_temp8 && _temp8.then ? _temp8.then(_temp7) : _temp7(_temp8));
    } catch (e) {
      return Promise.reject(e);
    }
  };

  return VersionManager;
}();

export { AnchorFile as A, BatchScheduler as B, ChunkFile as C, DeactivateOperation as D, Jwk as J, MapFile as M, Observer as O, RecoverOperation as R, ServiceInfoProvider as S, UpdateOperation as U, VersionManager as V, _catch as _, CreateOperation as a, DownloadManager as b, Jws as c, Operation as d, OperationGenerator as e, Resolver as f, ArrayMethods as g, _forTo as h, JsonAsync as i, _for as j, _createForOfIteratorHelperLoose as k, DocumentComposer as l, _switch as m, _inheritsLoose as n };
//# sourceMappingURL=index-f6e63a58.js.map
