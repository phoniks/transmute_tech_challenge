import { k as _createForOfIteratorHelperLoose, a as CreateOperation, _ as _catch, m as _switch, i as JsonAsync, d as Operation, l as DocumentComposer } from './index-f6e63a58.js';
import { SidetreeError, ErrorCode, Multihash, OperationType, ResponseStatus, protocolParameters } from '@sidetree/common';
import 'fast-json-patch';
import 'jose';
import 'bip39';
import '@transmute/did-key-ed25519';
import 'hdkey';
import '@trust/keyto';
import '@transmute/did-key-secp256k1';
import 'time-span';
import 'crypto';
import OperationProcessor from './OperationProcessor-691a8d37.js';
import { URL } from 'url';

/**
 * Class containing reusable Sidetree DID related operations.
 */

var Did = /*#__PURE__*/function () {
  /**
   * Parses the input string as Sidetree DID.
   * NOTE: Must not call this constructor directly, use the factory `create` method instead.
   * @param did Short or long-form DID string.
   * @param didMethodName The expected DID method given in the DID string. The method throws SidetreeError if mismatch.
   */
  function Did(did, didMethodName) {
    this.didMethodName = didMethodName;
    var didPrefix = "did:" + didMethodName + ":";

    if (!did.startsWith(didPrefix)) {
      throw new SidetreeError(ErrorCode.DidIncorrectPrefix);
    }

    var indexOfQuestionMarkChar = did.indexOf('?'); // If there is no question mark, then DID can only be in short-form.

    if (indexOfQuestionMarkChar < 0) {
      this.isShortForm = true;
    } else {
      this.isShortForm = false;
    }

    if (this.isShortForm) {
      this.uniqueSuffix = did.substring(didPrefix.length);
    } else {
      // This is long-form.
      this.uniqueSuffix = did.substring(didPrefix.length, indexOfQuestionMarkChar);
    }

    if (this.uniqueSuffix.length === 0) {
      throw new SidetreeError(ErrorCode.DidNoUniqueSuffix);
    }

    this.shortForm = didPrefix + this.uniqueSuffix;
  }
  /**
   * Parses the input string as Sidetree DID.
   * @param didString Short or long-form DID string.
   */


  Did.create = function create(didString, didMethodName) {
    try {
      var _exit2 = false;
      var did = new Did(didString, didMethodName); // If DID is long-form, ensure the unique suffix constructed from the suffix data matches the short-form DID and populate the `createOperation` property.

      var _temp2 = function () {
        if (!did.isShortForm) {
          var initialState = Did.getInitialStateFromDidString(didString, didMethodName);
          return Promise.resolve(Did.constructCreateOperationFromInitialState(initialState)).then(function (createOperation) {
            // NOTE: we cannot use the unique suffix directly from `createOperation.didUniqueSuffix` for comparison,
            // becasue a given long-form DID may have been created long ago,
            // thus this version of `CreateOperation.parse()` maybe using a different hashing algorithm than that of the unique DID suffix (short-form).
            // So we compute the suffix data hash again using the hashing algorithm used by the given unique DID suffix (short-form).
            var suffixDataHashMatchesUniqueSuffix = Multihash.isValidHash(createOperation.encodedSuffixData, did.uniqueSuffix); // If the computed suffix data hash is not the same as the unique suffix given in the DID string, the DID is not valid.

            if (!suffixDataHashMatchesUniqueSuffix) {
              throw new SidetreeError(ErrorCode.DidUniqueSuffixFromInitialStateMismatch);
            }

            did.createOperation = createOperation;
          });
        }
      }();

      return Promise.resolve(_temp2 && _temp2.then ? _temp2.then(function (_result) {
        return _exit2 ? _result : did;
      }) : _exit2 ? _temp2 : did);
    } catch (e) {
      return Promise.reject(e);
    }
  };

  Did.getInitialStateFromDidString = function getInitialStateFromDidString(didString, methodNameWithNetworkId) {
    var didStringUrl = undefined;

    try {
      didStringUrl = new URL(didString);
    } catch (_unused) {
      throw new SidetreeError(ErrorCode.DidInvalidDidString);
    } // TODO: #470 - Support/disambiguate "network ID" in method name.
    // Stripping away the potential network ID portion. e.g. 'sidetree:test' -> 'sidetree'


    var methodName = methodNameWithNetworkId.split(':')[0];
    var queryParamCounter = 0;
    var initialStateValue; // Verify that `-<method-name>-initial-state` is the one and only parameter.

    for (var _iterator = _createForOfIteratorHelperLoose(didStringUrl.searchParams), _step; !(_step = _iterator()).done;) {
      var _step$value = _step.value,
          key = _step$value[0],
          value = _step$value[1];
      queryParamCounter += 1;

      if (queryParamCounter > 1) {
        throw new SidetreeError(ErrorCode.DidLongFormOnlyOneQueryParamAllowed);
      } // expect key to be -<method-name>-initial-state


      var expectedKey = "-" + methodName + "-" + Did.initialStateParameterSuffix;

      if (key !== expectedKey) {
        throw new SidetreeError(ErrorCode.DidLongFormOnlyInitialStateParameterIsAllowed);
      }

      initialStateValue = value;
    }

    if (initialStateValue === undefined) {
      throw new SidetreeError(ErrorCode.DidLongFormNoInitialStateFound);
    }

    return initialStateValue;
  };

  Did.constructCreateOperationFromInitialState = function constructCreateOperationFromInitialState(initialState) {
    try {
      // Initial state should be in the format: <suffix-data>.<delta>
      var firstIndexOfDot = initialState.indexOf('.');

      if (firstIndexOfDot === -1) {
        throw new SidetreeError(ErrorCode.DidInitialStateValueContainsNoDot);
      }

      var lastIndexOfDot = initialState.lastIndexOf('.');

      if (lastIndexOfDot !== firstIndexOfDot) {
        throw new SidetreeError(ErrorCode.DidInitialStateValueContainsMoreThanOneDot);
      }

      if (firstIndexOfDot === initialState.length - 1 || firstIndexOfDot === 0) {
        throw new SidetreeError(ErrorCode.DidInitialStateValueDoesNotContainTwoParts);
      }

      var initialStateParts = initialState.split('.');
      var suffixData = initialStateParts[0];
      var delta = initialStateParts[1];
      var createOperationRequest = {
        type: OperationType.Create,
        suffix_data: suffixData,
        delta: delta
      };
      var createOperationBuffer = Buffer.from(JSON.stringify(createOperationRequest));
      return Promise.resolve(CreateOperation.parseObject(createOperationRequest, createOperationBuffer, false));
    } catch (e) {
      return Promise.reject(e);
    }
  };

  return Did;
}();
Did.initialStateParameterSuffix = 'initial-state';

/**
 * Sidetree operation request handler.
 */

var RequestHandler = /*#__PURE__*/function () {
  function RequestHandler(resolver, operationQueue, didMethodName) {
    this.resolver = resolver;
    this.operationQueue = operationQueue;
    this.didMethodName = didMethodName;
    this.operationProcessor = new OperationProcessor();
  }
  /**
   * Handles an operation request.
   */


  var _proto = RequestHandler.prototype;

  _proto.handleOperationRequest = function handleOperationRequest(request) {
    try {
      var _temp6 = function _temp6(_result) {
        return _exit2 ? _result : _catch(function () {
          function _temp3() {
            var _temp = function () {
              if (response.status === ResponseStatus.Succeeded) {
                return Promise.resolve(_this2.operationQueue.enqueue(operationModel.didUniqueSuffix, operationModel.operationBuffer)).then(function () {});
              }
            }();

            // if the operation was processed successfully, queue the original request buffer for batching.
            return _temp && _temp.then ? _temp.then(function () {
              return response;
            }) : response;
          }

          console.info("Operation type: '" + operationModel.type + "', DID unique suffix: '" + operationModel.didUniqueSuffix + "'"); // Passed common operation validation, hand off to specific operation handler.

          var response;

          var _temp2 = _switch(operationModel.type, [[function () {
            return OperationType.Create;
          }, function () {
            return Promise.resolve(_this2.handleCreateRequest(operationModel)).then(function (_this$handleCreateReq) {
              response = _this$handleCreateReq;
            });
          }], [function () {
            return OperationType.Update;
          }], [function () {
            return OperationType.Recover;
          }], [function () {
            return OperationType.Deactivate;
          }, function () {
            response = {
              status: ResponseStatus.Succeeded
            };
          }], [void 0, function () {
            // Should be an impossible condition, but we defensively check and handle.
            response = {
              status: ResponseStatus.BadRequest,
              body: {
                code: ErrorCode.RequestHandlerUnknownOperationType,
                message: "Unsupported operation type '" + operationModel.type + "'."
              }
            };
          }, function () {}]]);

          return _temp2 && _temp2.then ? _temp2.then(_temp3) : _temp3(_temp2);
        }, function (error) {
          // Give meaningful/specific error code and message when possible.
          if (error instanceof SidetreeError) {
            console.info("Sidetree error: " + error.code + " " + error.message);
            return {
              status: ResponseStatus.BadRequest,
              body: {
                code: error.code,
                message: error.message
              }
            };
          }

          console.info("Unexpected error: " + error);
          return {
            status: ResponseStatus.ServerError
          };
        });
      };

      var _exit2 = false;

      var _this2 = this;

      console.info("Handling operation request of size " + request.length + " bytes..."); // Perform common validation for any write request and parse it into an `OperationModel`.

      var operationModel;

      var _temp7 = _catch(function () {
        return Promise.resolve(JsonAsync.parse(request)).then(function (operationRequest) {
          // Check `delta` property data size if they exist in the operation.
          if (operationRequest.type === OperationType.Create || operationRequest.type === OperationType.Recover || operationRequest.type === OperationType.Update) {
            var deltaBuffer = Buffer.from(operationRequest.delta);

            if (deltaBuffer.length > protocolParameters.maxDeltaSizeInBytes) {
              var errorMessage = "operationDdata byte size of " + deltaBuffer.length + " exceeded limit of " + protocolParameters.maxDeltaSizeInBytes;
              console.info(errorMessage);
              throw new SidetreeError(ErrorCode.RequestHandlerDeltaExceedsMaximumSize, errorMessage);
            }
          }

          return Promise.resolve(Operation.parse(request)).then(function (_Operation$parse) {
            operationModel = _Operation$parse;
            // Reject operation if there is already an operation for the same DID waiting to be batched and anchored.
            return Promise.resolve(_this2.operationQueue.contains(operationModel.didUniqueSuffix)).then(function (_this$operationQueue$) {
              if (_this$operationQueue$) {
                var _errorMessage = "An operation request already exists in queue for DID '" + operationModel.didUniqueSuffix + "', only one is allowed at a time.";

                throw new SidetreeError(ErrorCode.QueueingMultipleOperationsPerDidNotAllowed, _errorMessage);
              }
            });
          });
        });
      }, function (error) {
        // Give meaningful/specific error code and message when possible.
        if (error instanceof SidetreeError) {
          console.info("Bad request: " + error.code);
          console.info("Error message: " + error.message);
          _exit2 = true;
          return {
            status: ResponseStatus.BadRequest,
            body: {
              code: error.code,
              message: error.message
            }
          };
        } // Else we give a generic bad request response.


        console.info("Bad request: " + error);
        _exit2 = true;
        return {
          status: ResponseStatus.BadRequest
        };
      });

      return Promise.resolve(_temp7 && _temp7.then ? _temp7.then(_temp6) : _temp6(_temp7));
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.handleCreateRequest = function handleCreateRequest(operationModel) {
    try {
      var _this4 = this;

      return Promise.resolve(_this4.applyCreateOperation(operationModel)).then(function (didState) {
        // Should be an impossible condition, but we defensively check and handle.
        if (didState === undefined) {
          return {
            status: ResponseStatus.BadRequest,
            body: 'Invalid create operation.'
          };
        }

        var did = "did:" + _this4.didMethodName + ":" + operationModel.didUniqueSuffix;
        var document = DocumentComposer.transformToExternalDocument(didState, did);
        return {
          status: ResponseStatus.Succeeded,
          body: document
        };
      });
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * Handles resolve operation.
   * @param shortOrLongFormDid Can either be:
   *   1. A short-form DID. e.g. 'did:<methodName>:abc' or
   *   2. A long-form DID. e.g. 'did:<methodName>:<unique-portion>?-<methodName>-initial-state=<encoded-original-did-document>'.
   */
  ;

  _proto.handleResolveRequest = function handleResolveRequest(shortOrLongFormDid) {
    try {
      var _this6 = this;

      return Promise.resolve(_catch(function () {
        console.info("Handling resolution request for: " + shortOrLongFormDid + "...");
        return Promise.resolve(Did.create(shortOrLongFormDid, _this6.didMethodName)).then(function (did) {
          function _temp9() {
            if (didState === undefined) {
              return {
                status: ResponseStatus.NotFound
              };
            }

            var document = DocumentComposer.transformToExternalDocument(didState, shortOrLongFormDid);
            return {
              status: ResponseStatus.Succeeded,
              body: document
            };
          }

          var didState;

          var _temp8 = function () {
            if (did.isShortForm) {
              return Promise.resolve(_this6.resolver.resolve(did.uniqueSuffix)).then(function (_this5$resolver$resol) {
                didState = _this5$resolver$resol;
              });
            } else {
              return Promise.resolve(_this6.resolveLongFormDid(did)).then(function (_this5$resolveLongFor) {
                didState = _this5$resolveLongFor;
              });
            }
          }();

          return _temp8 && _temp8.then ? _temp8.then(_temp9) : _temp9(_temp8);
        });
      }, function (error) {
        // Give meaningful/specific error code and message when possible.
        if (error instanceof SidetreeError) {
          return {
            status: ResponseStatus.BadRequest,
            body: {
              code: error.code,
              message: error.message
            }
          };
        }

        console.info("Unexpected error: " + error);
        return {
          status: ResponseStatus.ServerError
        };
      }));
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * Resolves the given long-form DID by resolving using operations found over the network first;
   * if no operations found, the given create operation will is used to construct the DID state.
   */
  ;

  _proto.resolveLongFormDid = function resolveLongFormDid(did) {
    try {
      var _this8 = this;

      // Attempt to resolve the DID by using operations found from the network first.
      return Promise.resolve(_this8.resolver.resolve(did.uniqueSuffix)).then(function (didState) {
        return didState !== undefined ? didState : Promise.resolve(_this8.applyCreateOperation(did.createOperation)).then(function (_this7$applyCreateOpe) {
          didState = _this7$applyCreateOpe;
          return didState;
        });
      }); // If DID state found then return it.
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.applyCreateOperation = function applyCreateOperation(createOperation) {
    try {
      var _this10 = this;

      var operationWithMockedAnchorTime = {
        didUniqueSuffix: createOperation.didUniqueSuffix,
        type: OperationType.Create,
        transactionTime: 0,
        transactionNumber: 0,
        operationIndex: 0,
        operationBuffer: createOperation.operationBuffer
      }; // NOTE: The transaction timing does not matter here, we are just computing a "theoretical" document if it were anchored on blockchain.

      return Promise.resolve(_this10.operationProcessor.apply(operationWithMockedAnchorTime, undefined));
    } catch (e) {
      return Promise.reject(e);
    }
  };

  return RequestHandler;
}();

export default RequestHandler;
//# sourceMappingURL=RequestHandler-b5176f73.js.map
