{"version":3,"file":"did-key-ed25519.cjs.production.min.js","sources":["../src/EdDSA.ts","../src/keyUtils.ts","../src/Ed25519KeyPair.ts","../src/driver.ts"],"sourcesContent":["import base64url from 'base64url';\n\nimport * as ed25519 from '@stablelib/ed25519';\n\nimport canonicalize from 'canonicalize';\n\nclass JWSVerificationFailed extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'JWSVerificationFailed';\n  }\n}\n\nconst _jwkToSecretKey = (jwk: any) => {\n  const d = base64url.toBuffer(jwk.d);\n  const x = base64url.toBuffer(jwk.x);\n  const secretKey = new Uint8Array(Buffer.concat([d, x]));\n  return secretKey;\n};\n\nconst _jwkToPublicKey = (jwk: any) => {\n  const x = base64url.toBuffer(jwk.x);\n  const publicKey = new Uint8Array(x);\n  return publicKey;\n};\n\nexport const decode = (jws: string, options = { complete: false }) => {\n  const [encodedHeader, encodedPayload, encodedSignature] = jws.split('.');\n\n  if (options.complete) {\n    return {\n      header: JSON.parse(base64url.decode(encodedHeader)),\n      payload: JSON.parse(base64url.decode(encodedPayload)),\n      signature: encodedSignature,\n    };\n  }\n  return JSON.parse(base64url.decode(encodedPayload));\n};\n\nexport const sign = (\n  payload: any,\n  privateKeyJwk: any,\n  header: any = {\n    alg: 'EdDSA',\n  }\n) => {\n  const secretKey = _jwkToSecretKey(privateKeyJwk);\n  const encodedHeader = base64url.encode(canonicalize(header));\n  const encodedPayload = base64url.encode(canonicalize(payload));\n  const message = new Uint8Array(\n    Buffer.from(`${encodedHeader}.${encodedPayload}`)\n  );\n  const signature = ed25519.sign(secretKey, message);\n  const encodedSignature = base64url.encode(Buffer.from(signature));\n  const jws = `${encodedHeader}.${encodedPayload}.${encodedSignature}`;\n  return jws;\n};\n\nexport const signDetached = (\n  payload: Buffer,\n  privateKeyJwk: any,\n  header: any = {\n    alg: 'EdDSA',\n  }\n) => {\n  const secretKey = _jwkToSecretKey(privateKeyJwk);\n  const encodedHeader = base64url.encode(canonicalize(header));\n  const message = new Uint8Array(\n    Buffer.concat([\n      Buffer.from(encodedHeader, 'utf-8'),\n      Buffer.from('.', 'utf-8'),\n      payload,\n    ])\n  );\n  const signature = ed25519.sign(secretKey, message);\n  const encodedSignature = base64url.encode(Buffer.from(signature));\n  const jws = `${encodedHeader}..${encodedSignature}`;\n  return jws;\n};\n\nexport const verify = (jws: string, publicKeyJwk: any) => {\n  const publicKey = _jwkToPublicKey(publicKeyJwk);\n  const [encodedHeader, encodedPayload, encodedSignature] = jws.split('.');\n\n  const message = new Uint8Array(\n    Buffer.from(`${encodedHeader}.${encodedPayload}`)\n  );\n  const verified = ed25519.verify(\n    publicKey,\n    message,\n    new Uint8Array(base64url.toBuffer(encodedSignature))\n  );\n\n  if (verified) {\n    return JSON.parse(base64url.decode(encodedPayload));\n  }\n\n  throw new JWSVerificationFailed('signature verification failed');\n};\n\nexport const verifyDetached = (\n  jws: string,\n  payload: Buffer,\n  publicKeyJwk: any\n) => {\n  const publicKey = _jwkToPublicKey(publicKeyJwk);\n  const [encodedHeader, encodedSignature] = jws.split('..');\n  const message = new Uint8Array(\n    Buffer.concat([\n      Buffer.from(encodedHeader, 'utf-8'),\n      Buffer.from('.', 'utf-8'),\n      payload,\n    ])\n  );\n  const verified = ed25519.verify(\n    publicKey,\n    message,\n    new Uint8Array(base64url.toBuffer(encodedSignature))\n  );\n  return verified;\n};\n\nexport default {\n  decode,\n\n  sign,\n  signDetached,\n\n  verify,\n  verifyDetached,\n};\n","// https://github.com/transmute-industries/json-ld-sig-detached-jws/blob/master/src/utils.js\nimport bs58 from 'bs58';\nimport base64url from 'base64url';\nimport crypto from 'crypto';\nimport canonicalize from 'canonicalize';\n\nexport const getKid = (jwk: any) => {\n  const copy = { ...jwk } as any;\n  delete copy.d;\n  delete copy.kid;\n  delete copy.alg;\n  const digest = crypto\n    .createHash('sha256')\n    .update(canonicalize(copy))\n    .digest();\n  return base64url.encode(Buffer.from(digest));\n};\n\nexport const publicKeyBase58FromPublicKeyHex = (publicKeyHex: string) => {\n  return bs58.encode(Buffer.from(publicKeyHex, 'hex'));\n};\n\nexport const privateKeyBase58FromPrivateKeyHex = (privateKeyHex: string) => {\n  return bs58.encode(Buffer.from(privateKeyHex, 'hex'));\n};\n\nexport const publicKeyJwkFromPublicKeyBase58 = (publicKeyBase58: string) => {\n  const jwk = {\n    crv: 'Ed25519',\n    x: base64url.encode(bs58.decode(publicKeyBase58)),\n    kty: 'OKP',\n  };\n  const kid = getKid(jwk);\n  return {\n    ...jwk,\n    kid,\n  };\n};\n\nexport const privateKeyJwkFromPrivateKeyBase58 = (privateKeyBase58: string) => {\n  const privateKeyBuf = bs58.decode(privateKeyBase58);\n  const jwk = {\n    crv: 'Ed25519',\n    d: base64url.encode(privateKeyBuf.slice(0, 32)),\n    x: base64url.encode(privateKeyBuf.slice(32, 64)),\n    kty: 'OKP',\n  };\n  const kid = getKid(jwk);\n  return {\n    ...jwk,\n    kid,\n  };\n};\n\nexport const publicKeyBase58FromPublicKeyJwk = (publicKeyJwk: any) => {\n  return bs58.encode(base64url.toBuffer(publicKeyJwk.x));\n};\n\nexport const privateKeyBase58FromPrivateKeyJwk = (privateKeyJwk: any) => {\n  return bs58.encode(\n    Buffer.concat([\n      base64url.toBuffer(privateKeyJwk.d),\n      base64url.toBuffer(privateKeyJwk.x),\n    ])\n  );\n};\n\nexport const publicKeyHexFromPublicKeyBase58 = (publicKeyBase58: string) => {\n  return bs58.decode(publicKeyBase58).toString('hex');\n};\n\nexport const privateKeyHexFromPrivateKeyBase58 = (privateKeyBase58: string) => {\n  return bs58.decode(privateKeyBase58).toString('hex');\n};\n","import bs58 from 'bs58';\n\nimport * as ed25519 from '@stablelib/ed25519';\nimport * as keyUtils from './keyUtils';\n\nimport * as common from '@transmute/did-key-common';\n\nimport { X25519KeyPair } from '@transmute/did-key-x25519';\n\n@common.types.staticImplements<common.types.KeyPairClass>()\nexport class Ed25519KeyPair {\n  public id: string;\n  public type: string;\n  public controller: string;\n\n  public publicKeyBuffer: Buffer;\n  public privateKeyBuffer?: Buffer;\n\n  static fingerprintFromPublicKey(\n    keypair: common.types.KeyPairJwk | common.types.KeyPairBase58\n  ) {\n    let pubkeyBytes: any;\n\n    if ((keypair as any).publicKeyBase58) {\n      pubkeyBytes = bs58.decode(\n        (keypair as common.types.KeyPairBase58).publicKeyBase58\n      );\n    }\n\n    if ((keypair as any).publicKeyJwk) {\n      pubkeyBytes = bs58.decode(\n        keyUtils.publicKeyBase58FromPublicKeyJwk(\n          (keypair as common.types.KeyPairJwk).publicKeyJwk\n        )\n      );\n    }\n    // ed25519 cryptonyms are multicodec encoded values, specifically:\n    // (multicodec ed25519-pub 0xed01 + key bytes)\n\n    const buffer = new Uint8Array(2 + pubkeyBytes.length);\n    buffer[0] = 0xed;\n    buffer[1] = 0x01;\n    buffer.set(pubkeyBytes, 2);\n    // prefix with `z` to indicate multi-base base58btc encoding\n    return `z${bs58.encode(buffer)}`;\n  }\n  static async generate(options: common.types.KeyPairGenerateOptions) {\n    let key;\n    if (options.secureRandom) {\n      key = ed25519.generateKeyPair({\n        isAvailable: true,\n        randomBytes: options.secureRandom,\n      });\n    } else {\n      throw new Error('options.secureRandom is required.');\n    }\n\n    const publicKeyBase58 = bs58.encode(key.publicKey);\n    const privateKeyBase58 = bs58.encode(key.secretKey);\n\n    const did = `did:key:${Ed25519KeyPair.fingerprintFromPublicKey({\n      publicKeyBase58,\n    } as any)}`;\n    const keyId = `#${Ed25519KeyPair.fingerprintFromPublicKey({\n      publicKeyBase58,\n    } as any)}`;\n    return new Ed25519KeyPair({\n      id: keyId,\n      controller: did,\n      publicKeyBase58,\n      privateKeyBase58,\n    });\n  }\n\n  static fromFingerprint({ fingerprint }: any) {\n    // skip leading `z` that indicates base58 encoding\n    const buffer = bs58.decode(fingerprint.substr(1));\n    // https://github.com/multiformats/multicodec/blob/master/table.csv#L81\n    if (buffer[0] === 0xed && buffer[1] === 0x01) {\n      const publicKeyBase58 = bs58.encode(buffer.slice(2));\n      const did = `did:key:${Ed25519KeyPair.fingerprintFromPublicKey({\n        publicKeyBase58,\n      } as any)}`;\n      const keyId = `#${Ed25519KeyPair.fingerprintFromPublicKey({\n        publicKeyBase58,\n      } as any)}`;\n      return new Ed25519KeyPair({\n        id: keyId,\n        controller: did,\n        publicKeyBase58,\n      });\n    }\n\n    throw new Error(`Unsupported Fingerprint Type: ${fingerprint}`);\n  }\n  // todo: consider moving this type conversion cancer to common.\n  static from(options: common.types.KeyPairBase58 | common.types.KeyPairJwk) {\n    let privateKeyBase58;\n    let publicKeyBase58;\n\n    if ((options as common.types.KeyPairBase58).publicKeyBase58) {\n      publicKeyBase58 = (options as common.types.KeyPairBase58).publicKeyBase58;\n    }\n\n    if ((options as common.types.KeyPairBase58).privateKeyBase58) {\n      privateKeyBase58 = (options as common.types.KeyPairBase58)\n        .privateKeyBase58;\n    }\n\n    if ((options as common.types.KeyPairJwk).privateKeyJwk) {\n      privateKeyBase58 = keyUtils.privateKeyBase58FromPrivateKeyJwk(\n        (options as common.types.KeyPairJwk).privateKeyJwk\n      );\n    }\n\n    if ((options as common.types.KeyPairJwk).publicKeyJwk) {\n      publicKeyBase58 = keyUtils.publicKeyBase58FromPublicKeyJwk(\n        (options as common.types.KeyPairJwk).publicKeyJwk\n      );\n    }\n\n    return new Ed25519KeyPair({\n      ...options,\n      privateKeyBase58,\n      publicKeyBase58,\n    });\n  }\n\n  constructor(options: any = {}) {\n    this.type = 'Ed25519VerificationKey2018';\n    this.id = options.id;\n    this.controller = options.controller;\n\n    if (options.publicKeyBase58) {\n      this.publicKeyBuffer = bs58.decode(options.publicKeyBase58);\n    } else if (options.publicKeyJwk) {\n      this.publicKeyBuffer = bs58.decode(\n        keyUtils.publicKeyBase58FromPublicKeyJwk(options.publicKeyJwk)\n      );\n    } else {\n      throw new Error(\n        'Ed25519KeyPair requires publicKeyBase58 or publicKeyJwk, recieved neither.'\n      );\n    }\n\n    if (options.privateKeyBase58) {\n      this.privateKeyBuffer = bs58.decode(options.privateKeyBase58);\n    }\n\n    if (this.controller && !this.id) {\n      this.id = `${this.controller}#${this.fingerprint()}`;\n    }\n  }\n\n  publicNode() {\n    return this.toKeyPair(false);\n  }\n\n  fingerprint() {\n    return Ed25519KeyPair.fingerprintFromPublicKey({\n      publicKeyBase58: bs58.encode(this.publicKeyBuffer),\n    } as any);\n  }\n  verifyFingerprint(fingerprint: any) {\n    // fingerprint should have `z` prefix indicating\n    // that it's multi-base encoded\n    if (!(typeof fingerprint === 'string' && fingerprint[0] === 'z')) {\n      return {\n        error: new Error('`fingerprint` must be a multibase encoded string.'),\n        valid: false,\n      };\n    }\n    let fingerprintBuffer;\n    try {\n      fingerprintBuffer = bs58.decode(fingerprint.slice(1));\n    } catch (e) {\n      return { error: e, valid: false };\n    }\n\n    // validate the first two multicodec bytes 0xed01\n    const valid =\n      fingerprintBuffer.slice(0, 2).toString('hex') === 'ed01' &&\n      this.publicKeyBuffer.equals(fingerprintBuffer.slice(2));\n    if (!valid) {\n      return {\n        error: new Error('The fingerprint does not match the public key.'),\n        valid: false,\n      };\n    }\n    return { valid };\n  }\n\n  async toJwk(exportPrivateKey: boolean = false) {\n    if (exportPrivateKey) {\n      return keyUtils.privateKeyJwkFromPrivateKeyBase58(\n        bs58.encode(this.privateKeyBuffer)\n      );\n    }\n    return keyUtils.publicKeyJwkFromPublicKeyBase58(\n      bs58.encode(this.publicKeyBuffer)\n    );\n  }\n\n  toX25519KeyPair(exportPrivateKey: boolean = false) {\n    if (exportPrivateKey) {\n      return X25519KeyPair.fromEdKeyPair({\n        controller: this.controller,\n        publicKeyBase58: bs58.encode(this.publicKeyBuffer),\n        privateKeyBase58: bs58.encode(this.privateKeyBuffer),\n      } as any);\n    } else {\n      return X25519KeyPair.fromEdKeyPair({\n        controller: this.controller,\n        publicKeyBase58: bs58.encode(this.publicKeyBuffer),\n      } as any);\n    }\n  }\n\n  toKeyPair(exportPrivateKey: boolean = false) {\n    const kp: any = {\n      id: this.id,\n      type: this.type,\n      controller: this.controller,\n      publicKeyBase58: bs58.encode(this.publicKeyBuffer),\n    };\n\n    if (exportPrivateKey) {\n      kp.privateKeyBase58 = bs58.encode(this.privateKeyBuffer);\n    }\n    return kp;\n  }\n\n  toJsonWebKeyPair(exportPrivateKey: boolean = false) {\n    const kp: any = {\n      id: this.id,\n      type: 'JsonWebKey2020',\n      controller: this.controller,\n      publicKeyJwk: keyUtils.publicKeyJwkFromPublicKeyBase58(\n        bs58.encode(this.publicKeyBuffer)\n      ),\n    };\n\n    delete kp.publicKeyJwk.kid;\n    if (exportPrivateKey) {\n      kp.privateKeyJwk = keyUtils.privateKeyJwkFromPrivateKeyBase58(\n        bs58.encode(this.privateKeyBuffer)\n      );\n      delete kp.privateKeyJwk.kid;\n    }\n\n    return kp;\n  }\n\n  signer() {\n    if (!this.privateKeyBuffer) {\n      throw new Error('No private key to sign with.');\n    }\n    let { privateKeyBuffer } = this;\n    return {\n      async sign({ data }: any) {\n        const signatureUInt8Array = ed25519.sign(privateKeyBuffer, data);\n        return signatureUInt8Array;\n      },\n    };\n  }\n  verifier() {\n    if (!this.publicKeyBuffer) {\n      throw new Error('No public key to verify with.');\n    }\n    let { publicKeyBuffer } = this;\n    return {\n      async verify({ data, signature }: any) {\n        let verified = false;\n        try {\n          verified = ed25519.verify(publicKeyBuffer, data, signature);\n        } catch (e) {\n          console.error('An error occurred when verifying signature: ', e);\n        }\n        return verified;\n      },\n    };\n  }\n}\n","import { getResolve, getGet } from '@transmute/did-key-common';\n\nimport { Ed25519KeyPair } from './Ed25519KeyPair';\n\nexport const resolve = getResolve(Ed25519KeyPair);\nexport const get = getGet(resolve);\n"],"names":["JWSVerificationFailed","message","name","Error","_jwkToSecretKey","jwk","d","base64url","toBuffer","x","Uint8Array","Buffer","concat","_jwkToPublicKey","decode","jws","options","complete","split","encodedPayload","encodedSignature","header","JSON","parse","payload","signature","sign","privateKeyJwk","alg","secretKey","encodedHeader","encode","canonicalize","from","ed25519","signDetached","verify","publicKeyJwk","publicKey","verifyDetached","getKid","copy","kid","digest","crypto","createHash","update","publicKeyJwkFromPublicKeyBase58","publicKeyBase58","crv","bs58","kty","privateKeyJwkFromPrivateKeyBase58","privateKeyBase58","privateKeyBuf","slice","publicKeyBase58FromPublicKeyJwk","privateKeyBase58FromPrivateKeyJwk","publicKeyHex","privateKeyHex","toString","Ed25519KeyPair","type","id","controller","publicKeyBuffer","keyUtils","privateKeyBuffer","this","fingerprint","fingerprintFromPublicKey","keypair","pubkeyBytes","buffer","length","set","generate","key","secureRandom","isAvailable","randomBytes","did","Ed25519KeyPair_1","keyId","fromFingerprint","substr","publicNode","toKeyPair","verifyFingerprint","error","valid","fingerprintBuffer","e","equals","toJwk","exportPrivateKey","toX25519KeyPair","X25519KeyPair","fromEdKeyPair","kp","toJsonWebKeyPair","signer","data","signatureUInt8Array","verifier","verified","console","common","staticImplements","resolve","getResolve","getGet"],"mappings":"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"}