import base64url from 'base64url';
import { sign as sign$1, verify as verify$1, generateKeyPair } from '@stablelib/ed25519';
import canonicalize from 'canonicalize';
import bs58 from 'bs58';
import crypto from 'crypto';
import { types, getResolve, getGet } from '@transmute/did-key-common';
import { __decorate } from 'tslib';
import { X25519KeyPair } from '@transmute/did-key-x25519';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}

var JWSVerificationFailed = /*#__PURE__*/function (_Error) {
  _inheritsLoose(JWSVerificationFailed, _Error);

  function JWSVerificationFailed(message) {
    var _this;

    _this = _Error.call(this, message) || this;
    _this.name = 'JWSVerificationFailed';
    return _this;
  }

  return JWSVerificationFailed;
}( /*#__PURE__*/_wrapNativeSuper(Error));

var _jwkToSecretKey = function _jwkToSecretKey(jwk) {
  var d = base64url.toBuffer(jwk.d);
  var x = base64url.toBuffer(jwk.x);
  var secretKey = new Uint8Array(Buffer.concat([d, x]));
  return secretKey;
};

var _jwkToPublicKey = function _jwkToPublicKey(jwk) {
  var x = base64url.toBuffer(jwk.x);
  var publicKey = new Uint8Array(x);
  return publicKey;
};

var decode = function decode(jws, options) {
  if (options === void 0) {
    options = {
      complete: false
    };
  }

  var _jws$split = jws.split('.'),
      encodedHeader = _jws$split[0],
      encodedPayload = _jws$split[1],
      encodedSignature = _jws$split[2];

  if (options.complete) {
    return {
      header: JSON.parse(base64url.decode(encodedHeader)),
      payload: JSON.parse(base64url.decode(encodedPayload)),
      signature: encodedSignature
    };
  }

  return JSON.parse(base64url.decode(encodedPayload));
};
var sign = function sign(payload, privateKeyJwk, header) {
  if (header === void 0) {
    header = {
      alg: 'EdDSA'
    };
  }

  var secretKey = _jwkToSecretKey(privateKeyJwk);

  var encodedHeader = base64url.encode(canonicalize(header));
  var encodedPayload = base64url.encode(canonicalize(payload));
  var message = new Uint8Array(Buffer.from(encodedHeader + "." + encodedPayload));
  var signature = sign$1(secretKey, message);
  var encodedSignature = base64url.encode(Buffer.from(signature));
  var jws = encodedHeader + "." + encodedPayload + "." + encodedSignature;
  return jws;
};
var signDetached = function signDetached(payload, privateKeyJwk, header) {
  if (header === void 0) {
    header = {
      alg: 'EdDSA'
    };
  }

  var secretKey = _jwkToSecretKey(privateKeyJwk);

  var encodedHeader = base64url.encode(canonicalize(header));
  var message = new Uint8Array(Buffer.concat([Buffer.from(encodedHeader, 'utf-8'), Buffer.from('.', 'utf-8'), payload]));
  var signature = sign$1(secretKey, message);
  var encodedSignature = base64url.encode(Buffer.from(signature));
  var jws = encodedHeader + ".." + encodedSignature;
  return jws;
};
var verify = function verify(jws, publicKeyJwk) {
  var publicKey = _jwkToPublicKey(publicKeyJwk);

  var _jws$split2 = jws.split('.'),
      encodedHeader = _jws$split2[0],
      encodedPayload = _jws$split2[1],
      encodedSignature = _jws$split2[2];

  var message = new Uint8Array(Buffer.from(encodedHeader + "." + encodedPayload));
  var verified = verify$1(publicKey, message, new Uint8Array(base64url.toBuffer(encodedSignature)));

  if (verified) {
    return JSON.parse(base64url.decode(encodedPayload));
  }

  throw new JWSVerificationFailed('signature verification failed');
};
var verifyDetached = function verifyDetached(jws, payload, publicKeyJwk) {
  var publicKey = _jwkToPublicKey(publicKeyJwk);

  var _jws$split3 = jws.split('..'),
      encodedHeader = _jws$split3[0],
      encodedSignature = _jws$split3[1];

  var message = new Uint8Array(Buffer.concat([Buffer.from(encodedHeader, 'utf-8'), Buffer.from('.', 'utf-8'), payload]));
  var verified = verify$1(publicKey, message, new Uint8Array(base64url.toBuffer(encodedSignature)));
  return verified;
};
var EdDSA = {
  decode: decode,
  sign: sign,
  signDetached: signDetached,
  verify: verify,
  verifyDetached: verifyDetached
};

var EdDSA$1 = {
  __proto__: null,
  decode: decode,
  sign: sign,
  signDetached: signDetached,
  verify: verify,
  verifyDetached: verifyDetached,
  'default': EdDSA
};

var getKid = function getKid(jwk) {
  var copy = _extends({}, jwk);

  delete copy.d;
  delete copy.kid;
  delete copy.alg;
  var digest = crypto.createHash('sha256').update(canonicalize(copy)).digest();
  return base64url.encode(Buffer.from(digest));
};
var publicKeyBase58FromPublicKeyHex = function publicKeyBase58FromPublicKeyHex(publicKeyHex) {
  return bs58.encode(Buffer.from(publicKeyHex, 'hex'));
};
var privateKeyBase58FromPrivateKeyHex = function privateKeyBase58FromPrivateKeyHex(privateKeyHex) {
  return bs58.encode(Buffer.from(privateKeyHex, 'hex'));
};
var publicKeyJwkFromPublicKeyBase58 = function publicKeyJwkFromPublicKeyBase58(publicKeyBase58) {
  var jwk = {
    crv: 'Ed25519',
    x: base64url.encode(bs58.decode(publicKeyBase58)),
    kty: 'OKP'
  };
  var kid = getKid(jwk);
  return _extends({}, jwk, {
    kid: kid
  });
};
var privateKeyJwkFromPrivateKeyBase58 = function privateKeyJwkFromPrivateKeyBase58(privateKeyBase58) {
  var privateKeyBuf = bs58.decode(privateKeyBase58);
  var jwk = {
    crv: 'Ed25519',
    d: base64url.encode(privateKeyBuf.slice(0, 32)),
    x: base64url.encode(privateKeyBuf.slice(32, 64)),
    kty: 'OKP'
  };
  var kid = getKid(jwk);
  return _extends({}, jwk, {
    kid: kid
  });
};
var publicKeyBase58FromPublicKeyJwk = function publicKeyBase58FromPublicKeyJwk(publicKeyJwk) {
  return bs58.encode(base64url.toBuffer(publicKeyJwk.x));
};
var privateKeyBase58FromPrivateKeyJwk = function privateKeyBase58FromPrivateKeyJwk(privateKeyJwk) {
  return bs58.encode(Buffer.concat([base64url.toBuffer(privateKeyJwk.d), base64url.toBuffer(privateKeyJwk.x)]));
};
var publicKeyHexFromPublicKeyBase58 = function publicKeyHexFromPublicKeyBase58(publicKeyBase58) {
  return bs58.decode(publicKeyBase58).toString('hex');
};
var privateKeyHexFromPrivateKeyBase58 = function privateKeyHexFromPrivateKeyBase58(privateKeyBase58) {
  return bs58.decode(privateKeyBase58).toString('hex');
};

var keyUtils = {
  __proto__: null,
  getKid: getKid,
  publicKeyBase58FromPublicKeyHex: publicKeyBase58FromPublicKeyHex,
  privateKeyBase58FromPrivateKeyHex: privateKeyBase58FromPrivateKeyHex,
  publicKeyJwkFromPublicKeyBase58: publicKeyJwkFromPublicKeyBase58,
  privateKeyJwkFromPrivateKeyBase58: privateKeyJwkFromPrivateKeyBase58,
  publicKeyBase58FromPublicKeyJwk: publicKeyBase58FromPublicKeyJwk,
  privateKeyBase58FromPrivateKeyJwk: privateKeyBase58FromPrivateKeyJwk,
  publicKeyHexFromPublicKeyBase58: publicKeyHexFromPublicKeyBase58,
  privateKeyHexFromPrivateKeyBase58: privateKeyHexFromPrivateKeyBase58
};

var Ed25519KeyPair_1;

var Ed25519KeyPair = Ed25519KeyPair_1 = /*#__PURE__*/function () {
  function Ed25519KeyPair(options) {
    if (options === void 0) {
      options = {};
    }

    this.type = 'Ed25519VerificationKey2018';
    this.id = options.id;
    this.controller = options.controller;

    if (options.publicKeyBase58) {
      this.publicKeyBuffer = bs58.decode(options.publicKeyBase58);
    } else if (options.publicKeyJwk) {
      this.publicKeyBuffer = bs58.decode(publicKeyBase58FromPublicKeyJwk(options.publicKeyJwk));
    } else {
      throw new Error('Ed25519KeyPair requires publicKeyBase58 or publicKeyJwk, recieved neither.');
    }

    if (options.privateKeyBase58) {
      this.privateKeyBuffer = bs58.decode(options.privateKeyBase58);
    }

    if (this.controller && !this.id) {
      this.id = this.controller + "#" + this.fingerprint();
    }
  }

  Ed25519KeyPair.fingerprintFromPublicKey = function fingerprintFromPublicKey(keypair) {
    var pubkeyBytes;

    if (keypair.publicKeyBase58) {
      pubkeyBytes = bs58.decode(keypair.publicKeyBase58);
    }

    if (keypair.publicKeyJwk) {
      pubkeyBytes = bs58.decode(publicKeyBase58FromPublicKeyJwk(keypair.publicKeyJwk));
    } // ed25519 cryptonyms are multicodec encoded values, specifically:
    // (multicodec ed25519-pub 0xed01 + key bytes)


    var buffer = new Uint8Array(2 + pubkeyBytes.length);
    buffer[0] = 0xed;
    buffer[1] = 0x01;
    buffer.set(pubkeyBytes, 2); // prefix with `z` to indicate multi-base base58btc encoding

    return "z" + bs58.encode(buffer);
  };

  Ed25519KeyPair.generate = function generate(options) {
    try {
      var key;

      if (options.secureRandom) {
        key = generateKeyPair({
          isAvailable: true,
          randomBytes: options.secureRandom
        });
      } else {
        throw new Error('options.secureRandom is required.');
      }

      var publicKeyBase58 = bs58.encode(key.publicKey);
      var privateKeyBase58 = bs58.encode(key.secretKey);
      var did = "did:key:" + Ed25519KeyPair_1.fingerprintFromPublicKey({
        publicKeyBase58: publicKeyBase58
      });
      var keyId = "#" + Ed25519KeyPair_1.fingerprintFromPublicKey({
        publicKeyBase58: publicKeyBase58
      });
      return Promise.resolve(new Ed25519KeyPair_1({
        id: keyId,
        controller: did,
        publicKeyBase58: publicKeyBase58,
        privateKeyBase58: privateKeyBase58
      }));
    } catch (e) {
      return Promise.reject(e);
    }
  };

  Ed25519KeyPair.fromFingerprint = function fromFingerprint(_ref) {
    var fingerprint = _ref.fingerprint;
    // skip leading `z` that indicates base58 encoding
    var buffer = bs58.decode(fingerprint.substr(1)); // https://github.com/multiformats/multicodec/blob/master/table.csv#L81

    if (buffer[0] === 0xed && buffer[1] === 0x01) {
      var publicKeyBase58 = bs58.encode(buffer.slice(2));
      var did = "did:key:" + Ed25519KeyPair_1.fingerprintFromPublicKey({
        publicKeyBase58: publicKeyBase58
      });
      var keyId = "#" + Ed25519KeyPair_1.fingerprintFromPublicKey({
        publicKeyBase58: publicKeyBase58
      });
      return new Ed25519KeyPair_1({
        id: keyId,
        controller: did,
        publicKeyBase58: publicKeyBase58
      });
    }

    throw new Error("Unsupported Fingerprint Type: " + fingerprint);
  } // todo: consider moving this type conversion cancer to common.
  ;

  Ed25519KeyPair.from = function from(options) {
    var privateKeyBase58;
    var publicKeyBase58;

    if (options.publicKeyBase58) {
      publicKeyBase58 = options.publicKeyBase58;
    }

    if (options.privateKeyBase58) {
      privateKeyBase58 = options.privateKeyBase58;
    }

    if (options.privateKeyJwk) {
      privateKeyBase58 = privateKeyBase58FromPrivateKeyJwk(options.privateKeyJwk);
    }

    if (options.publicKeyJwk) {
      publicKeyBase58 = publicKeyBase58FromPublicKeyJwk(options.publicKeyJwk);
    }

    return new Ed25519KeyPair_1(_extends({}, options, {
      privateKeyBase58: privateKeyBase58,
      publicKeyBase58: publicKeyBase58
    }));
  };

  var _proto = Ed25519KeyPair.prototype;

  _proto.publicNode = function publicNode() {
    return this.toKeyPair(false);
  };

  _proto.fingerprint = function fingerprint() {
    return Ed25519KeyPair_1.fingerprintFromPublicKey({
      publicKeyBase58: bs58.encode(this.publicKeyBuffer)
    });
  };

  _proto.verifyFingerprint = function verifyFingerprint(fingerprint) {
    // fingerprint should have `z` prefix indicating
    // that it's multi-base encoded
    if (!(typeof fingerprint === 'string' && fingerprint[0] === 'z')) {
      return {
        error: new Error('`fingerprint` must be a multibase encoded string.'),
        valid: false
      };
    }

    var fingerprintBuffer;

    try {
      fingerprintBuffer = bs58.decode(fingerprint.slice(1));
    } catch (e) {
      return {
        error: e,
        valid: false
      };
    } // validate the first two multicodec bytes 0xed01


    var valid = fingerprintBuffer.slice(0, 2).toString('hex') === 'ed01' && this.publicKeyBuffer.equals(fingerprintBuffer.slice(2));

    if (!valid) {
      return {
        error: new Error('The fingerprint does not match the public key.'),
        valid: false
      };
    }

    return {
      valid: valid
    };
  };

  _proto.toJwk = function toJwk(exportPrivateKey) {
    if (exportPrivateKey === void 0) {
      exportPrivateKey = false;
    }

    try {
      var _this2 = this;

      if (exportPrivateKey) {
        return Promise.resolve(privateKeyJwkFromPrivateKeyBase58(bs58.encode(_this2.privateKeyBuffer)));
      }

      return Promise.resolve(publicKeyJwkFromPublicKeyBase58(bs58.encode(_this2.publicKeyBuffer)));
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.toX25519KeyPair = function toX25519KeyPair(exportPrivateKey) {
    if (exportPrivateKey === void 0) {
      exportPrivateKey = false;
    }

    if (exportPrivateKey) {
      return X25519KeyPair.fromEdKeyPair({
        controller: this.controller,
        publicKeyBase58: bs58.encode(this.publicKeyBuffer),
        privateKeyBase58: bs58.encode(this.privateKeyBuffer)
      });
    } else {
      return X25519KeyPair.fromEdKeyPair({
        controller: this.controller,
        publicKeyBase58: bs58.encode(this.publicKeyBuffer)
      });
    }
  };

  _proto.toKeyPair = function toKeyPair(exportPrivateKey) {
    if (exportPrivateKey === void 0) {
      exportPrivateKey = false;
    }

    var kp = {
      id: this.id,
      type: this.type,
      controller: this.controller,
      publicKeyBase58: bs58.encode(this.publicKeyBuffer)
    };

    if (exportPrivateKey) {
      kp.privateKeyBase58 = bs58.encode(this.privateKeyBuffer);
    }

    return kp;
  };

  _proto.toJsonWebKeyPair = function toJsonWebKeyPair(exportPrivateKey) {
    if (exportPrivateKey === void 0) {
      exportPrivateKey = false;
    }

    var kp = {
      id: this.id,
      type: 'JsonWebKey2020',
      controller: this.controller,
      publicKeyJwk: publicKeyJwkFromPublicKeyBase58(bs58.encode(this.publicKeyBuffer))
    };
    delete kp.publicKeyJwk.kid;

    if (exportPrivateKey) {
      kp.privateKeyJwk = privateKeyJwkFromPrivateKeyBase58(bs58.encode(this.privateKeyBuffer));
      delete kp.privateKeyJwk.kid;
    }

    return kp;
  };

  _proto.signer = function signer() {
    if (!this.privateKeyBuffer) {
      throw new Error('No private key to sign with.');
    }

    var privateKeyBuffer = this.privateKeyBuffer;
    return {
      sign: function sign(_ref2) {
        var data = _ref2.data;

        try {
          var signatureUInt8Array = sign$1(privateKeyBuffer, data);
          return Promise.resolve(signatureUInt8Array);
        } catch (e) {
          return Promise.reject(e);
        }
      }
    };
  };

  _proto.verifier = function verifier() {
    if (!this.publicKeyBuffer) {
      throw new Error('No public key to verify with.');
    }

    var publicKeyBuffer = this.publicKeyBuffer;
    return {
      verify: function verify(_ref3) {
        var data = _ref3.data,
            signature = _ref3.signature;

        try {
          var verified = false;

          try {
            verified = verify$1(publicKeyBuffer, data, signature);
          } catch (e) {
            console.error('An error occurred when verifying signature: ', e);
          }

          return Promise.resolve(verified);
        } catch (e) {
          return Promise.reject(e);
        }
      }
    };
  };

  return Ed25519KeyPair;
}();

Ed25519KeyPair = Ed25519KeyPair_1 = /*#__PURE__*/__decorate([/*#__PURE__*/types.staticImplements()], Ed25519KeyPair);

var resolve = /*#__PURE__*/getResolve(Ed25519KeyPair);
var get = /*#__PURE__*/getGet(resolve);

var driver = {
  __proto__: null,
  resolve: resolve,
  get: get
};

export { Ed25519KeyPair, EdDSA$1 as EdDSA, driver, keyUtils };
//# sourceMappingURL=did-key-ed25519.esm.js.map
