import { DecryptTransformer } from './DecryptTransformer';
import { EncryptTransformer } from './EncryptTransformer';
export declare class Cipher {
    KeyPairClass: any;
    version: string;
    cipher: any;
    /**
     * Creates a new Cipher instance that can be used to encrypt or decrypt
     * data. A version must be supplied for encrypting data; the version
     * indicates whether a FIPS-compliant algorithm or the latest recommended
     * algorithm will be used.
     *
     * @param {string} [version='recommended'] - `fips` to use a FIPS-compliant
     *   algorithm, `recommended` to use the latest recommended algorithm when
     *   encrypting.
     *
     * @returns {Cipher} A Cipher used to encrypt and decrypt data.
     */
    constructor(KeyPairClass: any);
    /**
     * Creates a TransformStream that will encrypt some data for one or more
     * recipients and output a stream of chunks, each containing an object
     * with the property `jwe` with a JWE value.
     *
     * A list of recipients must be given in the `recipients` array, identified
     * by key agreement keys. An ephemeral ECDH key will be generated and used to
     * derive shared KEKs that will wrap a randomly generated CEK. Each recipient
     * in the `recipients` array will be updated to include the generated
     * ephemeral ECDH key.
     *
     * @param {object} options - The options for the stream.
     * @param {Array} options.recipients - An array of recipients for the
     *   encrypted content.
     * @param {Function} options.keyResolver - A function that returns a Promise
     *   that resolves a key ID to a DH public key.
     * @param {number} [options.chunkSize=1048576] - The size, in bytes,
     *   of the chunks to break the incoming data into.
     *
     * @returns {Promise<TransformStream>} Resolves to a TransformStream.
     */
    createEncryptStream({ recipients, keyResolver, chunkSize }: any): Promise<any>;
    /**
     * Creates a TransformStream that will decrypt one or more chunks, each one
     * that is an object with a `jwe` property that has a JWE as a value. The
     * stream will output chunks of Uint8Arrays consisting of the decrypted
     * data from each chunk.
     *
     * The only JWEs currently supported use an `alg` of `ECDH-ES+A256KW` and
     * `enc` of `A256GCM` or `XC20P`. These parameters refer to data that has been
     * encrypted using a 256-bit AES-GCM or XChaCha20Poly1305 content encryption
     * key (CEK) that has been wrapped using a 256-bit AES-KW key encryption key
     * (KEK) generated via a shared secret between an ephemeral ECDH key and a
     * static ECDH key (ECDH-ES).
     *
     * @param {object} options - Options for createDecryptStream.
     * @param {object} options.keyAgreementKey - A key agreement key API with
     *   `id` and deriveSecret`.
     *
     * @returns {Promise<TransformStream>} Resolves to the TransformStream.
     */
    createDecryptStream({ keyAgreementKey }: any): Promise<any>;
    /**
     * Encrypts some data for one or more recipients and outputs a JWE. The
     * data to encrypt can be given as a Uint8Array or a string.
     *
     * A list of recipients must be given in the `recipients` array, identified
     * by key agreement keys. An ephemeral ECDH key will be generated and used to
     * derive shared KEKs that will wrap a randomly generated CEK. Each recipient
     * in the `recipients` array will be updated to include the generated
     * ephemeral ECDH key.
     *
     * @param {object} options - Options for encrypt.
     * @param {Uint8Array|string} [options.data] - The data to encrypt.
     * @param {Array} options.recipients - An array of recipients for the\
     *   encrypted content.
     * @param {Function} options.keyResolver - A function that returns a Promise
     *   that resolves a key ID to a DH public key.
     *
     * @returns {Promise<object>} Resolves to a JWE.
     */
    encrypt({ data, recipients, keyResolver }: any): Promise<{
        protected: any;
        recipients: any;
        iv: string;
        ciphertext: string;
        tag: string;
    }>;
    /**
     * Encrypts an object. The object will be serialized to JSON and passed
     * to `encrypt`. See `encrypt` for other parameters.
     *
     * @param {object} obj - The object to encrypt.
     *
     * @returns {Promise<object>} Resolves to a JWE.
     */
    encryptObject({ obj, ...rest }: any): Promise<{
        protected: any;
        recipients: any;
        iv: string;
        ciphertext: string;
        tag: string;
    }>;
    /**
     * Decrypts a single JWE.
     *
     * The only JWEs currently supported use an `alg` of `ECDH-ES+A256KW` and
     * `enc` of `A256GCM` or `XC20P`. These parameters refer to data that has been
     * encrypted using a 256-bit AES-GCM or XChaCha20Poly1305 content encryption
     * key (CEK) that has been wrapped using a 256-bit AES-KW key encryption key
     * (KEK) generated via a shared secret between an ephemeral ECDH key and a
     * static ECDH key (ECDH-ES).
     *
     * Note: This version also supports decrypting data that was encrypted using
     * `C20P` (ChaCha20Poly1305) for backwards compatibility.
     *
     * @param {object} options - Options for decrypt.
     * @param {object} options.jwe - The JWE to decrypt.
     * @param {object} options.keyAgreementKey - A key agreement key API with
     *   `id` and `deriveSecret`.
     *
     * @returns {Promise<Uint8Array>} - Resolves to the decrypted data
     *   or `null` if the decryption failed.
     */
    decrypt({ jwe, keyAgreementKey }: any): Promise<any>;
    /**
     * Decrypts a JWE that must contain an encrypted object. This method will
     * call `decrypt` and then `JSON.parse` the resulting decrypted UTF-8 data.
     *
     * @param {object} options - Options.
     * @param {object} options.jwe - The JWE to decrypt.
     * @param {object} options.keyAgreementKey - A key agreement key API with
     *   `id` and `deriveSecret`.
     *
     * @returns {Promise<object>} - Resolves to the decrypted object or `null`
     *   if the decryption failed.
     */
    decryptObject({ jwe, keyAgreementKey }: any): Promise<any>;
    /**
     * Creates an EncryptTransformer that can be used to encrypt one or more
     * chunks of data.
     *
     * A list of recipients must be given in the `recipients` array, identified
     * by key agreement keys. An ephemeral ECDH key will be generated and used to
     * derive shared KEKs that will wrap a randomly generated CEK. Each recipient
     * in the `recipients` array will be updated to include the generated
     * ephemeral ECDH key.
     *
     * @param {object} options - Options for the transformer.
     * @param {Array} options.recipients - An array of recipients for the
     *   encrypted content.
     * @param {Function} options.keyResolver - A function that returns
     *   a Promise that resolves a key ID to a DH public key.
     * @param {number} [options.chunkSize=1048576] - The size, in bytes, of the
     *   chunks to break the incoming data into (only applies if returning a
     *   stream).
     *
     * @returns {Promise<EncryptTransformer>} - Resolves to an EncryptTransformer.
     */
    createEncryptTransformer({ recipients, keyResolver, chunkSize }: any): Promise<EncryptTransformer>;
    /**
     * Creates a DecryptTransformer.
     *
     * @param {object} keyAgreementKey - A key agreement key API with `id` and
     *   `deriveSecret`.
     *
     * @returns {Promise<DecryptTransformer>} - Resolves to a DecryptTransformer.
     */
    createDecryptTransformer({ keyAgreementKey }: any): Promise<DecryptTransformer>;
}
