{"version":3,"file":"did-key-cipher.cjs.development.js","sources":["../src/Cipher/crypto.ts","../src/Cipher/algorithms/ecdhkdf.ts","../src/Cipher/algorithms/classes/KeyEncryptionKey.ts","../src/Cipher/util.ts","../src/Cipher/algorithms/xc20p.ts","../src/Cipher/DecryptTransformer.ts","../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../src/Cipher/EncryptTransformer.ts","../src/Cipher/Cipher.ts","../src/Cipher/getEpkGenerator.ts"],"sourcesContent":["import { Crypto } from '@peculiar/webcrypto';\n\nfunction isNodejs() {\n  return (\n    typeof process === 'object' &&\n    typeof process.versions === 'object' &&\n    typeof process.versions.node !== 'undefined'\n  );\n}\n\nlet crypto: Crypto;\n\nif (isNodejs()) {\n  crypto = new Crypto();\n} else {\n  crypto = window.crypto;\n}\n\nexport default crypto;\n","/*!\n * Copyright (c) 2019-2020 Digital Bazaar, Inc. All rights reserved.\n */\nimport crypto from '../crypto';\n\n// only supported algorithm\nconst KEY_ALGORITHM = 'ECDH-ES+A256KW';\n\n// create static ALGORITHM_ID\nconst ALGORITHM_CONTENT = KEY_ALGORITHM; //new TextEncoder().encode();\nconst ALGORITHM_ID = new Uint8Array(4 + ALGORITHM_CONTENT.length);\n// write length of content as 32-bit big endian integer, then write content\nconst dv = new DataView(\n  ALGORITHM_ID.buffer,\n  ALGORITHM_ID.byteOffset,\n  ALGORITHM_ID.byteLength\n);\ndv.setUint32(0, ALGORITHM_CONTENT.length);\nALGORITHM_ID.set(Buffer.from(ALGORITHM_CONTENT), 4);\n\n// RFC 7518 Section 4.6.2 specifies using SHA-256 for ECDH-ES KDF\n// https://tools.ietf.org/html/rfc7518#section-4.6.2\nconst HASH_ALGORITHM = { name: 'SHA-256' };\n\n// derived keys are always 256-bits\nconst KEY_LENGTH = 256;\n\n/**\n * Derives a 256-bit AES-KW key encryption key from a shared secret that\n * was derived from an ephemeral and static pair\n * of Elliptic Curve Diffie-Hellman keys.\n *\n * The KDF used is described in RFC 7518. This KDF is referenced by RFC 8037,\n * which defines how to perform Curve25519 (X25519) ECDH key agreement.\n *\n * @param {object} options - The options to use.\n * @param {Uint8Array} options.secret - The shared secret (i.e., `Z`) to use.\n * @param {Uint8Array} options.producerInfo - An array of application-specific\n *   bytes describing the consumer (aka the \"encrypter\" or \"sender\").\n * @param {Uint8Array} options.consumerInfo - An array of application-specific\n *   bytes describing the producer (aka the \"decrypter\" or\n *   \"receiver\"/\"recipient\").\n *\n * @returns {Promise<Uint8Array>} - Resolves to the generated key.\n */\nexport async function deriveKey({ secret, producerInfo, consumerInfo }: any) {\n  if (!(secret instanceof Uint8Array && secret.length > 0)) {\n    throw new TypeError('\"secret\" must be a non-empty Uint8Array.');\n  }\n  if (!(producerInfo instanceof Uint8Array && producerInfo.length > 0)) {\n    throw new TypeError('\"producerInfo\" must be a non-empty Uint8Array.');\n  }\n  if (!(consumerInfo instanceof Uint8Array && consumerInfo.length > 0)) {\n    throw new TypeError('\"consumerInfo\" must be a non-empty Uint8Array.');\n  }\n\n  // the output of Concat KDF is hash(roundNumber || Z || OtherInfo)\n  // where roundNumber is always 1 because the hash length is presumed to\n  // ...match the key length, encoded as a big endian 32-bit integer\n  // where OtherInfo is:\n  // AlgorithmID || PartyUInfo || PartyVInfo || SuppPubInfo\n  // where SuppPubInfo is the key length in bits, big endian encoded as a\n  // 32-bit number, i.e., 256 === [0, 0, 1, 0]\n  const input = new Uint8Array(\n    4 + // round number\n    secret.length + // `Z`\n    ALGORITHM_ID.length + // AlgorithmID\n    4 +\n    producerInfo.length + // PartyUInfo\n    4 +\n    consumerInfo.length + // PartyVInfo\n      4\n  ); // SuppPubInfo (key data length in bits)\n  let offset = 0;\n  const dv = new DataView(input.buffer, input.byteOffset, input.byteLength);\n  dv.setUint32(offset, 1);\n  input.set(secret, (offset += 4));\n  input.set(ALGORITHM_ID, (offset += secret.length));\n  dv.setUint32((offset += ALGORITHM_ID.length), producerInfo.length);\n  input.set(producerInfo, (offset += 4));\n  dv.setUint32((offset += producerInfo.length), consumerInfo.length);\n  input.set(consumerInfo, (offset += 4));\n  dv.setUint32((offset += consumerInfo.length), KEY_LENGTH);\n\n  // hash input and return result as derived key\n  return new Uint8Array(await crypto.subtle.digest(HASH_ALGORITHM, input));\n}\n","import { default as bs64 } from 'base64url';\nimport { AESKW } from '@stablelib/aes-kw';\n\nexport interface CreateKekOptions {\n  keyData: Uint8Array;\n}\n\nexport interface WrapKeyOptions {\n  unwrappedKey: Uint8Array;\n}\n\nexport interface UnwrapKeyOptions {\n  wrappedKey: string; //base64url\n}\n\nexport class KeyEncryptionKey {\n  public aeskw: AESKW;\n  public algorithm: any;\n\n  static createKek = async ({ keyData }: CreateKekOptions) => {\n    return new KeyEncryptionKey(keyData);\n  };\n\n  constructor(key: Uint8Array) {\n    if (key.length !== 32) {\n      throw new Error('key must be 32 bytes');\n    }\n    this.aeskw = new AESKW(key);\n    this.algorithm = { name: 'A256KW' };\n  }\n\n  /**\n   * Wraps a cryptographic key.\n   *\n   * @param {object} options - The options to use.\n   * @param {Uint8Array} options.unwrappedKey - The key material as a\n   *   `Uint8Array`.\n   *\n   * @returns {string} - The base64url-encoded wrapped key bytes.\n   */\n  wrapKey({ unwrappedKey }: WrapKeyOptions): string {\n    const wrappedKey = this.aeskw.wrapKey(unwrappedKey);\n    return bs64.encode(Buffer.from(wrappedKey));\n  }\n\n  /**\n   * Unwraps a cryptographic key.\n   *\n   * @param {object} options - The options to use.\n   * @param {string} options.wrappedKey - The wrapped key material as a\n   *   base64url-encoded string.\n   *\n   * @returns {Uint8Array} - Resolves to the key bytes or null if\n   *   the unwrapping fails because the key does not match.\n   */\n  unwrapKey({ wrappedKey }: UnwrapKeyOptions): Uint8Array | null {\n    const _wrappedKey = bs64.toBuffer(wrappedKey);\n    try {\n      return this.aeskw.unwrapKey(_wrappedKey);\n    } catch (e) {\n      // decryption failed\n      console.error(e);\n      return null;\n    }\n  }\n}\n","export { ReadableStream, TransformStream } from 'web-streams-polyfill/ponyfill';\n\nexport function stringToUint8Array(data: any) {\n  if (typeof data === 'string') {\n    // convert data to Uint8Array\n    return new Uint8Array(Buffer.from(data));\n  }\n  if (!(data instanceof Uint8Array)) {\n    throw new TypeError('\"data\" be a string or Uint8Array.');\n  }\n  return data;\n}\n","/*!\n * Copyright (c) 2019-2020 Digital Bazaar, Inc. All rights reserved.\n */\nimport crypto from '../crypto';\nimport { XChaCha20Poly1305, KEY_LENGTH } from '@stablelib/xchacha20poly1305';\n\nexport const JWE_ENC = 'XC20P';\n\n/**\n * Generates a content encryption key (CEK). The 256-bit key is intended to be\n * used as a XChaCha20Poly1305 (draft-irtf-cfrg-xchacha-01) key.\n *\n * @returns {Promise<Uint8Array>} - Resolves to the generated key.\n */\nexport async function generateKey() {\n  // generate content encryption key\n  return crypto.getRandomValues(new Uint8Array(KEY_LENGTH));\n}\n\n/**\n * Encrypts some data. The data will be encrypted using the given\n * 256-bit XChaCha20Poly1305 (draft-irtf-cfrg-xchacha-01) content encryption\n * key (CEK).\n *\n * @param {object} options - The options to use.\n * @param {Uint8Array} options.data - The data to encrypt.\n * @param {Uint8Array} [options.additionalData] - Optional additional\n *   authentication data.\n * @param {Uint8Array} options.cek - The content encryption key to use.\n *\n * @returns {Promise<object>} - Resolves to `{ciphertext, iv, tag}`.\n */\nexport async function encrypt({ data, additionalData, cek }: any) {\n  if (!(data instanceof Uint8Array)) {\n    throw new TypeError('\"data\" must be a Uint8Array.');\n  }\n  if (!(cek instanceof Uint8Array)) {\n    throw new TypeError('\"cek\" must be a Uint8Array.');\n  }\n\n  const cipher = new XChaCha20Poly1305(cek);\n  // Note: Uses a random value here as a counter is not viable -- multiple\n  // recipients may be trying to update at the same time and use the same\n  // counter breaking security; using XChaCha20Poly1305 once available will\n  // further reduce chances of a collision as it has a 192-bit IV\n  const iv = crypto.getRandomValues(new Uint8Array(cipher.nonceLength));\n\n  // encrypt data\n  const encrypted = cipher.seal(iv, data, additionalData);\n\n  // split ciphertext and tag\n  const ciphertext = encrypted.subarray(0, encrypted.length - cipher.tagLength);\n  const tag = encrypted.subarray(encrypted.length - cipher.tagLength);\n\n  return {\n    ciphertext,\n    iv,\n    tag,\n  };\n}\n\n/**\n * Decrypts some encrypted data. The data must have been encrypted using\n * the given XChaCha20Poly1305 (draft-irtf-cfrg-xchacha-01) content encryption\n * key (CEK).\n *\n * @param {object} options - The options to use.\n * @param {Uint8Array} options.ciphertext - The data to decrypt.\n * @param {Uint8Array} options.iv - The initialization vector (aka nonce).\n * @param {Uint8Array} options.tag - The authentication tag.\n * @param {Uint8Array} [options.additionalData] - Optional additional\n *   authentication data.\n * @param {Uint8Array} options.cek - The content encryption key to use.\n *\n * @returns {Promise<Uint8Array>} The decrypted data.\n */\nexport async function decrypt({\n  ciphertext,\n  iv,\n  tag,\n  additionalData,\n  cek,\n}: any) {\n  if (!(iv instanceof Uint8Array)) {\n    throw new Error('Invalid or missing \"iv\".');\n  }\n  if (!(ciphertext instanceof Uint8Array)) {\n    throw new Error('Invalid or missing \"ciphertext\".');\n  }\n  if (!(tag instanceof Uint8Array)) {\n    throw new Error('Invalid or missing \"tag\".');\n  }\n  if (!(cek instanceof Uint8Array)) {\n    throw new TypeError('\"cek\" must be a Uint8Array.');\n  }\n\n  // decrypt `ciphertext`\n  const cipher = new XChaCha20Poly1305(cek);\n  const encrypted = new Uint8Array(ciphertext.length + cipher.tagLength);\n  encrypted.set(ciphertext);\n  encrypted.set(tag, ciphertext.length);\n  return cipher.open(iv, encrypted, additionalData);\n}\n","/*!\n * Copyright (c) 2019-2020 Digital Bazaar, Inc. All rights reserved.\n */\nimport base64url from 'base64url';\n\nimport * as recAlgorithm from './algorithms/recommended';\nimport { stringToUint8Array } from './util';\n\nconst CIPHER_ALGORITHMS: any = {\n  [recAlgorithm.cipher.JWE_ENC]: recAlgorithm.cipher,\n};\n\nexport class DecryptTransformer {\n  public keyAgreementKey: any;\n  public KeyPairClass: any;\n\n  constructor({ keyAgreementKey, KeyPairClass }: any = {}) {\n    if (!keyAgreementKey) {\n      throw new TypeError('\"keyAgreementKey\" is a required parameter.');\n    }\n    this.KeyPairClass = KeyPairClass;\n    this.keyAgreementKey = keyAgreementKey;\n  }\n\n  async transform(chunk: any, controller: any) {\n    // assumes `chunk` is an object with a JWE under the `jwe` property\n    if (!(chunk && typeof chunk === 'object')) {\n      throw new TypeError('\"chunk\" must be an object.');\n    }\n    const { jwe } = chunk;\n\n    const data = await this.decrypt(jwe);\n    if (data === null) {\n      const error = new Error('Invalid decryption key.');\n      error.name = 'DataError';\n      throw error;\n    }\n\n    controller.enqueue(data);\n  }\n\n  async decrypt(jwe: any) {\n    // validate JWE\n    if (!(jwe && typeof jwe === 'object')) {\n      throw new TypeError('\"jwe\" must be an object.');\n    }\n    if (typeof jwe.protected !== 'string') {\n      throw new TypeError('\"jwe.protected\" is missing or not a string.');\n    }\n    if (typeof jwe.iv !== 'string') {\n      throw new Error('Invalid or missing \"iv\".');\n    }\n    if (typeof jwe.ciphertext !== 'string') {\n      throw new Error('Invalid or missing \"ciphertext\".');\n    }\n    if (typeof jwe.tag !== 'string') {\n      throw new Error('Invalid or missing \"tag\".');\n    }\n\n    // validate encryption header\n    let header;\n    let additionalData;\n    try {\n      // ASCII(BASE64URL(UTF8(JWE Protected Header)))\n      additionalData = stringToUint8Array(jwe.protected);\n      header = JSON.parse(base64url.toBuffer(jwe.protected).toString());\n    } catch (e) {\n      throw new Error('Invalid JWE \"protected\" header.');\n    }\n    if (!(header.enc && typeof header.enc === 'string')) {\n      throw new Error('Invalid JWE \"enc\" header.');\n    }\n    const cipher = CIPHER_ALGORITHMS[header.enc];\n    if (!cipher) {\n      throw new Error('Unsupported encryption algorithm \"${header.enc}\".');\n    }\n    if (!Array.isArray(jwe.recipients)) {\n      throw new TypeError('\"jwe.recipients\" must be an array.');\n    }\n\n    // find `keyAgreementKey` matching recipient\n    const { keyAgreementKey } = this;\n\n    const _findRecipient = (recipients: any, key: any) => {\n      return recipients.find(\n        (rec: any) =>\n          (rec.header && rec.header.kid === key.id) ||\n          rec.header.kid.split('#').pop() === key.id.split('#').pop()\n      );\n    };\n\n    const recipient = _findRecipient(jwe.recipients, keyAgreementKey);\n\n    if (!recipient) {\n      console.log(jwe.recipients, keyAgreementKey);\n      throw new Error('No matching recipient found for key agreement key.');\n    }\n    // get wrapped CEK\n    const { encrypted_key: wrappedKey } = recipient;\n    if (typeof wrappedKey !== 'string') {\n      throw new Error('Invalid or missing \"encrypted_key\".');\n    }\n\n    // TODO: consider a cache of encrypted_key => CEKs to reduce unwrapping\n    // calls which may even need to hit the network (e.g., Web KMS)\n\n    // derive KEK and unwrap CEK\n    const { epk } = recipient.header;\n\n    const { kek } = await this.KeyPairClass.kekFromEphemeralPeer({\n      keyAgreementKey,\n      epk,\n    });\n    const cek = await kek.unwrapKey({ wrappedKey });\n    if (!cek) {\n      // failed to unwrap key\n      return null;\n    }\n\n    // decrypt content\n    const { ciphertext, iv, tag } = jwe;\n    return cipher.decrypt({\n      ciphertext: base64url.toBuffer(ciphertext),\n      iv: base64url.toBuffer(iv),\n      tag: base64url.toBuffer(tag),\n      additionalData,\n      cek,\n    });\n  }\n}\n","// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","/*!\n * Copyright (c) 2019-2020 Digital Bazaar, Inc. All rights reserved.\n */\nimport base64url from 'base64url';\n\n// 1 MiB = 1048576\nconst DEFAULT_CHUNK_SIZE = 1048576;\n\nexport class EncryptTransformer {\n  public recipients: any;\n  public encodedProtectedHeader: any;\n  public cipher: any;\n  public additionalData: any;\n  public cek: any;\n  public chunkSize: any;\n  public offset: any;\n  public totalOffset: any;\n  public index: any;\n  public buffer: any;\n\n  constructor({\n    recipients,\n    encodedProtectedHeader,\n    cipher,\n    additionalData,\n    cek,\n    chunkSize = DEFAULT_CHUNK_SIZE,\n  }: any = {}) {\n    this.recipients = recipients;\n    this.encodedProtectedHeader = encodedProtectedHeader;\n    this.cipher = cipher;\n    this.additionalData = additionalData;\n    this.cek = cek;\n    this.chunkSize = chunkSize;\n    this.offset = 0;\n    this.totalOffset = 0;\n    this.index = 0;\n  }\n\n  start() {\n    this.buffer = new Uint8Array(this.chunkSize);\n  }\n\n  async transform(chunk: any, controller: any) {\n    const { buffer } = this;\n\n    // assumes `chunk` is a Uint8Array...\n    if (!(chunk instanceof Uint8Array)) {\n      throw new TypeError('\"chunk\" must be an object.');\n    }\n    while (chunk) {\n      const space = buffer.length - this.offset;\n      if (chunk.length <= space) {\n        buffer.set(chunk, this.offset);\n        this.offset += chunk.byteLength;\n        this.totalOffset += chunk.byteLength;\n        chunk = null;\n      } else {\n        const partial = new Uint8Array(chunk.buffer, chunk.byteOffset, space);\n        chunk = new Uint8Array(\n          chunk.buffer,\n          chunk.byteOffset + space,\n          chunk.length - space\n        );\n        buffer.set(partial, this.offset);\n        this.offset += space;\n        this.totalOffset += space;\n      }\n\n      // flush if buffer is full and more data remains\n      if (chunk) {\n        await this.flush(controller);\n      }\n    }\n  }\n\n  async flush(controller: any) {\n    if (this.offset === 0) {\n      // nothing to flush\n      return;\n    }\n\n    // encrypt data\n    const { buffer } = this;\n    const data = new Uint8Array(buffer.buffer, buffer.byteOffset, this.offset);\n    const jwe = await this.encrypt(data);\n\n    // clear buffer\n    this.offset = 0;\n\n    controller.enqueue({\n      index: this.index++,\n      offset: this.totalOffset,\n      jwe,\n    });\n  }\n\n  async encrypt(data: any) {\n    const { cipher, additionalData, cek } = this;\n    const { ciphertext, iv, tag } = await cipher.encrypt({\n      data,\n      additionalData,\n      cek,\n    });\n\n    // represent encrypted data as JWE\n    const jwe = {\n      protected: this.encodedProtectedHeader,\n      recipients: this.recipients,\n      iv: base64url.encode(iv),\n      ciphertext: base64url.encode(ciphertext),\n      tag: base64url.encode(tag),\n    };\n    return jwe;\n  }\n}\n","/*!\n * Copyright (c) 2019-2020 Digital Bazaar, Inc. All rights reserved.\n */\nimport base64url from 'base64url';\nimport { TransformStream, stringToUint8Array } from './util';\nimport { DecryptTransformer } from './DecryptTransformer';\nimport { EncryptTransformer } from './EncryptTransformer';\nimport * as recAlgorithm from './algorithms/recommended';\n\nexport class Cipher {\n  public version: string;\n  public cipher: any;\n\n  /**\n   * Creates a new Cipher instance that can be used to encrypt or decrypt\n   * data. A version must be supplied for encrypting data; the version\n   * indicates whether a FIPS-compliant algorithm or the latest recommended\n   * algorithm will be used.\n   *\n   * @param {string} [version='recommended'] - `fips` to use a FIPS-compliant\n   *   algorithm, `recommended` to use the latest recommended algorithm when\n   *   encrypting.\n   *\n   * @returns {Cipher} A Cipher used to encrypt and decrypt data.\n   */\n  constructor(public KeyPairClass: any) {\n    this.version = 'recommended';\n    // only recommended... agility should be explicit.\n    this.cipher = recAlgorithm.cipher;\n  }\n\n  /**\n   * Creates a TransformStream that will encrypt some data for one or more\n   * recipients and output a stream of chunks, each containing an object\n   * with the property `jwe` with a JWE value.\n   *\n   * A list of recipients must be given in the `recipients` array, identified\n   * by key agreement keys. An ephemeral ECDH key will be generated and used to\n   * derive shared KEKs that will wrap a randomly generated CEK. Each recipient\n   * in the `recipients` array will be updated to include the generated\n   * ephemeral ECDH key.\n   *\n   * @param {object} options - The options for the stream.\n   * @param {Array} options.recipients - An array of recipients for the\n   *   encrypted content.\n   * @param {Function} options.keyResolver - A function that returns a Promise\n   *   that resolves a key ID to a DH public key.\n   * @param {number} [options.chunkSize=1048576] - The size, in bytes,\n   *   of the chunks to break the incoming data into.\n   *\n   * @returns {Promise<TransformStream>} Resolves to a TransformStream.\n   */\n  async createEncryptStream({ recipients, keyResolver, chunkSize }: any) {\n    const transformer = await this.createEncryptTransformer({\n      recipients,\n      keyResolver,\n      chunkSize,\n    });\n    return new TransformStream(transformer);\n  }\n\n  /**\n   * Creates a TransformStream that will decrypt one or more chunks, each one\n   * that is an object with a `jwe` property that has a JWE as a value. The\n   * stream will output chunks of Uint8Arrays consisting of the decrypted\n   * data from each chunk.\n   *\n   * The only JWEs currently supported use an `alg` of `ECDH-ES+A256KW` and\n   * `enc` of `A256GCM` or `XC20P`. These parameters refer to data that has been\n   * encrypted using a 256-bit AES-GCM or XChaCha20Poly1305 content encryption\n   * key (CEK) that has been wrapped using a 256-bit AES-KW key encryption key\n   * (KEK) generated via a shared secret between an ephemeral ECDH key and a\n   * static ECDH key (ECDH-ES).\n   *\n   * @param {object} options - Options for createDecryptStream.\n   * @param {object} options.keyAgreementKey - A key agreement key API with\n   *   `id` and deriveSecret`.\n   *\n   * @returns {Promise<TransformStream>} Resolves to the TransformStream.\n   */\n  async createDecryptStream({ keyAgreementKey }: any) {\n    const transformer = await this.createDecryptTransformer({\n      keyAgreementKey,\n    });\n    return new TransformStream(transformer);\n  }\n\n  /**\n   * Encrypts some data for one or more recipients and outputs a JWE. The\n   * data to encrypt can be given as a Uint8Array or a string.\n   *\n   * A list of recipients must be given in the `recipients` array, identified\n   * by key agreement keys. An ephemeral ECDH key will be generated and used to\n   * derive shared KEKs that will wrap a randomly generated CEK. Each recipient\n   * in the `recipients` array will be updated to include the generated\n   * ephemeral ECDH key.\n   *\n   * @param {object} options - Options for encrypt.\n   * @param {Uint8Array|string} [options.data] - The data to encrypt.\n   * @param {Array} options.recipients - An array of recipients for the\\\n   *   encrypted content.\n   * @param {Function} options.keyResolver - A function that returns a Promise\n   *   that resolves a key ID to a DH public key.\n   *\n   * @returns {Promise<object>} Resolves to a JWE.\n   */\n  async encrypt({ data, recipients, keyResolver }: any) {\n    if (!(data instanceof Uint8Array) && typeof data !== 'string') {\n      throw new TypeError('\"data\" must be a Uint8Array or a string.');\n    }\n    if (data) {\n      data = stringToUint8Array(data);\n    }\n    const transformer = await this.createEncryptTransformer({\n      recipients,\n      keyResolver,\n    });\n    return transformer.encrypt(data);\n  }\n\n  /**\n   * Encrypts an object. The object will be serialized to JSON and passed\n   * to `encrypt`. See `encrypt` for other parameters.\n   *\n   * @param {object} obj - The object to encrypt.\n   *\n   * @returns {Promise<object>} Resolves to a JWE.\n   */\n  async encryptObject({ obj, ...rest }: any) {\n    if (typeof obj !== 'object') {\n      throw new TypeError('\"obj\" must be an object.');\n    }\n    return this.encrypt({ data: JSON.stringify(obj), ...rest });\n  }\n\n  /**\n   * Decrypts a single JWE.\n   *\n   * The only JWEs currently supported use an `alg` of `ECDH-ES+A256KW` and\n   * `enc` of `A256GCM` or `XC20P`. These parameters refer to data that has been\n   * encrypted using a 256-bit AES-GCM or XChaCha20Poly1305 content encryption\n   * key (CEK) that has been wrapped using a 256-bit AES-KW key encryption key\n   * (KEK) generated via a shared secret between an ephemeral ECDH key and a\n   * static ECDH key (ECDH-ES).\n   *\n   * Note: This version also supports decrypting data that was encrypted using\n   * `C20P` (ChaCha20Poly1305) for backwards compatibility.\n   *\n   * @param {object} options - Options for decrypt.\n   * @param {object} options.jwe - The JWE to decrypt.\n   * @param {object} options.keyAgreementKey - A key agreement key API with\n   *   `id` and `deriveSecret`.\n   *\n   * @returns {Promise<Uint8Array>} - Resolves to the decrypted data\n   *   or `null` if the decryption failed.\n   */\n  async decrypt({ jwe, keyAgreementKey }: any) {\n    const transformer = await this.createDecryptTransformer({\n      keyAgreementKey,\n    });\n    return transformer.decrypt(jwe);\n  }\n\n  /**\n   * Decrypts a JWE that must contain an encrypted object. This method will\n   * call `decrypt` and then `JSON.parse` the resulting decrypted UTF-8 data.\n   *\n   * @param {object} options - Options.\n   * @param {object} options.jwe - The JWE to decrypt.\n   * @param {object} options.keyAgreementKey - A key agreement key API with\n   *   `id` and `deriveSecret`.\n   *\n   * @returns {Promise<object>} - Resolves to the decrypted object or `null`\n   *   if the decryption failed.\n   */\n  async decryptObject({ jwe, keyAgreementKey }: any) {\n    const data = await this.decrypt({ jwe, keyAgreementKey });\n    if (!data) {\n      // decryption failed\n      return null;\n    }\n\n    return JSON.parse(Buffer.from(data).toString());\n  }\n\n  /**\n   * Creates an EncryptTransformer that can be used to encrypt one or more\n   * chunks of data.\n   *\n   * A list of recipients must be given in the `recipients` array, identified\n   * by key agreement keys. An ephemeral ECDH key will be generated and used to\n   * derive shared KEKs that will wrap a randomly generated CEK. Each recipient\n   * in the `recipients` array will be updated to include the generated\n   * ephemeral ECDH key.\n   *\n   * @param {object} options - Options for the transformer.\n   * @param {Array} options.recipients - An array of recipients for the\n   *   encrypted content.\n   * @param {Function} options.keyResolver - A function that returns\n   *   a Promise that resolves a key ID to a DH public key.\n   * @param {number} [options.chunkSize=1048576] - The size, in bytes, of the\n   *   chunks to break the incoming data into (only applies if returning a\n   *   stream).\n   *\n   * @returns {Promise<EncryptTransformer>} - Resolves to an EncryptTransformer.\n   */\n  async createEncryptTransformer({ recipients, keyResolver, chunkSize }: any) {\n    if (!(Array.isArray(recipients) && recipients.length > 0)) {\n      throw new TypeError('\"recipients\" must be a non-empty array.');\n    }\n    // ensure all recipients use the supported key agreement algorithm\n\n    const alg = this.KeyPairClass.JWE_ALG;\n    if (!recipients.every((e) => e.header && e.header.alg === alg)) {\n      throw new Error(`All recipients must use the algorithm \"${alg}\".`);\n    }\n    const { cipher } = this;\n\n    // generate a CEK for encrypting the content\n    const cek = await cipher.generateKey();\n\n    // fetch all public DH keys\n    const publicKeys = await Promise.all(\n      recipients.map((e) => keyResolver({ id: e.header.kid }))\n    );\n\n    let epkArgs = undefined;\n    if (publicKeys[0].type === 'JsonWebKey2020') {\n      // agility ftw...\n      // TODO: ... tests with different keys...\n      epkArgs = { kty: 'EC', crvOrSize: publicKeys[0].publicKeyJwk.crv };\n    }\n\n    // derive ephemeral ECDH key pair to use with all recipients\n    const ephemeralKeyPair = await this.KeyPairClass.generateEphemeralKeyPair(\n      epkArgs\n    );\n\n    // derive KEKs for each recipient\n    const derivedResults = await Promise.all(\n      publicKeys.map((staticPublicKey) =>\n        this.KeyPairClass.kekFromStaticPeer({\n          ephemeralKeyPair,\n          staticPublicKey,\n        })\n      )\n    );\n\n    // update all recipients with ephemeral ECDH key and wrapped CEK\n    await Promise.all(\n      recipients.map(async (recipient, i) => {\n        const { kek, epk, apu, apv } = derivedResults[i];\n        recipients[i] = recipient = { header: { ...recipient.header } };\n        recipient.header.epk = epk;\n        recipient.header.apu = apu;\n        recipient.header.apv = apv;\n        recipient.encrypted_key = await kek.wrapKey({ unwrappedKey: cek });\n      })\n    );\n\n    // create shared protected header as associated authenticated data (aad)\n    // ASCII(BASE64URL(UTF8(JWE Protected Header)))\n    const enc = cipher.JWE_ENC;\n    const jweProtectedHeader = JSON.stringify({ enc });\n    const encodedProtectedHeader = base64url.encode(\n      Buffer.from(stringToUint8Array(jweProtectedHeader))\n    );\n    // UTF8-encoding a base64url-encoded string is the same as ASCII\n    const additionalData = stringToUint8Array(encodedProtectedHeader);\n\n    return new EncryptTransformer({\n      recipients,\n      encodedProtectedHeader,\n      cipher,\n      additionalData,\n      cek,\n      chunkSize,\n    });\n  }\n\n  /**\n   * Creates a DecryptTransformer.\n   *\n   * @param {object} keyAgreementKey - A key agreement key API with `id` and\n   *   `deriveSecret`.\n   *\n   * @returns {Promise<DecryptTransformer>} - Resolves to a DecryptTransformer.\n   */\n  async createDecryptTransformer({ keyAgreementKey }: any) {\n    return new DecryptTransformer({\n      KeyPairClass: this.KeyPairClass,\n      keyAgreementKey,\n    });\n  }\n}\n","import { types } from '@transmute/did-key-common';\n\nexport const getEpkGenerator = (KeyPair: types.KeyPairClass, opts: any) => {\n  const generateEphemeralKeyPair = async (): Promise<types.EpkResult> => {\n    const k0 = await KeyPair.generate(opts);\n    const keypair = await k0.toJsonWebKeyPair(true);\n\n    return {\n      keypair,\n      epk: keypair.publicKeyJwk,\n    };\n  };\n  return generateEphemeralKeyPair;\n};\n"],"names":["isNodejs","process","versions","node","crypto","Crypto","window","deriveKey","secret","producerInfo","consumerInfo","Uint8Array","length","TypeError","input","ALGORITHM_ID","offset","dv","DataView","buffer","byteOffset","byteLength","setUint32","set","KEY_LENGTH","subtle","digest","HASH_ALGORITHM","KEY_ALGORITHM","ALGORITHM_CONTENT","Buffer","from","name","KeyEncryptionKey","key","Error","aeskw","AESKW","algorithm","wrapKey","unwrappedKey","wrappedKey","bs64","encode","unwrapKey","_wrappedKey","toBuffer","e","console","error","keyData","stringToUint8Array","data","decrypt","ciphertext","iv","tag","additionalData","cek","cipher","XChaCha20Poly1305","encrypted","tagLength","open","encrypt","getRandomValues","nonceLength","seal","subarray","generateKey","JWE_ENC","CIPHER_ALGORITHMS","recAlgorithm","DecryptTransformer","keyAgreementKey","KeyPairClass","transform","chunk","controller","jwe","enqueue","header","JSON","parse","base64url","toString","enc","Array","isArray","recipients","_findRecipient","find","rec","kid","id","split","pop","recipient","log","encrypted_key","epk","kekFromEphemeralPeer","kek","DEFAULT_CHUNK_SIZE","EncryptTransformer","encodedProtectedHeader","chunkSize","totalOffset","index","start","space","partial","flush","Cipher","version","createEncryptStream","keyResolver","createEncryptTransformer","transformer","TransformStream","createDecryptStream","createDecryptTransformer","encryptObject","obj","rest","stringify","decryptObject","alg","JWE_ALG","every","Promise","all","map","publicKeys","epkArgs","undefined","type","kty","crvOrSize","publicKeyJwk","crv","generateEphemeralKeyPair","ephemeralKeyPair","staticPublicKey","kekFromStaticPeer","derivedResults","i","apu","apv","jweProtectedHeader","getEpkGenerator","KeyPair","opts","generate","k0","toJsonWebKeyPair","keypair"],"mappings":";;;;;;;;;;;;AAEA,SAASA,QAAT;AACE,SACE,OAAOC,OAAP,KAAmB,QAAnB,IACA,OAAOA,OAAO,CAACC,QAAf,KAA4B,QAD5B,IAEA,OAAOD,OAAO,CAACC,QAAR,CAAiBC,IAAxB,KAAiC,WAHnC;AAKD;;AAED,IAAIC,MAAJ;;AAEA,IAAIJ,QAAQ,EAAZ,EAAgB;AACdI,EAAAA,MAAM,gBAAG,IAAIC,gBAAJ,EAAT;AACD,CAFD,MAEO;AACLD,EAAAA,MAAM,GAAGE,MAAM,CAACF,MAAhB;AACD;;AAED,eAAeA,MAAf;;AClBA;;;AAGA;AAwBA;;;;;;;;;;;;;;;;;;AAkBA,IAAsBG,SAAtB,YAAsBA,SAAtB;AAAA,MAAkCC,MAAlC,QAAkCA,MAAlC;AAAA,MAA0CC,YAA1C,QAA0CA,YAA1C;AAAA,MAAwDC,YAAxD,QAAwDA,YAAxD;;AAAA;AACE,QAAI,EAAEF,MAAM,YAAYG,UAAlB,IAAgCH,MAAM,CAACI,MAAP,GAAgB,CAAlD,CAAJ,EAA0D;AACxD,YAAM,IAAIC,SAAJ,CAAc,0CAAd,CAAN;AACD;;AACD,QAAI,EAAEJ,YAAY,YAAYE,UAAxB,IAAsCF,YAAY,CAACG,MAAb,GAAsB,CAA9D,CAAJ,EAAsE;AACpE,YAAM,IAAIC,SAAJ,CAAc,gDAAd,CAAN;AACD;;AACD,QAAI,EAAEH,YAAY,YAAYC,UAAxB,IAAsCD,YAAY,CAACE,MAAb,GAAsB,CAA9D,CAAJ,EAAsE;AACpE,YAAM,IAAIC,SAAJ,CAAc,gDAAd,CAAN;AACD;AAGD;AACA;AACA;AACA;AACA;AACA;;;AACA,QAAMC,KAAK,GAAG,IAAIH,UAAJ,CACZ;AACAH,IAAAA,MAAM,CAACI,MADP;AAEAG,IAAAA,YAAY,CAACH,MAFb;AAGA,KAHA,GAIAH,YAAY,CAACG,MAJb;AAKA,KALA,GAMAF,YAAY,CAACE,MANb;AAOE,KARU,CAAd;;AAUA,QAAII,MAAM,GAAG,CAAb;;AACA,QAAMC,GAAE,GAAG,IAAIC,QAAJ,CAAaJ,KAAK,CAACK,MAAnB,EAA2BL,KAAK,CAACM,UAAjC,EAA6CN,KAAK,CAACO,UAAnD,CAAX;;AACAJ,IAAAA,GAAE,CAACK,SAAH,CAAaN,MAAb,EAAqB,CAArB;;AACAF,IAAAA,KAAK,CAACS,GAAN,CAAUf,MAAV,EAAmBQ,MAAM,IAAI,CAA7B;AACAF,IAAAA,KAAK,CAACS,GAAN,CAAUR,YAAV,EAAyBC,MAAM,IAAIR,MAAM,CAACI,MAA1C;;AACAK,IAAAA,GAAE,CAACK,SAAH,CAAcN,MAAM,IAAID,YAAY,CAACH,MAArC,EAA8CH,YAAY,CAACG,MAA3D;;AACAE,IAAAA,KAAK,CAACS,GAAN,CAAUd,YAAV,EAAyBO,MAAM,IAAI,CAAnC;;AACAC,IAAAA,GAAE,CAACK,SAAH,CAAcN,MAAM,IAAIP,YAAY,CAACG,MAArC,EAA8CF,YAAY,CAACE,MAA3D;;AACAE,IAAAA,KAAK,CAACS,GAAN,CAAUb,YAAV,EAAyBM,MAAM,IAAI,CAAnC;;AACAC,IAAAA,GAAE,CAACK,SAAH,CAAcN,MAAM,IAAIN,YAAY,CAACE,MAArC,EAA8CY,UAA9C;;;2BAG4BpB,QAAM,CAACqB,MAAP,CAAcC,MAAd,CAAqBC,cAArB,EAAqCb,KAArC;AAA5B,aAAO,IAAIH,UAAJ,uBAAP;;AACD,GAzCD;AAAA;AAAA;AAAA;AAvCA,IAAMiB,aAAa,GAAG,gBAAtB;;AAGA,IAAMC,iBAAiB,GAAGD,aAA1B;;AACA,IAAMb,YAAY,gBAAG,IAAIJ,UAAJ,CAAe,IAAIkB,iBAAiB,CAACjB,MAArC,CAArB;;AAEA,IAAMK,EAAE,gBAAG,IAAIC,QAAJ,CACTH,YAAY,CAACI,MADJ,EAETJ,YAAY,CAACK,UAFJ,EAGTL,YAAY,CAACM,UAHJ,CAAX;AAKAJ,EAAE,CAACK,SAAH,CAAa,CAAb,EAAgBO,iBAAiB,CAACjB,MAAlC;AACAG,YAAY,CAACQ,GAAb,CAAiBO,MAAM,CAACC,IAAP,CAAYF,iBAAZ,CAAjB,EAAiD,CAAjD;AAGA;;AACA,IAAMF,cAAc,GAAG;AAAEK,EAAAA,IAAI,EAAE;AAAR,CAAvB;;AAGA,IAAMR,UAAU,GAAG,GAAnB;;ICVaS,gBAAb;AAQE,4BAAYC,GAAZ;AACE,QAAIA,GAAG,CAACtB,MAAJ,KAAe,EAAnB,EAAuB;AACrB,YAAM,IAAIuB,KAAJ,CAAU,sBAAV,CAAN;AACD;;AACD,SAAKC,KAAL,GAAa,IAAIC,WAAJ,CAAUH,GAAV,CAAb;AACA,SAAKI,SAAL,GAAiB;AAAEN,MAAAA,IAAI,EAAE;AAAR,KAAjB;AACD;AAED;;;;;;;;;;;AAhBF;;AAAA,SAyBEO,OAzBF,GAyBE;QAAUC,oBAAAA;AACR,QAAMC,UAAU,GAAG,KAAKL,KAAL,CAAWG,OAAX,CAAmBC,YAAnB,CAAnB;AACA,WAAOE,SAAI,CAACC,MAAL,CAAYb,MAAM,CAACC,IAAP,CAAYU,UAAZ,CAAZ,CAAP;AACD;AAED;;;;;;;;;;AA9BF;;AAAA,SAwCEG,SAxCF,GAwCE;QAAYH,mBAAAA;;AACV,QAAMI,WAAW,GAAGH,SAAI,CAACI,QAAL,CAAcL,UAAd,CAApB;;AACA,QAAI;AACF,aAAO,KAAKL,KAAL,CAAWQ,SAAX,CAAqBC,WAArB,CAAP;AACD,KAFD,CAEE,OAAOE,CAAP,EAAU;AACV;AACAC,MAAAA,OAAO,CAACC,KAAR,CAAcF,CAAd;AACA,aAAO,IAAP;AACD;AACF,GAjDH;;AAAA;AAAA;;AAISd,0BAAA;AAAA,MAAqBiB,OAArB,SAAqBA,OAArB;;AAAA;AACL,2BAAO,IAAIjB,gBAAJ,CAAqBiB,OAArB,CAAP;AACD,GAFM;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;SCjBOC,mBAAmBC;AACjC,MAAI,OAAOA,IAAP,KAAgB,QAApB,EAA8B;AAC5B;AACA,WAAO,IAAIzC,UAAJ,CAAemB,MAAM,CAACC,IAAP,CAAYqB,IAAZ,CAAf,CAAP;AACD;;AACD,MAAI,EAAEA,IAAI,YAAYzC,UAAlB,CAAJ,EAAmC;AACjC,UAAM,IAAIE,SAAJ,CAAc,mCAAd,CAAN;AACD;;AACD,SAAOuC,IAAP;AACD;;ACXD;;;AAGA;AA0DA;;;;;;;;;;;;;;;AAeA,IAAsBC,OAAtB,YAAsBA,OAAtB;AAAA,MACEC,UADF,SACEA,UADF;AAAA,MAEEC,EAFF,SAEEA,EAFF;AAAA,MAGEC,GAHF,SAGEA,GAHF;AAAA,MAIEC,cAJF,SAIEA,cAJF;AAAA,MAKEC,GALF,SAKEA,GALF;;AAAA;AAOE,QAAI,EAAEH,EAAE,YAAY5C,UAAhB,CAAJ,EAAiC;AAC/B,YAAM,IAAIwB,KAAJ,CAAU,0BAAV,CAAN;AACD;;AACD,QAAI,EAAEmB,UAAU,YAAY3C,UAAxB,CAAJ,EAAyC;AACvC,YAAM,IAAIwB,KAAJ,CAAU,kCAAV,CAAN;AACD;;AACD,QAAI,EAAEqB,GAAG,YAAY7C,UAAjB,CAAJ,EAAkC;AAChC,YAAM,IAAIwB,KAAJ,CAAU,2BAAV,CAAN;AACD;;AACD,QAAI,EAAEuB,GAAG,YAAY/C,UAAjB,CAAJ,EAAkC;AAChC,YAAM,IAAIE,SAAJ,CAAc,6BAAd,CAAN;AACD;;;AAGD,QAAM8C,MAAM,GAAG,IAAIC,mCAAJ,CAAsBF,GAAtB,CAAf;AACA,QAAMG,SAAS,GAAG,IAAIlD,UAAJ,CAAe2C,UAAU,CAAC1C,MAAX,GAAoB+C,MAAM,CAACG,SAA1C,CAAlB;AACAD,IAAAA,SAAS,CAACtC,GAAV,CAAc+B,UAAd;AACAO,IAAAA,SAAS,CAACtC,GAAV,CAAciC,GAAd,EAAmBF,UAAU,CAAC1C,MAA9B;AACA,2BAAO+C,MAAM,CAACI,IAAP,CAAYR,EAAZ,EAAgBM,SAAhB,EAA2BJ,cAA3B,CAAP;AACD,GA1BD;AAAA;AAAA;AAAA;;AAzDA;;;;;;;;;;;;;AAaA,IAAsBO,OAAtB,YAAsBA,OAAtB;AAAA,MAAgCZ,IAAhC,QAAgCA,IAAhC;AAAA,MAAsCK,cAAtC,QAAsCA,cAAtC;AAAA,MAAsDC,GAAtD,QAAsDA,GAAtD;;AAAA;AACE,QAAI,EAAEN,IAAI,YAAYzC,UAAlB,CAAJ,EAAmC;AACjC,YAAM,IAAIE,SAAJ,CAAc,8BAAd,CAAN;AACD;;AACD,QAAI,EAAE6C,GAAG,YAAY/C,UAAjB,CAAJ,EAAkC;AAChC,YAAM,IAAIE,SAAJ,CAAc,6BAAd,CAAN;AACD;;AAED,QAAM8C,MAAM,GAAG,IAAIC,mCAAJ,CAAsBF,GAAtB,CAAf;AAEA;AACA;AACA;;AACA,QAAMH,EAAE,GAAGnD,QAAM,CAAC6D,eAAP,CAAuB,IAAItD,UAAJ,CAAegD,MAAM,CAACO,WAAtB,CAAvB,CAAX;;AAGA,QAAML,SAAS,GAAGF,MAAM,CAACQ,IAAP,CAAYZ,EAAZ,EAAgBH,IAAhB,EAAsBK,cAAtB,CAAlB;;AAGA,QAAMH,UAAU,GAAGO,SAAS,CAACO,QAAV,CAAmB,CAAnB,EAAsBP,SAAS,CAACjD,MAAV,GAAmB+C,MAAM,CAACG,SAAhD,CAAnB;AACA,QAAMN,GAAG,GAAGK,SAAS,CAACO,QAAV,CAAmBP,SAAS,CAACjD,MAAV,GAAmB+C,MAAM,CAACG,SAA7C,CAAZ;AAEA,2BAAO;AACLR,MAAAA,UAAU,EAAVA,UADK;AAELC,MAAAA,EAAE,EAAFA,EAFK;AAGLC,MAAAA,GAAG,EAAHA;AAHK,KAAP;AAKD,GA3BD;AAAA;AAAA;AAAA;;AAxBA;;;;;;AAMA,IAAsBa,WAAtB,YAAsBA,WAAtB;AAAA;AACE;AACA,2BAAOjE,QAAM,CAAC6D,eAAP,CAAuB,IAAItD,UAAJ,CAAea,4BAAf,CAAvB,CAAP;AACD,GAHD;AAAA;AAAA;AAAA;AARA,AAAO,IAAM8C,OAAO,GAAG,OAAhB;;;;;;;;;;;ACEP,IAAMC,iBAAiB,gDACpBC,OADoB,IACUA,KADV,qBAAvB;AAIA,IAAaC,kBAAb;AAIE;kCAAqD;QAAvCC,uBAAAA;QAAiBC,oBAAAA;;AAC7B,QAAI,CAACD,eAAL,EAAsB;AACpB,YAAM,IAAI7D,SAAJ,CAAc,4CAAd,CAAN;AACD;;AACD,SAAK8D,YAAL,GAAoBA,YAApB;AACA,SAAKD,eAAL,GAAuBA,eAAvB;AACD;;AAVH;;AAAA,SAYQE,SAZR,sBAYkBC,KAZlB,EAY8BC,UAZ9B;AAAA;mBAmBuB;;AANnB;AACA,UAAI,EAAED,KAAK,IAAI,OAAOA,KAAP,KAAiB,QAA5B,CAAJ,EAA2C;AACzC,cAAM,IAAIhE,SAAJ,CAAc,4BAAd,CAAN;AACD;;UACOkE,MAAQF,MAARE;6BAEW,OAAK1B,OAAL,CAAa0B,GAAb,kBAAb3B;AACN,YAAIA,IAAI,KAAK,IAAb,EAAmB;AACjB,cAAMH,KAAK,GAAG,IAAId,KAAJ,CAAU,yBAAV,CAAd;AACAc,UAAAA,KAAK,CAACjB,IAAN,GAAa,WAAb;AACA,gBAAMiB,KAAN;AACD;;AAED6B,QAAAA,UAAU,CAACE,OAAX,CAAmB5B,IAAnB;;AACD,KA3BH;AAAA;AAAA;AAAA;;AAAA,SA6BQC,OA7BR,oBA6BgB0B,GA7BhB;AAAA;mBAqEgC;;AAvC5B;AACA,UAAI,EAAEA,GAAG,IAAI,OAAOA,GAAP,KAAe,QAAxB,CAAJ,EAAuC;AACrC,cAAM,IAAIlE,SAAJ,CAAc,0BAAd,CAAN;AACD;;AACD,UAAI,OAAOkE,GAAG,aAAV,KAAyB,QAA7B,EAAuC;AACrC,cAAM,IAAIlE,SAAJ,CAAc,6CAAd,CAAN;AACD;;AACD,UAAI,OAAOkE,GAAG,CAACxB,EAAX,KAAkB,QAAtB,EAAgC;AAC9B,cAAM,IAAIpB,KAAJ,CAAU,0BAAV,CAAN;AACD;;AACD,UAAI,OAAO4C,GAAG,CAACzB,UAAX,KAA0B,QAA9B,EAAwC;AACtC,cAAM,IAAInB,KAAJ,CAAU,kCAAV,CAAN;AACD;;AACD,UAAI,OAAO4C,GAAG,CAACvB,GAAX,KAAmB,QAAvB,EAAiC;AAC/B,cAAM,IAAIrB,KAAJ,CAAU,2BAAV,CAAN;AACD;;;AAGD,UAAI8C,MAAJ;AACA,UAAIxB,cAAJ;;AACA,UAAI;AACF;AACAA,QAAAA,cAAc,GAAGN,kBAAkB,CAAC4B,GAAG,aAAJ,CAAnC;AACAE,QAAAA,MAAM,GAAGC,IAAI,CAACC,KAAL,CAAWC,SAAS,CAACtC,QAAV,CAAmBiC,GAAG,aAAtB,EAAkCM,QAAlC,EAAX,CAAT;AACD,OAJD,CAIE,OAAOtC,CAAP,EAAU;AACV,cAAM,IAAIZ,KAAJ,CAAU,iCAAV,CAAN;AACD;;AACD,UAAI,EAAE8C,MAAM,CAACK,GAAP,IAAc,OAAOL,MAAM,CAACK,GAAd,KAAsB,QAAtC,CAAJ,EAAqD;AACnD,cAAM,IAAInD,KAAJ,CAAU,2BAAV,CAAN;AACD;;AACD,UAAMwB,MAAM,GAAGY,iBAAiB,CAACU,MAAM,CAACK,GAAR,CAAhC;;AACA,UAAI,CAAC3B,MAAL,EAAa;AACX,cAAM,IAAIxB,KAAJ,CAAU,mDAAV,CAAN;AACD;;AACD,UAAI,CAACoD,KAAK,CAACC,OAAN,CAAcT,GAAG,CAACU,UAAlB,CAAL,EAAoC;AAClC,cAAM,IAAI5E,SAAJ,CAAc,oCAAd,CAAN;AACD;;;UAGO6D,yBAAAA;;AAER,UAAMgB,cAAc,GAAG,SAAjBA,cAAiB,CAACD,UAAD,EAAkBvD,GAAlB;AACrB,eAAOuD,UAAU,CAACE,IAAX,CACL,UAACC,GAAD;AAAA,iBACGA,GAAG,CAACX,MAAJ,IAAcW,GAAG,CAACX,MAAJ,CAAWY,GAAX,KAAmB3D,GAAG,CAAC4D,EAAtC,IACAF,GAAG,CAACX,MAAJ,CAAWY,GAAX,CAAeE,KAAf,CAAqB,GAArB,EAA0BC,GAA1B,OAAoC9D,GAAG,CAAC4D,EAAJ,CAAOC,KAAP,CAAa,GAAb,EAAkBC,GAAlB,EAFtC;AAAA,SADK,CAAP;AAKD,OAND;;AAQA,UAAMC,SAAS,GAAGP,cAAc,CAACX,GAAG,CAACU,UAAL,EAAiBf,eAAjB,CAAhC;;AAEA,UAAI,CAACuB,SAAL,EAAgB;AACdjD,QAAAA,OAAO,CAACkD,GAAR,CAAYnB,GAAG,CAACU,UAAhB,EAA4Bf,eAA5B;AACA,cAAM,IAAIvC,KAAJ,CAAU,oDAAV,CAAN;AACD;;;UAEsBM,aAAewD,UAA9BE;;AACR,UAAI,OAAO1D,UAAP,KAAsB,QAA1B,EAAoC;AAClC,cAAM,IAAIN,KAAJ,CAAU,qCAAV,CAAN;AACD;AAGD;AAEA;;;UACQiE,MAAQH,SAAS,CAAChB,OAAlBmB;6BAEc,OAAKzB,YAAL,CAAkB0B,oBAAlB,CAAuC;AAC3D3B,QAAAA,eAAe,EAAfA,eAD2D;AAE3D0B,QAAAA,GAAG,EAAHA;AAF2D,OAAvC;YAAdE,YAAAA;+BAIUA,GAAG,CAAC1D,SAAJ,CAAc;AAAEH,UAAAA,UAAU,EAAVA;AAAF,SAAd,kBAAZiB;AACN,cAAI,CAACA,GAAL,EAAU;AACR;AACA,mBAAO,IAAP;AACD;;;cAGOJ,aAAwByB,IAAxBzB;cAAYC,KAAYwB,IAAZxB;cAAIC,MAAQuB,IAARvB;AACxB,iBAAOG,MAAM,CAACN,OAAP,CAAe;AACpBC,YAAAA,UAAU,EAAE8B,SAAS,CAACtC,QAAV,CAAmBQ,UAAnB,CADQ;AAEpBC,YAAAA,EAAE,EAAE6B,SAAS,CAACtC,QAAV,CAAmBS,EAAnB,CAFgB;AAGpBC,YAAAA,GAAG,EAAE4B,SAAS,CAACtC,QAAV,CAAmBU,GAAnB,CAHe;AAIpBC,YAAAA,cAAc,EAAdA,cAJoB;AAKpBC,YAAAA,GAAG,EAAHA;AALoB,WAAf,CAAP;;;AAOD,KApHH;AAAA;AAAA;AAAA;;AAAA;AAAA;;ACZA;AACA,AAAO,MAAM,KAAK,gBAAgB,CAAC,WAAW;AAC9C,CAAC,SAAS,KAAK,GAAG,EAAE;AACpB,CAAC,KAAK,CAAC,SAAS,CAAC,IAAI,GAAG,SAAS,WAAW,EAAE,UAAU,EAAE;AAC1D,EAAE,MAAM,MAAM,GAAG,IAAI,KAAK,EAAE,CAAC;AAC7B,EAAE,MAAM,KAAK,GAAG,IAAI,CAAC,CAAC,CAAC;AACvB,EAAE,IAAI,KAAK,EAAE;AACb,GAAG,MAAM,QAAQ,GAAG,KAAK,GAAG,CAAC,GAAG,WAAW,GAAG,UAAU,CAAC;AACzD,GAAG,IAAI,QAAQ,EAAE;AACjB,IAAI,IAAI;AACR,KAAK,OAAO,CAAC,MAAM,EAAE,CAAC,EAAE,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;AAC1C,KAAK,CAAC,OAAO,CAAC,EAAE;AAChB,KAAK,OAAO,CAAC,MAAM,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;AAC3B,KAAK;AACL,IAAI,OAAO,MAAM,CAAC;AAClB,IAAI,MAAM;AACV,IAAI,OAAO,IAAI,CAAC;AAChB,IAAI;AACJ,GAAG;AACH,EAAE,IAAI,CAAC,CAAC,GAAG,SAAS,KAAK,EAAE;AAC3B,GAAG,IAAI;AACP,IAAI,MAAM,KAAK,GAAG,KAAK,CAAC,CAAC,CAAC;AAC1B,IAAI,IAAI,KAAK,CAAC,CAAC,GAAG,CAAC,EAAE;AACrB,KAAK,OAAO,CAAC,MAAM,EAAE,CAAC,EAAE,WAAW,GAAG,WAAW,CAAC,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;AAClE,KAAK,MAAM,IAAI,UAAU,EAAE;AAC3B,KAAK,OAAO,CAAC,MAAM,EAAE,CAAC,EAAE,UAAU,CAAC,KAAK,CAAC,CAAC,CAAC;AAC3C,KAAK,MAAM;AACX,KAAK,OAAO,CAAC,MAAM,EAAE,CAAC,EAAE,KAAK,CAAC,CAAC;AAC/B,KAAK;AACL,IAAI,CAAC,OAAO,CAAC,EAAE;AACf,IAAI,OAAO,CAAC,MAAM,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;AAC1B,IAAI;AACJ,GAAG,CAAC;AACJ,EAAE,OAAO,MAAM,CAAC;AAChB,GAAE;AACF,CAAC,OAAO,KAAK,CAAC;AACd,CAAC,GAAG,CAAC;AACL;AACA;AACA,AAAO,SAAS,OAAO,CAAC,IAAI,EAAE,KAAK,EAAE,KAAK,EAAE;AAC5C,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,EAAE;AACd,EAAE,IAAI,KAAK,YAAY,KAAK,EAAE;AAC9B,GAAG,IAAI,KAAK,CAAC,CAAC,EAAE;AAChB,IAAI,IAAI,KAAK,GAAG,CAAC,EAAE;AACnB,KAAK,KAAK,GAAG,KAAK,CAAC,CAAC,CAAC;AACrB,KAAK;AACL,IAAI,KAAK,GAAG,KAAK,CAAC,CAAC,CAAC;AACpB,IAAI,MAAM;AACV,IAAI,KAAK,CAAC,CAAC,GAAG,OAAO,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC;AAC9C,IAAI,OAAO;AACX,IAAI;AACJ,GAAG;AACH,EAAE,IAAI,KAAK,IAAI,KAAK,CAAC,IAAI,EAAE;AAC3B,GAAG,KAAK,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,EAAE,KAAK,CAAC,EAAE,OAAO,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,EAAE,CAAC,CAAC,CAAC,CAAC;AAC5E,GAAG,OAAO;AACV,GAAG;AACH,EAAE,IAAI,CAAC,CAAC,GAAG,KAAK,CAAC;AACjB,EAAE,IAAI,CAAC,CAAC,GAAG,KAAK,CAAC;AACjB,EAAE,MAAM,QAAQ,GAAG,IAAI,CAAC,CAAC,CAAC;AAC1B,EAAE,IAAI,QAAQ,EAAE;AAChB,GAAG,QAAQ,CAAC,IAAI,CAAC,CAAC;AAClB,GAAG;AACH,EAAE;AACF,CAAC;AACD;AACA,AAAO,SAAS,cAAc,CAAC,QAAQ,EAAE;AACzC,CAAC,OAAO,QAAQ,YAAY,KAAK,IAAI,QAAQ,CAAC,CAAC,GAAG,CAAC,CAAC;AACpD,CAAC;AACD,AA+FA;AACA,AAAO,MAAM,eAAe,iBAAiB,OAAO,MAAM,KAAK,WAAW,IAAI,MAAM,CAAC,QAAQ,KAAK,MAAM,CAAC,QAAQ,GAAG,MAAM,CAAC,iBAAiB,CAAC,CAAC,IAAI,YAAY,CAAC;AAC/J,AA2DA;AACA,AAAO,MAAM,oBAAoB,iBAAiB,OAAO,MAAM,KAAK,WAAW,IAAI,MAAM,CAAC,aAAa,KAAK,MAAM,CAAC,aAAa,GAAG,MAAM,CAAC,sBAAsB,CAAC,CAAC,IAAI,iBAAiB,CAAC;AACxL,AA2BA;AACA;AACA,AAAO,SAAS,IAAI,CAAC,IAAI,EAAE,MAAM,EAAE,IAAI,EAAE;AACzC,CAAC,IAAI,KAAK,CAAC;AACX,CAAC,SAAS;AACV,EAAE,IAAI,cAAc,GAAG,IAAI,EAAE,CAAC;AAC9B,EAAE,IAAI,cAAc,CAAC,cAAc,CAAC,EAAE;AACtC,GAAG,cAAc,GAAG,cAAc,CAAC,CAAC,CAAC;AACrC,GAAG;AACH,EAAE,IAAI,CAAC,cAAc,EAAE;AACvB,GAAG,OAAO,MAAM,CAAC;AACjB,GAAG;AACH,EAAE,IAAI,cAAc,CAAC,IAAI,EAAE;AAC3B,GAAG,KAAK,GAAG,CAAC,CAAC;AACb,GAAG,MAAM;AACT,GAAG;AACH,EAAE,IAAI,MAAM,GAAG,IAAI,EAAE,CAAC;AACtB,EAAE,IAAI,MAAM,IAAI,MAAM,CAAC,IAAI,EAAE;AAC7B,GAAG,IAAI,cAAc,CAAC,MAAM,CAAC,EAAE;AAC/B,IAAI,MAAM,GAAG,MAAM,CAAC,CAAC,CAAC;AACtB,IAAI,MAAM;AACV,IAAI,KAAK,GAAG,CAAC,CAAC;AACd,IAAI,MAAM;AACV,IAAI;AACJ,GAAG;AACH,EAAE,IAAI,MAAM,EAAE;AACd,GAAG,IAAI,WAAW,GAAG,MAAM,EAAE,CAAC;AAC9B,GAAG,IAAI,WAAW,IAAI,WAAW,CAAC,IAAI,IAAI,CAAC,cAAc,CAAC,WAAW,CAAC,EAAE;AACxE,IAAI,KAAK,GAAG,CAAC,CAAC;AACd,IAAI,MAAM;AACV,IAAI;AACJ,GAAG;AACH,EAAE;AACF,CAAC,IAAI,IAAI,GAAG,IAAI,KAAK,EAAE,CAAC;AACxB,CAAC,IAAI,MAAM,GAAG,OAAO,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,EAAE,CAAC,CAAC,CAAC;AAC1C,CAAC,CAAC,KAAK,KAAK,CAAC,GAAG,cAAc,CAAC,IAAI,CAAC,gBAAgB,CAAC,GAAG,KAAK,KAAK,CAAC,GAAG,MAAM,CAAC,IAAI,CAAC,gBAAgB,CAAC,GAAG,WAAW,CAAC,IAAI,CAAC,kBAAkB,CAAC,EAAE,IAAI,CAAC,KAAK,CAAC,EAAE,MAAM,CAAC,CAAC;AACjK,CAAC,OAAO,IAAI,CAAC;AACb,CAAC,SAAS,gBAAgB,CAAC,KAAK,EAAE;AAClC,EAAE,MAAM,GAAG,KAAK,CAAC;AACjB,EAAE,GAAG;AACL,GAAG,IAAI,MAAM,EAAE;AACf,IAAI,WAAW,GAAG,MAAM,EAAE,CAAC;AAC3B,IAAI,IAAI,WAAW,IAAI,WAAW,CAAC,IAAI,IAAI,CAAC,cAAc,CAAC,WAAW,CAAC,EAAE;AACzE,KAAK,WAAW,CAAC,IAAI,CAAC,kBAAkB,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,MAAM,CAAC,CAAC;AAC/D,KAAK,OAAO;AACZ,KAAK;AACL,IAAI;AACJ,GAAG,cAAc,GAAG,IAAI,EAAE,CAAC;AAC3B,GAAG,IAAI,CAAC,cAAc,KAAK,cAAc,CAAC,cAAc,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC,CAAC,EAAE;AACjF,IAAI,OAAO,CAAC,IAAI,EAAE,CAAC,EAAE,MAAM,CAAC,CAAC;AAC7B,IAAI,OAAO;AACX,IAAI;AACJ,GAAG,IAAI,cAAc,CAAC,IAAI,EAAE;AAC5B,IAAI,cAAc,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,MAAM,CAAC,CAAC;AAC/D,IAAI,OAAO;AACX,IAAI;AACJ,GAAG,MAAM,GAAG,IAAI,EAAE,CAAC;AACnB,GAAG,IAAI,cAAc,CAAC,MAAM,CAAC,EAAE;AAC/B,IAAI,MAAM,GAAG,MAAM,CAAC,CAAC,CAAC;AACtB,IAAI;AACJ,GAAG,QAAQ,CAAC,MAAM,IAAI,CAAC,MAAM,CAAC,IAAI,EAAE;AACpC,EAAE,MAAM,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,MAAM,CAAC,CAAC;AACrD,EAAE;AACF,CAAC,SAAS,gBAAgB,CAAC,cAAc,EAAE;AAC3C,EAAE,IAAI,cAAc,EAAE;AACtB,GAAG,MAAM,GAAG,IAAI,EAAE,CAAC;AACnB,GAAG,IAAI,MAAM,IAAI,MAAM,CAAC,IAAI,EAAE;AAC9B,IAAI,MAAM,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,MAAM,CAAC,CAAC;AACvD,IAAI,MAAM;AACV,IAAI,gBAAgB,CAAC,MAAM,CAAC,CAAC;AAC7B,IAAI;AACJ,GAAG,MAAM;AACT,GAAG,OAAO,CAAC,IAAI,EAAE,CAAC,EAAE,MAAM,CAAC,CAAC;AAC5B,GAAG;AACH,EAAE;AACF,CAAC,SAAS,kBAAkB,GAAG;AAC/B,EAAE,IAAI,cAAc,GAAG,IAAI,EAAE,EAAE;AAC/B,GAAG,IAAI,cAAc,CAAC,IAAI,EAAE;AAC5B,IAAI,cAAc,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,MAAM,CAAC,CAAC;AAC/D,IAAI,MAAM;AACV,IAAI,gBAAgB,CAAC,cAAc,CAAC,CAAC;AACrC,IAAI;AACJ,GAAG,MAAM;AACT,GAAG,OAAO,CAAC,IAAI,EAAE,CAAC,EAAE,MAAM,CAAC,CAAC;AAC5B,GAAG;AACH,EAAE;AACF,CAAC;;AC7UD,IAAM6C,kBAAkB,GAAG,OAA3B;AAEA,IAAaC,kBAAb;AAYE;kCAOS;QANPf,kBAAAA;QACAgB,8BAAAA;QACA9C,cAAAA;QACAF,sBAAAA;QACAC,WAAAA;8BACAgD;QAAAA,wCAAYH;;AAEZ,SAAKd,UAAL,GAAkBA,UAAlB;AACA,SAAKgB,sBAAL,GAA8BA,sBAA9B;AACA,SAAK9C,MAAL,GAAcA,MAAd;AACA,SAAKF,cAAL,GAAsBA,cAAtB;AACA,SAAKC,GAAL,GAAWA,GAAX;AACA,SAAKgD,SAAL,GAAiBA,SAAjB;AACA,SAAK1F,MAAL,GAAc,CAAd;AACA,SAAK2F,WAAL,GAAmB,CAAnB;AACA,SAAKC,KAAL,GAAa,CAAb;AACD;;AA7BH;;AAAA,SA+BEC,KA/BF,GA+BE;AACE,SAAK1F,MAAL,GAAc,IAAIR,UAAJ,CAAe,KAAK+F,SAApB,CAAd;AACD,GAjCH;;AAAA,SAmCQ9B,SAnCR,sBAmCkBC,KAnClB,EAmC8BC,UAnC9B;AAAA;mBAoCuB;;UAAX3D,gBAAAA;;AAGR,UAAI,EAAE0D,KAAK,YAAYlE,UAAnB,CAAJ,EAAoC;AAClC,cAAM,IAAIE,SAAJ,CAAc,4BAAd,CAAN;AACD;;;iBACMgE;6BAAO;AACZ,YAAMiC,KAAK,GAAG3F,MAAM,CAACP,MAAP,GAAgB,OAAKI,MAAnC;;AACA,YAAI6D,KAAK,CAACjE,MAAN,IAAgBkG,KAApB,EAA2B;AACzB3F,UAAAA,MAAM,CAACI,GAAP,CAAWsD,KAAX,EAAkB,OAAK7D,MAAvB;AACA,iBAAKA,MAAL,IAAe6D,KAAK,CAACxD,UAArB;AACA,iBAAKsF,WAAL,IAAoB9B,KAAK,CAACxD,UAA1B;AACAwD,UAAAA,KAAK,GAAG,IAAR;AACD,SALD,MAKO;AACL,cAAMkC,OAAO,GAAG,IAAIpG,UAAJ,CAAekE,KAAK,CAAC1D,MAArB,EAA6B0D,KAAK,CAACzD,UAAnC,EAA+C0F,KAA/C,CAAhB;AACAjC,UAAAA,KAAK,GAAG,IAAIlE,UAAJ,CACNkE,KAAK,CAAC1D,MADA,EAEN0D,KAAK,CAACzD,UAAN,GAAmB0F,KAFb,EAGNjC,KAAK,CAACjE,MAAN,GAAekG,KAHT,CAAR;AAKA3F,UAAAA,MAAM,CAACI,GAAP,CAAWwF,OAAX,EAAoB,OAAK/F,MAAzB;AACA,iBAAKA,MAAL,IAAe8F,KAAf;AACA,iBAAKH,WAAL,IAAoBG,KAApB;AACD,SAjBW;;;AAAA;AAAA,cAoBRjC,KApBQ;AAAA,mCAqBJ,OAAKmC,KAAL,CAAWlC,UAAX,CArBI;AAAA;AAAA;;AAAA;AAuBb;AACF,KAlEH;AAAA;AAAA;AAAA;;AAAA,SAoEQkC,KApER,kBAoEclC,UApEd;AAAA;mBAqEQ;;AAAJ,UAAI,OAAK9D,MAAL,KAAgB,CAApB,EAAuB;AACrB;AACA;AACD;;;UAGOG,gBAAAA;AACR,UAAMiC,IAAI,GAAG,IAAIzC,UAAJ,CAAeQ,MAAM,CAACA,MAAtB,EAA8BA,MAAM,CAACC,UAArC,EAAiD,OAAKJ,MAAtD,CAAb;6BACkB,OAAKgD,OAAL,CAAaZ,IAAb,kBAAZ2B;AAEN;AACA,eAAK/D,MAAL,GAAc,CAAd;AAEA8D,QAAAA,UAAU,CAACE,OAAX,CAAmB;AACjB4B,UAAAA,KAAK,EAAE,OAAKA,KAAL,EADU;AAEjB5F,UAAAA,MAAM,EAAE,OAAK2F,WAFI;AAGjB5B,UAAAA,GAAG,EAAHA;AAHiB,SAAnB;;AAKD,KAvFH;AAAA;AAAA;AAAA;;AAAA,SAyFQf,OAzFR,oBAyFgBZ,IAzFhB;AAAA;mBA0F4C;;UAAhCO,gBAAAA;UAAQF,wBAAAA;UAAgBC,aAAAA;6BACMC,MAAM,CAACK,OAAP,CAAe;AACnDZ,QAAAA,IAAI,EAAJA,IADmD;AAEnDK,QAAAA,cAAc,EAAdA,cAFmD;AAGnDC,QAAAA,GAAG,EAAHA;AAHmD,OAAf;YAA9BJ,mBAAAA;YAAYC,WAAAA;YAAIC,YAAAA;AAMxB;AACA,YAAMuB,GAAG,GAAG;AACV,uBAAW,OAAK0B,sBADN;AAEVhB,UAAAA,UAAU,EAAE,OAAKA,UAFP;AAGVlC,UAAAA,EAAE,EAAE6B,SAAS,CAACzC,MAAV,CAAiBY,EAAjB,CAHM;AAIVD,UAAAA,UAAU,EAAE8B,SAAS,CAACzC,MAAV,CAAiBW,UAAjB,CAJF;AAKVE,UAAAA,GAAG,EAAE4B,SAAS,CAACzC,MAAV,CAAiBa,GAAjB;AALK,SAAZ;AAOA,eAAOuB,GAAP;;AACD,KA1GH;AAAA;AAAA;AAAA;;AAAA;AAAA;;ICCakC,MAAb;AAIE;;;;;;;;;;;;AAYA,kBAAmBtC,YAAnB;AAAmB,qBAAA,GAAAA,YAAA;AACjB,SAAKuC,OAAL,GAAe,aAAf;;AAEA,SAAKvD,MAAL,GAAca,KAAd;AACD;AAED;;;;;;;;;;;;;;;;;;;;;;;AAtBF;;AAAA,SA2CQ2C,mBA3CR;AAAA,QA2C8B1B,UA3C9B,QA2C8BA,UA3C9B;AAAA,QA2C0C2B,WA3C1C,QA2C0CA,WA3C1C;AAAA,QA2CuDV,SA3CvD,QA2CuDA,SA3CvD;;AAAA;mBA4C8B;;6BAAA,OAAKW,wBAAL,CAA8B;AACtD5B,QAAAA,UAAU,EAAVA,UADsD;AAEtD2B,QAAAA,WAAW,EAAXA,WAFsD;AAGtDV,QAAAA,SAAS,EAATA;AAHsD,OAA9B,kBAApBY;AAKN,eAAO,IAAIC,wBAAJ,CAAoBD,WAApB,CAAP;;AACD,KAlDH;AAAA;AAAA;AAAA;AAoDE;;;;;;;;;;;;;;;;;;;AApDF;;AAAA,SAuEQE,mBAvER;AAAA,QAuE8B9C,eAvE9B,SAuE8BA,eAvE9B;;AAAA;mBAwE8B;;6BAAA,OAAK+C,wBAAL,CAA8B;AACtD/C,QAAAA,eAAe,EAAfA;AADsD,OAA9B,kBAApB4C;AAGN,eAAO,IAAIC,wBAAJ,CAAoBD,WAApB,CAAP;;AACD,KA5EH;AAAA;AAAA;AAAA;AA8EE;;;;;;;;;;;;;;;;;;;AA9EF;;AAAA,SAiGQtD,OAjGR;AAAA,QAiGkBZ,IAjGlB,SAiGkBA,IAjGlB;AAAA,QAiGwBqC,UAjGxB,SAiGwBA,UAjGxB;AAAA,QAiGoC2B,WAjGpC,SAiGoCA,WAjGpC;;AAAA;mBAwG8B;;AAN1B,UAAI,EAAEhE,IAAI,YAAYzC,UAAlB,KAAiC,OAAOyC,IAAP,KAAgB,QAArD,EAA+D;AAC7D,cAAM,IAAIvC,SAAJ,CAAc,0CAAd,CAAN;AACD;;AACD,UAAIuC,IAAJ,EAAU;AACRA,QAAAA,IAAI,GAAGD,kBAAkB,CAACC,IAAD,CAAzB;AACD;;6BACyB,OAAKiE,wBAAL,CAA8B;AACtD5B,QAAAA,UAAU,EAAVA,UADsD;AAEtD2B,QAAAA,WAAW,EAAXA;AAFsD,OAA9B,kBAApBE;AAIN,eAAOA,WAAW,CAACtD,OAAZ,CAAoBZ,IAApB,CAAP;;AACD,KA7GH;AAAA;AAAA;AAAA;AA+GE;;;;;;;;AA/GF;;AAAA,SAuHQsE,aAvHR;AAAA,QAuHwBC,GAvHxB,SAuHwBA,GAvHxB;AAAA,QAuHgCC,IAvHhC;;AAAA;mBA2HW;;AAHP,UAAI,OAAOD,GAAP,KAAe,QAAnB,EAA6B;AAC3B,cAAM,IAAI9G,SAAJ,CAAc,0BAAd,CAAN;AACD;;AACD,6BAAO,OAAKmD,OAAL;AAAeZ,QAAAA,IAAI,EAAE8B,IAAI,CAAC2C,SAAL,CAAeF,GAAf;AAArB,SAA6CC,IAA7C,EAAP;AACD,KA5HH;AAAA;AAAA;AAAA;AA8HE;;;;;;;;;;;;;;;;;;;;;AA9HF;;AAAA,SAmJQvE,OAnJR;AAAA,QAmJkB0B,GAnJlB,SAmJkBA,GAnJlB;AAAA,QAmJuBL,eAnJvB,SAmJuBA,eAnJvB;;AAAA;oBAoJ8B;;6BAAA,QAAK+C,wBAAL,CAA8B;AACtD/C,QAAAA,eAAe,EAAfA;AADsD,OAA9B,kBAApB4C;AAGN,eAAOA,WAAW,CAACjE,OAAZ,CAAoB0B,GAApB,CAAP;;AACD,KAxJH;AAAA;AAAA;AAAA;AA0JE;;;;;;;;;;;;AA1JF;;AAAA,SAsKQ+C,aAtKR;AAAA,QAsKwB/C,GAtKxB,SAsKwBA,GAtKxB;AAAA,QAsK6BL,eAtK7B,SAsK6BA,eAtK7B;;AAAA;oBAuKuB;;6BAAA,QAAKrB,OAAL,CAAa;AAAE0B,QAAAA,GAAG,EAAHA,GAAF;AAAOL,QAAAA,eAAe,EAAfA;AAAP,OAAb,kBAAbtB;eACDA,OAKE8B,IAAI,CAACC,KAAL,CAAWrD,MAAM,CAACC,IAAP,CAAYqB,IAAZ,EAAkBiC,QAAlB,EAAX,IAHE;;AAIV,KA9KH;AAAA;AAAA;AAAA;AAgLE;;;;;;;;;;;;;;;;;;;;;AAhLF;;AAAA,SAqMQgC,wBArMR;AAAA,QAqMmC5B,UArMnC,SAqMmCA,UArMnC;AAAA,QAqM+C2B,WArM/C,SAqM+CA,WArM/C;AAAA,QAqM4DV,SArM5D,SAqM4DA,SArM5D;;AAAA;oBA2MgB;;AALZ,UAAI,EAAEnB,KAAK,CAACC,OAAN,CAAcC,UAAd,KAA6BA,UAAU,CAAC7E,MAAX,GAAoB,CAAnD,CAAJ,EAA2D;AACzD,cAAM,IAAIC,SAAJ,CAAc,yCAAd,CAAN;AACD;;;AAGD,UAAMkH,GAAG,GAAG,QAAKpD,YAAL,CAAkBqD,OAA9B;;AACA,UAAI,CAACvC,UAAU,CAACwC,KAAX,CAAiB,UAAClF,CAAD;AAAA,eAAOA,CAAC,CAACkC,MAAF,IAAYlC,CAAC,CAACkC,MAAF,CAAS8C,GAAT,KAAiBA,GAApC;AAAA,OAAjB,CAAL,EAAgE;AAC9D,cAAM,IAAI5F,KAAJ,8CAAoD4F,GAApD,SAAN;AACD;;UACOpE,iBAAAA;;6BAGUA,MAAM,CAACU,WAAP,mBAAZX;AAEN;+BACyBwE,OAAO,CAACC,GAAR,CACvB1C,UAAU,CAAC2C,GAAX,CAAe,UAACrF,CAAD;AAAA,iBAAOqE,WAAW,CAAC;AAAEtB,YAAAA,EAAE,EAAE/C,CAAC,CAACkC,MAAF,CAASY;AAAf,WAAD,CAAlB;AAAA,SAAf,CADuB,kBAAnBwC;AAIN,cAAIC,OAAO,GAAGC,SAAd;;AACA,cAAIF,UAAU,CAAC,CAAD,CAAV,CAAcG,IAAd,KAAuB,gBAA3B,EAA6C;AAC3C;AACA;AACAF,YAAAA,OAAO,GAAG;AAAEG,cAAAA,GAAG,EAAE,IAAP;AAAaC,cAAAA,SAAS,EAAEL,UAAU,CAAC,CAAD,CAAV,CAAcM,YAAd,CAA2BC;AAAnD,aAAV;AACD;;;iCAG8B,QAAKjE,YAAL,CAAkBkE,wBAAlB,CAC7BP,OAD6B,kBAAzBQ;AAIN;mCAC6BZ,OAAO,CAACC,GAAR,CAC3BE,UAAU,CAACD,GAAX,CAAe,UAACW,eAAD;AAAA,qBACb,QAAKpE,YAAL,CAAkBqE,iBAAlB,CAAoC;AAClCF,gBAAAA,gBAAgB,EAAhBA,gBADkC;AAElCC,gBAAAA,eAAe,EAAfA;AAFkC,eAApC,CADa;AAAA,aAAf,CAD2B,kBAAvBE;AASN;qCACMf,OAAO,CAACC,GAAR,CACJ1C,UAAU,CAAC2C,GAAX,WAAsBnC,SAAtB,EAAiCiD,CAAjC;AAAA;0CACiCD,cAAc,CAACC,CAAD;sBAArC5C,wBAAAA;sBAAKF,wBAAAA;sBAAK+C,wBAAAA;sBAAKC,wBAAAA;AACvB3D,kBAAAA,UAAU,CAACyD,CAAD,CAAV,GAAgBjD,SAAS,GAAG;AAAEhB,oBAAAA,MAAM,eAAOgB,SAAS,CAAChB,MAAjB;AAAR,mBAA5B;AACAgB,kBAAAA,SAAS,CAAChB,MAAV,CAAiBmB,GAAjB,GAAuBA,GAAvB;AACAH,kBAAAA,SAAS,CAAChB,MAAV,CAAiBkE,GAAjB,GAAuBA,GAAvB;AACAlD,kBAAAA,SAAS,CAAChB,MAAV,CAAiBmE,GAAjB,GAAuBA,GAAvB;yCACgC9C,GAAG,CAAC/D,OAAJ,CAAY;AAAEC,oBAAAA,YAAY,EAAEkB;AAAhB,mBAAZ;AAAhCuC,oBAAAA,SAAS,CAACE,aAAV;;AACD,iBAPD;AAAA;AAAA;AAAA,gBADI;AAWN;AACA;AACA,oBAAMb,GAAG,GAAG3B,MAAM,CAACW,OAAnB;AACA,oBAAM+E,kBAAkB,GAAGnE,IAAI,CAAC2C,SAAL,CAAe;AAAEvC,kBAAAA,GAAG,EAAHA;AAAF,iBAAf,CAA3B;AACA,oBAAMmB,sBAAsB,GAAGrB,SAAS,CAACzC,MAAV,CAC7Bb,MAAM,CAACC,IAAP,CAAYoB,kBAAkB,CAACkG,kBAAD,CAA9B,CAD6B,CAA/B;;AAIA,oBAAM5F,cAAc,GAAGN,kBAAkB,CAACsD,sBAAD,CAAzC;AAEA,uBAAO,IAAID,kBAAJ,CAAuB;AAC5Bf,kBAAAA,UAAU,EAAVA,UAD4B;AAE5BgB,kBAAAA,sBAAsB,EAAtBA,sBAF4B;AAG5B9C,kBAAAA,MAAM,EAANA,MAH4B;AAI5BF,kBAAAA,cAAc,EAAdA,cAJ4B;AAK5BC,kBAAAA,GAAG,EAAHA,GAL4B;AAM5BgD,kBAAAA,SAAS,EAATA;AAN4B,iBAAvB,CAAP;;;;;;AAQD,KA7QH;AAAA;AAAA;AAAA;AA+QE;;;;;;;;AA/QF;;AAAA,SAuRQe,wBAvRR;AAAA,QAuRmC/C,eAvRnC,SAuRmCA,eAvRnC;;AAAA;oBAyRoB;;AADhB,6BAAO,IAAID,kBAAJ,CAAuB;AAC5BE,QAAAA,YAAY,EAAE,QAAKA,YADS;AAE5BD,QAAAA,eAAe,EAAfA;AAF4B,OAAvB,CAAP;AAID,KA5RH;AAAA;AAAA;AAAA;;AAAA;AAAA;;ICPa4E,eAAe,GAAG,SAAlBA,eAAkB,CAACC,OAAD,EAA8BC,IAA9B;AAC7B,MAAMX,wBAAwB,YAAxBA,wBAAwB;AAAA;6BACXU,OAAO,CAACE,QAAR,CAAiBD,IAAjB,kBAAXE;+BACgBA,EAAE,CAACC,gBAAH,CAAoB,IAApB,kBAAhBC;AAEN,iBAAO;AACLA,YAAAA,OAAO,EAAPA,OADK;AAELxD,YAAAA,GAAG,EAAEwD,OAAO,CAACjB;AAFR,WAAP;;;AAID,KAR6B;AAAA;AAAA;AAAA,GAA9B;;AASA,SAAOE,wBAAP;AACD,CAXM;;;;;;;"}