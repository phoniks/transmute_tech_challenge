'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var webcrypto = require('@peculiar/webcrypto');
var base64url = _interopDefault(require('base64url'));
var aesKw = require('@stablelib/aes-kw');
var ponyfill = require('web-streams-polyfill/ponyfill');
var xchacha20poly1305 = require('@stablelib/xchacha20poly1305');

function isNodejs() {
  return typeof process === 'object' && typeof process.versions === 'object' && typeof process.versions.node !== 'undefined';
}

var crypto;

if (isNodejs()) {
  crypto = /*#__PURE__*/new webcrypto.Crypto();
} else {
  crypto = window.crypto;
}

var crypto$1 = crypto;

/*!
 * Copyright (c) 2019-2020 Digital Bazaar, Inc. All rights reserved.
 */

/**
 * Derives a 256-bit AES-KW key encryption key from a shared secret that
 * was derived from an ephemeral and static pair
 * of Elliptic Curve Diffie-Hellman keys.
 *
 * The KDF used is described in RFC 7518. This KDF is referenced by RFC 8037,
 * which defines how to perform Curve25519 (X25519) ECDH key agreement.
 *
 * @param {object} options - The options to use.
 * @param {Uint8Array} options.secret - The shared secret (i.e., `Z`) to use.
 * @param {Uint8Array} options.producerInfo - An array of application-specific
 *   bytes describing the consumer (aka the "encrypter" or "sender").
 * @param {Uint8Array} options.consumerInfo - An array of application-specific
 *   bytes describing the producer (aka the "decrypter" or
 *   "receiver"/"recipient").
 *
 * @returns {Promise<Uint8Array>} - Resolves to the generated key.
 */
var deriveKey = function deriveKey(_ref) {
  var secret = _ref.secret,
      producerInfo = _ref.producerInfo,
      consumerInfo = _ref.consumerInfo;

  try {
    if (!(secret instanceof Uint8Array && secret.length > 0)) {
      throw new TypeError('"secret" must be a non-empty Uint8Array.');
    }

    if (!(producerInfo instanceof Uint8Array && producerInfo.length > 0)) {
      throw new TypeError('"producerInfo" must be a non-empty Uint8Array.');
    }

    if (!(consumerInfo instanceof Uint8Array && consumerInfo.length > 0)) {
      throw new TypeError('"consumerInfo" must be a non-empty Uint8Array.');
    } // the output of Concat KDF is hash(roundNumber || Z || OtherInfo)
    // where roundNumber is always 1 because the hash length is presumed to
    // ...match the key length, encoded as a big endian 32-bit integer
    // where OtherInfo is:
    // AlgorithmID || PartyUInfo || PartyVInfo || SuppPubInfo
    // where SuppPubInfo is the key length in bits, big endian encoded as a
    // 32-bit number, i.e., 256 === [0, 0, 1, 0]


    var input = new Uint8Array(4 + // round number
    secret.length + // `Z`
    ALGORITHM_ID.length + // AlgorithmID
    4 + producerInfo.length + // PartyUInfo
    4 + consumerInfo.length + // PartyVInfo
    4); // SuppPubInfo (key data length in bits)

    var offset = 0;

    var _dv = new DataView(input.buffer, input.byteOffset, input.byteLength);

    _dv.setUint32(offset, 1);

    input.set(secret, offset += 4);
    input.set(ALGORITHM_ID, offset += secret.length);

    _dv.setUint32(offset += ALGORITHM_ID.length, producerInfo.length);

    input.set(producerInfo, offset += 4);

    _dv.setUint32(offset += producerInfo.length, consumerInfo.length);

    input.set(consumerInfo, offset += 4);

    _dv.setUint32(offset += consumerInfo.length, KEY_LENGTH); // hash input and return result as derived key


    return Promise.resolve(crypto$1.subtle.digest(HASH_ALGORITHM, input)).then(function (_crypto$subtle$digest) {
      return new Uint8Array(_crypto$subtle$digest);
    });
  } catch (e) {
    return Promise.reject(e);
  }
};
var KEY_ALGORITHM = 'ECDH-ES+A256KW'; // create static ALGORITHM_ID

var ALGORITHM_CONTENT = KEY_ALGORITHM; //new TextEncoder().encode();

var ALGORITHM_ID = /*#__PURE__*/new Uint8Array(4 + ALGORITHM_CONTENT.length); // write length of content as 32-bit big endian integer, then write content

var dv = /*#__PURE__*/new DataView(ALGORITHM_ID.buffer, ALGORITHM_ID.byteOffset, ALGORITHM_ID.byteLength);
dv.setUint32(0, ALGORITHM_CONTENT.length);
ALGORITHM_ID.set(Buffer.from(ALGORITHM_CONTENT), 4); // RFC 7518 Section 4.6.2 specifies using SHA-256 for ECDH-ES KDF
// https://tools.ietf.org/html/rfc7518#section-4.6.2

var HASH_ALGORITHM = {
  name: 'SHA-256'
}; // derived keys are always 256-bits

var KEY_LENGTH = 256;

var KeyEncryptionKey = /*#__PURE__*/function () {
  function KeyEncryptionKey(key) {
    if (key.length !== 32) {
      throw new Error('key must be 32 bytes');
    }

    this.aeskw = new aesKw.AESKW(key);
    this.algorithm = {
      name: 'A256KW'
    };
  }
  /**
   * Wraps a cryptographic key.
   *
   * @param {object} options - The options to use.
   * @param {Uint8Array} options.unwrappedKey - The key material as a
   *   `Uint8Array`.
   *
   * @returns {string} - The base64url-encoded wrapped key bytes.
   */


  var _proto = KeyEncryptionKey.prototype;

  _proto.wrapKey = function wrapKey(_ref) {
    var unwrappedKey = _ref.unwrappedKey;
    var wrappedKey = this.aeskw.wrapKey(unwrappedKey);
    return base64url.encode(Buffer.from(wrappedKey));
  }
  /**
   * Unwraps a cryptographic key.
   *
   * @param {object} options - The options to use.
   * @param {string} options.wrappedKey - The wrapped key material as a
   *   base64url-encoded string.
   *
   * @returns {Uint8Array} - Resolves to the key bytes or null if
   *   the unwrapping fails because the key does not match.
   */
  ;

  _proto.unwrapKey = function unwrapKey(_ref2) {
    var wrappedKey = _ref2.wrappedKey;

    var _wrappedKey = base64url.toBuffer(wrappedKey);

    try {
      return this.aeskw.unwrapKey(_wrappedKey);
    } catch (e) {
      // decryption failed
      console.error(e);
      return null;
    }
  };

  return KeyEncryptionKey;
}();

KeyEncryptionKey.createKek = function (_ref3) {
  var keyData = _ref3.keyData;

  try {
    return Promise.resolve(new KeyEncryptionKey(keyData));
  } catch (e) {
    return Promise.reject(e);
  }
};

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function stringToUint8Array(data) {
  if (typeof data === 'string') {
    // convert data to Uint8Array
    return new Uint8Array(Buffer.from(data));
  }

  if (!(data instanceof Uint8Array)) {
    throw new TypeError('"data" be a string or Uint8Array.');
  }

  return data;
}

/*!
 * Copyright (c) 2019-2020 Digital Bazaar, Inc. All rights reserved.
 */

/**
 * Decrypts some encrypted data. The data must have been encrypted using
 * the given XChaCha20Poly1305 (draft-irtf-cfrg-xchacha-01) content encryption
 * key (CEK).
 *
 * @param {object} options - The options to use.
 * @param {Uint8Array} options.ciphertext - The data to decrypt.
 * @param {Uint8Array} options.iv - The initialization vector (aka nonce).
 * @param {Uint8Array} options.tag - The authentication tag.
 * @param {Uint8Array} [options.additionalData] - Optional additional
 *   authentication data.
 * @param {Uint8Array} options.cek - The content encryption key to use.
 *
 * @returns {Promise<Uint8Array>} The decrypted data.
 */
var decrypt = function decrypt(_ref2) {
  var ciphertext = _ref2.ciphertext,
      iv = _ref2.iv,
      tag = _ref2.tag,
      additionalData = _ref2.additionalData,
      cek = _ref2.cek;

  try {
    if (!(iv instanceof Uint8Array)) {
      throw new Error('Invalid or missing "iv".');
    }

    if (!(ciphertext instanceof Uint8Array)) {
      throw new Error('Invalid or missing "ciphertext".');
    }

    if (!(tag instanceof Uint8Array)) {
      throw new Error('Invalid or missing "tag".');
    }

    if (!(cek instanceof Uint8Array)) {
      throw new TypeError('"cek" must be a Uint8Array.');
    } // decrypt `ciphertext`


    var cipher = new xchacha20poly1305.XChaCha20Poly1305(cek);
    var encrypted = new Uint8Array(ciphertext.length + cipher.tagLength);
    encrypted.set(ciphertext);
    encrypted.set(tag, ciphertext.length);
    return Promise.resolve(cipher.open(iv, encrypted, additionalData));
  } catch (e) {
    return Promise.reject(e);
  }
};

/**
 * Encrypts some data. The data will be encrypted using the given
 * 256-bit XChaCha20Poly1305 (draft-irtf-cfrg-xchacha-01) content encryption
 * key (CEK).
 *
 * @param {object} options - The options to use.
 * @param {Uint8Array} options.data - The data to encrypt.
 * @param {Uint8Array} [options.additionalData] - Optional additional
 *   authentication data.
 * @param {Uint8Array} options.cek - The content encryption key to use.
 *
 * @returns {Promise<object>} - Resolves to `{ciphertext, iv, tag}`.
 */
var encrypt = function encrypt(_ref) {
  var data = _ref.data,
      additionalData = _ref.additionalData,
      cek = _ref.cek;

  try {
    if (!(data instanceof Uint8Array)) {
      throw new TypeError('"data" must be a Uint8Array.');
    }

    if (!(cek instanceof Uint8Array)) {
      throw new TypeError('"cek" must be a Uint8Array.');
    }

    var cipher = new xchacha20poly1305.XChaCha20Poly1305(cek); // Note: Uses a random value here as a counter is not viable -- multiple
    // recipients may be trying to update at the same time and use the same
    // counter breaking security; using XChaCha20Poly1305 once available will
    // further reduce chances of a collision as it has a 192-bit IV

    var iv = crypto$1.getRandomValues(new Uint8Array(cipher.nonceLength)); // encrypt data

    var encrypted = cipher.seal(iv, data, additionalData); // split ciphertext and tag

    var ciphertext = encrypted.subarray(0, encrypted.length - cipher.tagLength);
    var tag = encrypted.subarray(encrypted.length - cipher.tagLength);
    return Promise.resolve({
      ciphertext: ciphertext,
      iv: iv,
      tag: tag
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

/**
 * Generates a content encryption key (CEK). The 256-bit key is intended to be
 * used as a XChaCha20Poly1305 (draft-irtf-cfrg-xchacha-01) key.
 *
 * @returns {Promise<Uint8Array>} - Resolves to the generated key.
 */
var generateKey = function generateKey() {
  try {
    // generate content encryption key
    return Promise.resolve(crypto$1.getRandomValues(new Uint8Array(xchacha20poly1305.KEY_LENGTH)));
  } catch (e) {
    return Promise.reject(e);
  }
};
var JWE_ENC = 'XC20P';

var xc20p = {
  __proto__: null,
  decrypt: decrypt,
  encrypt: encrypt,
  generateKey: generateKey,
  JWE_ENC: JWE_ENC
};

var _CIPHER_ALGORITHMS;
var CIPHER_ALGORITHMS = (_CIPHER_ALGORITHMS = {}, _CIPHER_ALGORITHMS[JWE_ENC] = xc20p, _CIPHER_ALGORITHMS);
var DecryptTransformer = /*#__PURE__*/function () {
  function DecryptTransformer(_temp) {
    var _ref = _temp === void 0 ? {} : _temp,
        keyAgreementKey = _ref.keyAgreementKey,
        KeyPairClass = _ref.KeyPairClass;

    if (!keyAgreementKey) {
      throw new TypeError('"keyAgreementKey" is a required parameter.');
    }

    this.KeyPairClass = KeyPairClass;
    this.keyAgreementKey = keyAgreementKey;
  }

  var _proto = DecryptTransformer.prototype;

  _proto.transform = function transform(chunk, controller) {
    try {
      var _this2 = this;

      // assumes `chunk` is an object with a JWE under the `jwe` property
      if (!(chunk && typeof chunk === 'object')) {
        throw new TypeError('"chunk" must be an object.');
      }

      var jwe = chunk.jwe;
      return Promise.resolve(_this2.decrypt(jwe)).then(function (data) {
        if (data === null) {
          var error = new Error('Invalid decryption key.');
          error.name = 'DataError';
          throw error;
        }

        controller.enqueue(data);
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.decrypt = function decrypt(jwe) {
    try {
      var _this4 = this;

      // validate JWE
      if (!(jwe && typeof jwe === 'object')) {
        throw new TypeError('"jwe" must be an object.');
      }

      if (typeof jwe["protected"] !== 'string') {
        throw new TypeError('"jwe.protected" is missing or not a string.');
      }

      if (typeof jwe.iv !== 'string') {
        throw new Error('Invalid or missing "iv".');
      }

      if (typeof jwe.ciphertext !== 'string') {
        throw new Error('Invalid or missing "ciphertext".');
      }

      if (typeof jwe.tag !== 'string') {
        throw new Error('Invalid or missing "tag".');
      } // validate encryption header


      var header;
      var additionalData;

      try {
        // ASCII(BASE64URL(UTF8(JWE Protected Header)))
        additionalData = stringToUint8Array(jwe["protected"]);
        header = JSON.parse(base64url.toBuffer(jwe["protected"]).toString());
      } catch (e) {
        throw new Error('Invalid JWE "protected" header.');
      }

      if (!(header.enc && typeof header.enc === 'string')) {
        throw new Error('Invalid JWE "enc" header.');
      }

      var cipher = CIPHER_ALGORITHMS[header.enc];

      if (!cipher) {
        throw new Error('Unsupported encryption algorithm "${header.enc}".');
      }

      if (!Array.isArray(jwe.recipients)) {
        throw new TypeError('"jwe.recipients" must be an array.');
      } // find `keyAgreementKey` matching recipient


      var keyAgreementKey = _this4.keyAgreementKey;

      var _findRecipient = function _findRecipient(recipients, key) {
        return recipients.find(function (rec) {
          return rec.header && rec.header.kid === key.id || rec.header.kid.split('#').pop() === key.id.split('#').pop();
        });
      };

      var recipient = _findRecipient(jwe.recipients, keyAgreementKey);

      if (!recipient) {
        console.log(jwe.recipients, keyAgreementKey);
        throw new Error('No matching recipient found for key agreement key.');
      } // get wrapped CEK


      var wrappedKey = recipient.encrypted_key;

      if (typeof wrappedKey !== 'string') {
        throw new Error('Invalid or missing "encrypted_key".');
      } // TODO: consider a cache of encrypted_key => CEKs to reduce unwrapping
      // calls which may even need to hit the network (e.g., Web KMS)
      // derive KEK and unwrap CEK


      var epk = recipient.header.epk;
      return Promise.resolve(_this4.KeyPairClass.kekFromEphemeralPeer({
        keyAgreementKey: keyAgreementKey,
        epk: epk
      })).then(function (_ref2) {
        var kek = _ref2.kek;
        return Promise.resolve(kek.unwrapKey({
          wrappedKey: wrappedKey
        })).then(function (cek) {
          if (!cek) {
            // failed to unwrap key
            return null;
          } // decrypt content


          var ciphertext = jwe.ciphertext,
              iv = jwe.iv,
              tag = jwe.tag;
          return cipher.decrypt({
            ciphertext: base64url.toBuffer(ciphertext),
            iv: base64url.toBuffer(iv),
            tag: base64url.toBuffer(tag),
            additionalData: additionalData,
            cek: cek
          });
        });
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  return DecryptTransformer;
}();

// A type of promise-like that resolves synchronously and supports only one observer
const _Pact = /*#__PURE__*/(function() {
	function _Pact() {}
	_Pact.prototype.then = function(onFulfilled, onRejected) {
		const result = new _Pact();
		const state = this.s;
		if (state) {
			const callback = state & 1 ? onFulfilled : onRejected;
			if (callback) {
				try {
					_settle(result, 1, callback(this.v));
				} catch (e) {
					_settle(result, 2, e);
				}
				return result;
			} else {
				return this;
			}
		}
		this.o = function(_this) {
			try {
				const value = _this.v;
				if (_this.s & 1) {
					_settle(result, 1, onFulfilled ? onFulfilled(value) : value);
				} else if (onRejected) {
					_settle(result, 1, onRejected(value));
				} else {
					_settle(result, 2, value);
				}
			} catch (e) {
				_settle(result, 2, e);
			}
		};
		return result;
	};
	return _Pact;
})();

// Settles a pact synchronously
function _settle(pact, state, value) {
	if (!pact.s) {
		if (value instanceof _Pact) {
			if (value.s) {
				if (state & 1) {
					state = value.s;
				}
				value = value.v;
			} else {
				value.o = _settle.bind(null, pact, state);
				return;
			}
		}
		if (value && value.then) {
			value.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));
			return;
		}
		pact.s = state;
		pact.v = value;
		const observer = pact.o;
		if (observer) {
			observer(pact);
		}
	}
}

function _isSettledPact(thenable) {
	return thenable instanceof _Pact && thenable.s & 1;
}

const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== "undefined" ? (Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator"))) : "@@iterator";

const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== "undefined" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol("Symbol.asyncIterator"))) : "@@asyncIterator";

// Asynchronously implement a generic for loop
function _for(test, update, body) {
	var stage;
	for (;;) {
		var shouldContinue = test();
		if (_isSettledPact(shouldContinue)) {
			shouldContinue = shouldContinue.v;
		}
		if (!shouldContinue) {
			return result;
		}
		if (shouldContinue.then) {
			stage = 0;
			break;
		}
		var result = body();
		if (result && result.then) {
			if (_isSettledPact(result)) {
				result = result.s;
			} else {
				stage = 1;
				break;
			}
		}
		if (update) {
			var updateValue = update();
			if (updateValue && updateValue.then && !_isSettledPact(updateValue)) {
				stage = 2;
				break;
			}
		}
	}
	var pact = new _Pact();
	var reject = _settle.bind(null, pact, 2);
	(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);
	return pact;
	function _resumeAfterBody(value) {
		result = value;
		do {
			if (update) {
				updateValue = update();
				if (updateValue && updateValue.then && !_isSettledPact(updateValue)) {
					updateValue.then(_resumeAfterUpdate).then(void 0, reject);
					return;
				}
			}
			shouldContinue = test();
			if (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {
				_settle(pact, 1, result);
				return;
			}
			if (shouldContinue.then) {
				shouldContinue.then(_resumeAfterTest).then(void 0, reject);
				return;
			}
			result = body();
			if (_isSettledPact(result)) {
				result = result.v;
			}
		} while (!result || !result.then);
		result.then(_resumeAfterBody).then(void 0, reject);
	}
	function _resumeAfterTest(shouldContinue) {
		if (shouldContinue) {
			result = body();
			if (result && result.then) {
				result.then(_resumeAfterBody).then(void 0, reject);
			} else {
				_resumeAfterBody(result);
			}
		} else {
			_settle(pact, 1, result);
		}
	}
	function _resumeAfterUpdate() {
		if (shouldContinue = test()) {
			if (shouldContinue.then) {
				shouldContinue.then(_resumeAfterTest).then(void 0, reject);
			} else {
				_resumeAfterTest(shouldContinue);
			}
		} else {
			_settle(pact, 1, result);
		}
	}
}

var DEFAULT_CHUNK_SIZE = 1048576;
var EncryptTransformer = /*#__PURE__*/function () {
  function EncryptTransformer(_temp) {
    var _ref = _temp === void 0 ? {} : _temp,
        recipients = _ref.recipients,
        encodedProtectedHeader = _ref.encodedProtectedHeader,
        cipher = _ref.cipher,
        additionalData = _ref.additionalData,
        cek = _ref.cek,
        _ref$chunkSize = _ref.chunkSize,
        chunkSize = _ref$chunkSize === void 0 ? DEFAULT_CHUNK_SIZE : _ref$chunkSize;

    this.recipients = recipients;
    this.encodedProtectedHeader = encodedProtectedHeader;
    this.cipher = cipher;
    this.additionalData = additionalData;
    this.cek = cek;
    this.chunkSize = chunkSize;
    this.offset = 0;
    this.totalOffset = 0;
    this.index = 0;
  }

  var _proto = EncryptTransformer.prototype;

  _proto.start = function start() {
    this.buffer = new Uint8Array(this.chunkSize);
  };

  _proto.transform = function transform(chunk, controller) {
    try {
      var _this2 = this;

      var buffer = _this2.buffer; // assumes `chunk` is a Uint8Array...

      if (!(chunk instanceof Uint8Array)) {
        throw new TypeError('"chunk" must be an object.');
      }

      return Promise.resolve(_for(function () {
        return !!chunk;
      }, void 0, function () {
        var space = buffer.length - _this2.offset;

        if (chunk.length <= space) {
          buffer.set(chunk, _this2.offset);
          _this2.offset += chunk.byteLength;
          _this2.totalOffset += chunk.byteLength;
          chunk = null;
        } else {
          var partial = new Uint8Array(chunk.buffer, chunk.byteOffset, space);
          chunk = new Uint8Array(chunk.buffer, chunk.byteOffset + space, chunk.length - space);
          buffer.set(partial, _this2.offset);
          _this2.offset += space;
          _this2.totalOffset += space;
        } // flush if buffer is full and more data remains


        var _temp2 = function () {
          if (chunk) {
            return Promise.resolve(_this2.flush(controller)).then(function () {});
          }
        }();

        if (_temp2 && _temp2.then) return _temp2.then(function () {});
      }));
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.flush = function flush(controller) {
    try {
      var _this4 = this;

      if (_this4.offset === 0) {
        // nothing to flush
        return Promise.resolve();
      } // encrypt data


      var buffer = _this4.buffer;
      var data = new Uint8Array(buffer.buffer, buffer.byteOffset, _this4.offset);
      return Promise.resolve(_this4.encrypt(data)).then(function (jwe) {
        // clear buffer
        _this4.offset = 0;
        controller.enqueue({
          index: _this4.index++,
          offset: _this4.totalOffset,
          jwe: jwe
        });
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.encrypt = function encrypt(data) {
    try {
      var _this6 = this;

      var cipher = _this6.cipher,
          additionalData = _this6.additionalData,
          cek = _this6.cek;
      return Promise.resolve(cipher.encrypt({
        data: data,
        additionalData: additionalData,
        cek: cek
      })).then(function (_ref2) {
        var ciphertext = _ref2.ciphertext,
            iv = _ref2.iv,
            tag = _ref2.tag;
        // represent encrypted data as JWE
        var jwe = {
          "protected": _this6.encodedProtectedHeader,
          recipients: _this6.recipients,
          iv: base64url.encode(iv),
          ciphertext: base64url.encode(ciphertext),
          tag: base64url.encode(tag)
        };
        return jwe;
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  return EncryptTransformer;
}();

var Cipher = /*#__PURE__*/function () {
  /**
   * Creates a new Cipher instance that can be used to encrypt or decrypt
   * data. A version must be supplied for encrypting data; the version
   * indicates whether a FIPS-compliant algorithm or the latest recommended
   * algorithm will be used.
   *
   * @param {string} [version='recommended'] - `fips` to use a FIPS-compliant
   *   algorithm, `recommended` to use the latest recommended algorithm when
   *   encrypting.
   *
   * @returns {Cipher} A Cipher used to encrypt and decrypt data.
   */
  function Cipher(KeyPairClass) {
    this.KeyPairClass = KeyPairClass;
    this.version = 'recommended'; // only recommended... agility should be explicit.

    this.cipher = xc20p;
  }
  /**
   * Creates a TransformStream that will encrypt some data for one or more
   * recipients and output a stream of chunks, each containing an object
   * with the property `jwe` with a JWE value.
   *
   * A list of recipients must be given in the `recipients` array, identified
   * by key agreement keys. An ephemeral ECDH key will be generated and used to
   * derive shared KEKs that will wrap a randomly generated CEK. Each recipient
   * in the `recipients` array will be updated to include the generated
   * ephemeral ECDH key.
   *
   * @param {object} options - The options for the stream.
   * @param {Array} options.recipients - An array of recipients for the
   *   encrypted content.
   * @param {Function} options.keyResolver - A function that returns a Promise
   *   that resolves a key ID to a DH public key.
   * @param {number} [options.chunkSize=1048576] - The size, in bytes,
   *   of the chunks to break the incoming data into.
   *
   * @returns {Promise<TransformStream>} Resolves to a TransformStream.
   */


  var _proto = Cipher.prototype;

  _proto.createEncryptStream = function createEncryptStream(_ref) {
    var recipients = _ref.recipients,
        keyResolver = _ref.keyResolver,
        chunkSize = _ref.chunkSize;

    try {
      var _this2 = this;

      return Promise.resolve(_this2.createEncryptTransformer({
        recipients: recipients,
        keyResolver: keyResolver,
        chunkSize: chunkSize
      })).then(function (transformer) {
        return new ponyfill.TransformStream(transformer);
      });
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * Creates a TransformStream that will decrypt one or more chunks, each one
   * that is an object with a `jwe` property that has a JWE as a value. The
   * stream will output chunks of Uint8Arrays consisting of the decrypted
   * data from each chunk.
   *
   * The only JWEs currently supported use an `alg` of `ECDH-ES+A256KW` and
   * `enc` of `A256GCM` or `XC20P`. These parameters refer to data that has been
   * encrypted using a 256-bit AES-GCM or XChaCha20Poly1305 content encryption
   * key (CEK) that has been wrapped using a 256-bit AES-KW key encryption key
   * (KEK) generated via a shared secret between an ephemeral ECDH key and a
   * static ECDH key (ECDH-ES).
   *
   * @param {object} options - Options for createDecryptStream.
   * @param {object} options.keyAgreementKey - A key agreement key API with
   *   `id` and deriveSecret`.
   *
   * @returns {Promise<TransformStream>} Resolves to the TransformStream.
   */
  ;

  _proto.createDecryptStream = function createDecryptStream(_ref2) {
    var keyAgreementKey = _ref2.keyAgreementKey;

    try {
      var _this4 = this;

      return Promise.resolve(_this4.createDecryptTransformer({
        keyAgreementKey: keyAgreementKey
      })).then(function (transformer) {
        return new ponyfill.TransformStream(transformer);
      });
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * Encrypts some data for one or more recipients and outputs a JWE. The
   * data to encrypt can be given as a Uint8Array or a string.
   *
   * A list of recipients must be given in the `recipients` array, identified
   * by key agreement keys. An ephemeral ECDH key will be generated and used to
   * derive shared KEKs that will wrap a randomly generated CEK. Each recipient
   * in the `recipients` array will be updated to include the generated
   * ephemeral ECDH key.
   *
   * @param {object} options - Options for encrypt.
   * @param {Uint8Array|string} [options.data] - The data to encrypt.
   * @param {Array} options.recipients - An array of recipients for the\
   *   encrypted content.
   * @param {Function} options.keyResolver - A function that returns a Promise
   *   that resolves a key ID to a DH public key.
   *
   * @returns {Promise<object>} Resolves to a JWE.
   */
  ;

  _proto.encrypt = function encrypt(_ref3) {
    var data = _ref3.data,
        recipients = _ref3.recipients,
        keyResolver = _ref3.keyResolver;

    try {
      var _this6 = this;

      if (!(data instanceof Uint8Array) && typeof data !== 'string') {
        throw new TypeError('"data" must be a Uint8Array or a string.');
      }

      if (data) {
        data = stringToUint8Array(data);
      }

      return Promise.resolve(_this6.createEncryptTransformer({
        recipients: recipients,
        keyResolver: keyResolver
      })).then(function (transformer) {
        return transformer.encrypt(data);
      });
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * Encrypts an object. The object will be serialized to JSON and passed
   * to `encrypt`. See `encrypt` for other parameters.
   *
   * @param {object} obj - The object to encrypt.
   *
   * @returns {Promise<object>} Resolves to a JWE.
   */
  ;

  _proto.encryptObject = function encryptObject(_ref4) {
    var obj = _ref4.obj,
        rest = _objectWithoutPropertiesLoose(_ref4, ["obj"]);

    try {
      var _this8 = this;

      if (typeof obj !== 'object') {
        throw new TypeError('"obj" must be an object.');
      }

      return Promise.resolve(_this8.encrypt(_extends({
        data: JSON.stringify(obj)
      }, rest)));
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * Decrypts a single JWE.
   *
   * The only JWEs currently supported use an `alg` of `ECDH-ES+A256KW` and
   * `enc` of `A256GCM` or `XC20P`. These parameters refer to data that has been
   * encrypted using a 256-bit AES-GCM or XChaCha20Poly1305 content encryption
   * key (CEK) that has been wrapped using a 256-bit AES-KW key encryption key
   * (KEK) generated via a shared secret between an ephemeral ECDH key and a
   * static ECDH key (ECDH-ES).
   *
   * Note: This version also supports decrypting data that was encrypted using
   * `C20P` (ChaCha20Poly1305) for backwards compatibility.
   *
   * @param {object} options - Options for decrypt.
   * @param {object} options.jwe - The JWE to decrypt.
   * @param {object} options.keyAgreementKey - A key agreement key API with
   *   `id` and `deriveSecret`.
   *
   * @returns {Promise<Uint8Array>} - Resolves to the decrypted data
   *   or `null` if the decryption failed.
   */
  ;

  _proto.decrypt = function decrypt(_ref5) {
    var jwe = _ref5.jwe,
        keyAgreementKey = _ref5.keyAgreementKey;

    try {
      var _this10 = this;

      return Promise.resolve(_this10.createDecryptTransformer({
        keyAgreementKey: keyAgreementKey
      })).then(function (transformer) {
        return transformer.decrypt(jwe);
      });
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * Decrypts a JWE that must contain an encrypted object. This method will
   * call `decrypt` and then `JSON.parse` the resulting decrypted UTF-8 data.
   *
   * @param {object} options - Options.
   * @param {object} options.jwe - The JWE to decrypt.
   * @param {object} options.keyAgreementKey - A key agreement key API with
   *   `id` and `deriveSecret`.
   *
   * @returns {Promise<object>} - Resolves to the decrypted object or `null`
   *   if the decryption failed.
   */
  ;

  _proto.decryptObject = function decryptObject(_ref6) {
    var jwe = _ref6.jwe,
        keyAgreementKey = _ref6.keyAgreementKey;

    try {
      var _this12 = this;

      return Promise.resolve(_this12.decrypt({
        jwe: jwe,
        keyAgreementKey: keyAgreementKey
      })).then(function (data) {
        return data ? JSON.parse(Buffer.from(data).toString()) : null;
      });
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * Creates an EncryptTransformer that can be used to encrypt one or more
   * chunks of data.
   *
   * A list of recipients must be given in the `recipients` array, identified
   * by key agreement keys. An ephemeral ECDH key will be generated and used to
   * derive shared KEKs that will wrap a randomly generated CEK. Each recipient
   * in the `recipients` array will be updated to include the generated
   * ephemeral ECDH key.
   *
   * @param {object} options - Options for the transformer.
   * @param {Array} options.recipients - An array of recipients for the
   *   encrypted content.
   * @param {Function} options.keyResolver - A function that returns
   *   a Promise that resolves a key ID to a DH public key.
   * @param {number} [options.chunkSize=1048576] - The size, in bytes, of the
   *   chunks to break the incoming data into (only applies if returning a
   *   stream).
   *
   * @returns {Promise<EncryptTransformer>} - Resolves to an EncryptTransformer.
   */
  ;

  _proto.createEncryptTransformer = function createEncryptTransformer(_ref7) {
    var recipients = _ref7.recipients,
        keyResolver = _ref7.keyResolver,
        chunkSize = _ref7.chunkSize;

    try {
      var _this14 = this;

      if (!(Array.isArray(recipients) && recipients.length > 0)) {
        throw new TypeError('"recipients" must be a non-empty array.');
      } // ensure all recipients use the supported key agreement algorithm


      var alg = _this14.KeyPairClass.JWE_ALG;

      if (!recipients.every(function (e) {
        return e.header && e.header.alg === alg;
      })) {
        throw new Error("All recipients must use the algorithm \"" + alg + "\".");
      }

      var cipher = _this14.cipher; // generate a CEK for encrypting the content

      return Promise.resolve(cipher.generateKey()).then(function (cek) {
        // fetch all public DH keys
        return Promise.resolve(Promise.all(recipients.map(function (e) {
          return keyResolver({
            id: e.header.kid
          });
        }))).then(function (publicKeys) {
          var epkArgs = undefined;

          if (publicKeys[0].type === 'JsonWebKey2020') {
            // agility ftw...
            // TODO: ... tests with different keys...
            epkArgs = {
              kty: 'EC',
              crvOrSize: publicKeys[0].publicKeyJwk.crv
            };
          } // derive ephemeral ECDH key pair to use with all recipients


          return Promise.resolve(_this14.KeyPairClass.generateEphemeralKeyPair(epkArgs)).then(function (ephemeralKeyPair) {
            // derive KEKs for each recipient
            return Promise.resolve(Promise.all(publicKeys.map(function (staticPublicKey) {
              return _this14.KeyPairClass.kekFromStaticPeer({
                ephemeralKeyPair: ephemeralKeyPair,
                staticPublicKey: staticPublicKey
              });
            }))).then(function (derivedResults) {
              // update all recipients with ephemeral ECDH key and wrapped CEK
              return Promise.resolve(Promise.all(recipients.map(function (recipient, i) {
                try {
                  var _derivedResults$i = derivedResults[i],
                      kek = _derivedResults$i.kek,
                      epk = _derivedResults$i.epk,
                      apu = _derivedResults$i.apu,
                      apv = _derivedResults$i.apv;
                  recipients[i] = recipient = {
                    header: _extends({}, recipient.header)
                  };
                  recipient.header.epk = epk;
                  recipient.header.apu = apu;
                  recipient.header.apv = apv;
                  return Promise.resolve(kek.wrapKey({
                    unwrappedKey: cek
                  })).then(function (_kek$wrapKey) {
                    recipient.encrypted_key = _kek$wrapKey;
                  });
                } catch (e) {
                  return Promise.reject(e);
                }
              }))).then(function () {
                // create shared protected header as associated authenticated data (aad)
                // ASCII(BASE64URL(UTF8(JWE Protected Header)))
                var enc = cipher.JWE_ENC;
                var jweProtectedHeader = JSON.stringify({
                  enc: enc
                });
                var encodedProtectedHeader = base64url.encode(Buffer.from(stringToUint8Array(jweProtectedHeader))); // UTF8-encoding a base64url-encoded string is the same as ASCII

                var additionalData = stringToUint8Array(encodedProtectedHeader);
                return new EncryptTransformer({
                  recipients: recipients,
                  encodedProtectedHeader: encodedProtectedHeader,
                  cipher: cipher,
                  additionalData: additionalData,
                  cek: cek,
                  chunkSize: chunkSize
                });
              });
            });
          });
        });
      });
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * Creates a DecryptTransformer.
   *
   * @param {object} keyAgreementKey - A key agreement key API with `id` and
   *   `deriveSecret`.
   *
   * @returns {Promise<DecryptTransformer>} - Resolves to a DecryptTransformer.
   */
  ;

  _proto.createDecryptTransformer = function createDecryptTransformer(_ref8) {
    var keyAgreementKey = _ref8.keyAgreementKey;

    try {
      var _this16 = this;

      return Promise.resolve(new DecryptTransformer({
        KeyPairClass: _this16.KeyPairClass,
        keyAgreementKey: keyAgreementKey
      }));
    } catch (e) {
      return Promise.reject(e);
    }
  };

  return Cipher;
}();

var getEpkGenerator = function getEpkGenerator(KeyPair, opts) {
  var generateEphemeralKeyPair = function generateEphemeralKeyPair() {
    try {
      return Promise.resolve(KeyPair.generate(opts)).then(function (k0) {
        return Promise.resolve(k0.toJsonWebKeyPair(true)).then(function (keypair) {
          return {
            keypair: keypair,
            epk: keypair.publicKeyJwk
          };
        });
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  return generateEphemeralKeyPair;
};

exports.Cipher = Cipher;
exports.KeyEncryptionKey = KeyEncryptionKey;
exports.deriveKey = deriveKey;
exports.getEpkGenerator = getEpkGenerator;
//# sourceMappingURL=did-key-cipher.cjs.development.js.map
