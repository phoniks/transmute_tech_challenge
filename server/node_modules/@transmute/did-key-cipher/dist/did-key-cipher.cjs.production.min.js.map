{"version":3,"file":"did-key-cipher.cjs.production.min.js","sources":["../src/Cipher/crypto.ts","../src/Cipher/algorithms/ecdhkdf.ts","../src/Cipher/algorithms/classes/KeyEncryptionKey.ts","../src/Cipher/util.ts","../src/Cipher/algorithms/xc20p.ts","../src/Cipher/DecryptTransformer.ts","../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../src/Cipher/EncryptTransformer.ts","../src/Cipher/Cipher.ts","../src/Cipher/getEpkGenerator.ts"],"sourcesContent":["import { Crypto } from '@peculiar/webcrypto';\n\nfunction isNodejs() {\n  return (\n    typeof process === 'object' &&\n    typeof process.versions === 'object' &&\n    typeof process.versions.node !== 'undefined'\n  );\n}\n\nlet crypto: Crypto;\n\nif (isNodejs()) {\n  crypto = new Crypto();\n} else {\n  crypto = window.crypto;\n}\n\nexport default crypto;\n","/*!\n * Copyright (c) 2019-2020 Digital Bazaar, Inc. All rights reserved.\n */\nimport crypto from '../crypto';\n\n// only supported algorithm\nconst KEY_ALGORITHM = 'ECDH-ES+A256KW';\n\n// create static ALGORITHM_ID\nconst ALGORITHM_CONTENT = KEY_ALGORITHM; //new TextEncoder().encode();\nconst ALGORITHM_ID = new Uint8Array(4 + ALGORITHM_CONTENT.length);\n// write length of content as 32-bit big endian integer, then write content\nconst dv = new DataView(\n  ALGORITHM_ID.buffer,\n  ALGORITHM_ID.byteOffset,\n  ALGORITHM_ID.byteLength\n);\ndv.setUint32(0, ALGORITHM_CONTENT.length);\nALGORITHM_ID.set(Buffer.from(ALGORITHM_CONTENT), 4);\n\n// RFC 7518 Section 4.6.2 specifies using SHA-256 for ECDH-ES KDF\n// https://tools.ietf.org/html/rfc7518#section-4.6.2\nconst HASH_ALGORITHM = { name: 'SHA-256' };\n\n// derived keys are always 256-bits\nconst KEY_LENGTH = 256;\n\n/**\n * Derives a 256-bit AES-KW key encryption key from a shared secret that\n * was derived from an ephemeral and static pair\n * of Elliptic Curve Diffie-Hellman keys.\n *\n * The KDF used is described in RFC 7518. This KDF is referenced by RFC 8037,\n * which defines how to perform Curve25519 (X25519) ECDH key agreement.\n *\n * @param {object} options - The options to use.\n * @param {Uint8Array} options.secret - The shared secret (i.e., `Z`) to use.\n * @param {Uint8Array} options.producerInfo - An array of application-specific\n *   bytes describing the consumer (aka the \"encrypter\" or \"sender\").\n * @param {Uint8Array} options.consumerInfo - An array of application-specific\n *   bytes describing the producer (aka the \"decrypter\" or\n *   \"receiver\"/\"recipient\").\n *\n * @returns {Promise<Uint8Array>} - Resolves to the generated key.\n */\nexport async function deriveKey({ secret, producerInfo, consumerInfo }: any) {\n  if (!(secret instanceof Uint8Array && secret.length > 0)) {\n    throw new TypeError('\"secret\" must be a non-empty Uint8Array.');\n  }\n  if (!(producerInfo instanceof Uint8Array && producerInfo.length > 0)) {\n    throw new TypeError('\"producerInfo\" must be a non-empty Uint8Array.');\n  }\n  if (!(consumerInfo instanceof Uint8Array && consumerInfo.length > 0)) {\n    throw new TypeError('\"consumerInfo\" must be a non-empty Uint8Array.');\n  }\n\n  // the output of Concat KDF is hash(roundNumber || Z || OtherInfo)\n  // where roundNumber is always 1 because the hash length is presumed to\n  // ...match the key length, encoded as a big endian 32-bit integer\n  // where OtherInfo is:\n  // AlgorithmID || PartyUInfo || PartyVInfo || SuppPubInfo\n  // where SuppPubInfo is the key length in bits, big endian encoded as a\n  // 32-bit number, i.e., 256 === [0, 0, 1, 0]\n  const input = new Uint8Array(\n    4 + // round number\n    secret.length + // `Z`\n    ALGORITHM_ID.length + // AlgorithmID\n    4 +\n    producerInfo.length + // PartyUInfo\n    4 +\n    consumerInfo.length + // PartyVInfo\n      4\n  ); // SuppPubInfo (key data length in bits)\n  let offset = 0;\n  const dv = new DataView(input.buffer, input.byteOffset, input.byteLength);\n  dv.setUint32(offset, 1);\n  input.set(secret, (offset += 4));\n  input.set(ALGORITHM_ID, (offset += secret.length));\n  dv.setUint32((offset += ALGORITHM_ID.length), producerInfo.length);\n  input.set(producerInfo, (offset += 4));\n  dv.setUint32((offset += producerInfo.length), consumerInfo.length);\n  input.set(consumerInfo, (offset += 4));\n  dv.setUint32((offset += consumerInfo.length), KEY_LENGTH);\n\n  // hash input and return result as derived key\n  return new Uint8Array(await crypto.subtle.digest(HASH_ALGORITHM, input));\n}\n","import { default as bs64 } from 'base64url';\nimport { AESKW } from '@stablelib/aes-kw';\n\nexport interface CreateKekOptions {\n  keyData: Uint8Array;\n}\n\nexport interface WrapKeyOptions {\n  unwrappedKey: Uint8Array;\n}\n\nexport interface UnwrapKeyOptions {\n  wrappedKey: string; //base64url\n}\n\nexport class KeyEncryptionKey {\n  public aeskw: AESKW;\n  public algorithm: any;\n\n  static createKek = async ({ keyData }: CreateKekOptions) => {\n    return new KeyEncryptionKey(keyData);\n  };\n\n  constructor(key: Uint8Array) {\n    if (key.length !== 32) {\n      throw new Error('key must be 32 bytes');\n    }\n    this.aeskw = new AESKW(key);\n    this.algorithm = { name: 'A256KW' };\n  }\n\n  /**\n   * Wraps a cryptographic key.\n   *\n   * @param {object} options - The options to use.\n   * @param {Uint8Array} options.unwrappedKey - The key material as a\n   *   `Uint8Array`.\n   *\n   * @returns {string} - The base64url-encoded wrapped key bytes.\n   */\n  wrapKey({ unwrappedKey }: WrapKeyOptions): string {\n    const wrappedKey = this.aeskw.wrapKey(unwrappedKey);\n    return bs64.encode(Buffer.from(wrappedKey));\n  }\n\n  /**\n   * Unwraps a cryptographic key.\n   *\n   * @param {object} options - The options to use.\n   * @param {string} options.wrappedKey - The wrapped key material as a\n   *   base64url-encoded string.\n   *\n   * @returns {Uint8Array} - Resolves to the key bytes or null if\n   *   the unwrapping fails because the key does not match.\n   */\n  unwrapKey({ wrappedKey }: UnwrapKeyOptions): Uint8Array | null {\n    const _wrappedKey = bs64.toBuffer(wrappedKey);\n    try {\n      return this.aeskw.unwrapKey(_wrappedKey);\n    } catch (e) {\n      // decryption failed\n      console.error(e);\n      return null;\n    }\n  }\n}\n","export { ReadableStream, TransformStream } from 'web-streams-polyfill/ponyfill';\n\nexport function stringToUint8Array(data: any) {\n  if (typeof data === 'string') {\n    // convert data to Uint8Array\n    return new Uint8Array(Buffer.from(data));\n  }\n  if (!(data instanceof Uint8Array)) {\n    throw new TypeError('\"data\" be a string or Uint8Array.');\n  }\n  return data;\n}\n","/*!\n * Copyright (c) 2019-2020 Digital Bazaar, Inc. All rights reserved.\n */\nimport crypto from '../crypto';\nimport { XChaCha20Poly1305, KEY_LENGTH } from '@stablelib/xchacha20poly1305';\n\nexport const JWE_ENC = 'XC20P';\n\n/**\n * Generates a content encryption key (CEK). The 256-bit key is intended to be\n * used as a XChaCha20Poly1305 (draft-irtf-cfrg-xchacha-01) key.\n *\n * @returns {Promise<Uint8Array>} - Resolves to the generated key.\n */\nexport async function generateKey() {\n  // generate content encryption key\n  return crypto.getRandomValues(new Uint8Array(KEY_LENGTH));\n}\n\n/**\n * Encrypts some data. The data will be encrypted using the given\n * 256-bit XChaCha20Poly1305 (draft-irtf-cfrg-xchacha-01) content encryption\n * key (CEK).\n *\n * @param {object} options - The options to use.\n * @param {Uint8Array} options.data - The data to encrypt.\n * @param {Uint8Array} [options.additionalData] - Optional additional\n *   authentication data.\n * @param {Uint8Array} options.cek - The content encryption key to use.\n *\n * @returns {Promise<object>} - Resolves to `{ciphertext, iv, tag}`.\n */\nexport async function encrypt({ data, additionalData, cek }: any) {\n  if (!(data instanceof Uint8Array)) {\n    throw new TypeError('\"data\" must be a Uint8Array.');\n  }\n  if (!(cek instanceof Uint8Array)) {\n    throw new TypeError('\"cek\" must be a Uint8Array.');\n  }\n\n  const cipher = new XChaCha20Poly1305(cek);\n  // Note: Uses a random value here as a counter is not viable -- multiple\n  // recipients may be trying to update at the same time and use the same\n  // counter breaking security; using XChaCha20Poly1305 once available will\n  // further reduce chances of a collision as it has a 192-bit IV\n  const iv = crypto.getRandomValues(new Uint8Array(cipher.nonceLength));\n\n  // encrypt data\n  const encrypted = cipher.seal(iv, data, additionalData);\n\n  // split ciphertext and tag\n  const ciphertext = encrypted.subarray(0, encrypted.length - cipher.tagLength);\n  const tag = encrypted.subarray(encrypted.length - cipher.tagLength);\n\n  return {\n    ciphertext,\n    iv,\n    tag,\n  };\n}\n\n/**\n * Decrypts some encrypted data. The data must have been encrypted using\n * the given XChaCha20Poly1305 (draft-irtf-cfrg-xchacha-01) content encryption\n * key (CEK).\n *\n * @param {object} options - The options to use.\n * @param {Uint8Array} options.ciphertext - The data to decrypt.\n * @param {Uint8Array} options.iv - The initialization vector (aka nonce).\n * @param {Uint8Array} options.tag - The authentication tag.\n * @param {Uint8Array} [options.additionalData] - Optional additional\n *   authentication data.\n * @param {Uint8Array} options.cek - The content encryption key to use.\n *\n * @returns {Promise<Uint8Array>} The decrypted data.\n */\nexport async function decrypt({\n  ciphertext,\n  iv,\n  tag,\n  additionalData,\n  cek,\n}: any) {\n  if (!(iv instanceof Uint8Array)) {\n    throw new Error('Invalid or missing \"iv\".');\n  }\n  if (!(ciphertext instanceof Uint8Array)) {\n    throw new Error('Invalid or missing \"ciphertext\".');\n  }\n  if (!(tag instanceof Uint8Array)) {\n    throw new Error('Invalid or missing \"tag\".');\n  }\n  if (!(cek instanceof Uint8Array)) {\n    throw new TypeError('\"cek\" must be a Uint8Array.');\n  }\n\n  // decrypt `ciphertext`\n  const cipher = new XChaCha20Poly1305(cek);\n  const encrypted = new Uint8Array(ciphertext.length + cipher.tagLength);\n  encrypted.set(ciphertext);\n  encrypted.set(tag, ciphertext.length);\n  return cipher.open(iv, encrypted, additionalData);\n}\n","/*!\n * Copyright (c) 2019-2020 Digital Bazaar, Inc. All rights reserved.\n */\nimport base64url from 'base64url';\n\nimport * as recAlgorithm from './algorithms/recommended';\nimport { stringToUint8Array } from './util';\n\nconst CIPHER_ALGORITHMS: any = {\n  [recAlgorithm.cipher.JWE_ENC]: recAlgorithm.cipher,\n};\n\nexport class DecryptTransformer {\n  public keyAgreementKey: any;\n  public KeyPairClass: any;\n\n  constructor({ keyAgreementKey, KeyPairClass }: any = {}) {\n    if (!keyAgreementKey) {\n      throw new TypeError('\"keyAgreementKey\" is a required parameter.');\n    }\n    this.KeyPairClass = KeyPairClass;\n    this.keyAgreementKey = keyAgreementKey;\n  }\n\n  async transform(chunk: any, controller: any) {\n    // assumes `chunk` is an object with a JWE under the `jwe` property\n    if (!(chunk && typeof chunk === 'object')) {\n      throw new TypeError('\"chunk\" must be an object.');\n    }\n    const { jwe } = chunk;\n\n    const data = await this.decrypt(jwe);\n    if (data === null) {\n      const error = new Error('Invalid decryption key.');\n      error.name = 'DataError';\n      throw error;\n    }\n\n    controller.enqueue(data);\n  }\n\n  async decrypt(jwe: any) {\n    // validate JWE\n    if (!(jwe && typeof jwe === 'object')) {\n      throw new TypeError('\"jwe\" must be an object.');\n    }\n    if (typeof jwe.protected !== 'string') {\n      throw new TypeError('\"jwe.protected\" is missing or not a string.');\n    }\n    if (typeof jwe.iv !== 'string') {\n      throw new Error('Invalid or missing \"iv\".');\n    }\n    if (typeof jwe.ciphertext !== 'string') {\n      throw new Error('Invalid or missing \"ciphertext\".');\n    }\n    if (typeof jwe.tag !== 'string') {\n      throw new Error('Invalid or missing \"tag\".');\n    }\n\n    // validate encryption header\n    let header;\n    let additionalData;\n    try {\n      // ASCII(BASE64URL(UTF8(JWE Protected Header)))\n      additionalData = stringToUint8Array(jwe.protected);\n      header = JSON.parse(base64url.toBuffer(jwe.protected).toString());\n    } catch (e) {\n      throw new Error('Invalid JWE \"protected\" header.');\n    }\n    if (!(header.enc && typeof header.enc === 'string')) {\n      throw new Error('Invalid JWE \"enc\" header.');\n    }\n    const cipher = CIPHER_ALGORITHMS[header.enc];\n    if (!cipher) {\n      throw new Error('Unsupported encryption algorithm \"${header.enc}\".');\n    }\n    if (!Array.isArray(jwe.recipients)) {\n      throw new TypeError('\"jwe.recipients\" must be an array.');\n    }\n\n    // find `keyAgreementKey` matching recipient\n    const { keyAgreementKey } = this;\n\n    const _findRecipient = (recipients: any, key: any) => {\n      return recipients.find(\n        (rec: any) =>\n          (rec.header && rec.header.kid === key.id) ||\n          rec.header.kid.split('#').pop() === key.id.split('#').pop()\n      );\n    };\n\n    const recipient = _findRecipient(jwe.recipients, keyAgreementKey);\n\n    if (!recipient) {\n      console.log(jwe.recipients, keyAgreementKey);\n      throw new Error('No matching recipient found for key agreement key.');\n    }\n    // get wrapped CEK\n    const { encrypted_key: wrappedKey } = recipient;\n    if (typeof wrappedKey !== 'string') {\n      throw new Error('Invalid or missing \"encrypted_key\".');\n    }\n\n    // TODO: consider a cache of encrypted_key => CEKs to reduce unwrapping\n    // calls which may even need to hit the network (e.g., Web KMS)\n\n    // derive KEK and unwrap CEK\n    const { epk } = recipient.header;\n\n    const { kek } = await this.KeyPairClass.kekFromEphemeralPeer({\n      keyAgreementKey,\n      epk,\n    });\n    const cek = await kek.unwrapKey({ wrappedKey });\n    if (!cek) {\n      // failed to unwrap key\n      return null;\n    }\n\n    // decrypt content\n    const { ciphertext, iv, tag } = jwe;\n    return cipher.decrypt({\n      ciphertext: base64url.toBuffer(ciphertext),\n      iv: base64url.toBuffer(iv),\n      tag: base64url.toBuffer(tag),\n      additionalData,\n      cek,\n    });\n  }\n}\n","// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","/*!\n * Copyright (c) 2019-2020 Digital Bazaar, Inc. All rights reserved.\n */\nimport base64url from 'base64url';\n\n// 1 MiB = 1048576\nconst DEFAULT_CHUNK_SIZE = 1048576;\n\nexport class EncryptTransformer {\n  public recipients: any;\n  public encodedProtectedHeader: any;\n  public cipher: any;\n  public additionalData: any;\n  public cek: any;\n  public chunkSize: any;\n  public offset: any;\n  public totalOffset: any;\n  public index: any;\n  public buffer: any;\n\n  constructor({\n    recipients,\n    encodedProtectedHeader,\n    cipher,\n    additionalData,\n    cek,\n    chunkSize = DEFAULT_CHUNK_SIZE,\n  }: any = {}) {\n    this.recipients = recipients;\n    this.encodedProtectedHeader = encodedProtectedHeader;\n    this.cipher = cipher;\n    this.additionalData = additionalData;\n    this.cek = cek;\n    this.chunkSize = chunkSize;\n    this.offset = 0;\n    this.totalOffset = 0;\n    this.index = 0;\n  }\n\n  start() {\n    this.buffer = new Uint8Array(this.chunkSize);\n  }\n\n  async transform(chunk: any, controller: any) {\n    const { buffer } = this;\n\n    // assumes `chunk` is a Uint8Array...\n    if (!(chunk instanceof Uint8Array)) {\n      throw new TypeError('\"chunk\" must be an object.');\n    }\n    while (chunk) {\n      const space = buffer.length - this.offset;\n      if (chunk.length <= space) {\n        buffer.set(chunk, this.offset);\n        this.offset += chunk.byteLength;\n        this.totalOffset += chunk.byteLength;\n        chunk = null;\n      } else {\n        const partial = new Uint8Array(chunk.buffer, chunk.byteOffset, space);\n        chunk = new Uint8Array(\n          chunk.buffer,\n          chunk.byteOffset + space,\n          chunk.length - space\n        );\n        buffer.set(partial, this.offset);\n        this.offset += space;\n        this.totalOffset += space;\n      }\n\n      // flush if buffer is full and more data remains\n      if (chunk) {\n        await this.flush(controller);\n      }\n    }\n  }\n\n  async flush(controller: any) {\n    if (this.offset === 0) {\n      // nothing to flush\n      return;\n    }\n\n    // encrypt data\n    const { buffer } = this;\n    const data = new Uint8Array(buffer.buffer, buffer.byteOffset, this.offset);\n    const jwe = await this.encrypt(data);\n\n    // clear buffer\n    this.offset = 0;\n\n    controller.enqueue({\n      index: this.index++,\n      offset: this.totalOffset,\n      jwe,\n    });\n  }\n\n  async encrypt(data: any) {\n    const { cipher, additionalData, cek } = this;\n    const { ciphertext, iv, tag } = await cipher.encrypt({\n      data,\n      additionalData,\n      cek,\n    });\n\n    // represent encrypted data as JWE\n    const jwe = {\n      protected: this.encodedProtectedHeader,\n      recipients: this.recipients,\n      iv: base64url.encode(iv),\n      ciphertext: base64url.encode(ciphertext),\n      tag: base64url.encode(tag),\n    };\n    return jwe;\n  }\n}\n","/*!\n * Copyright (c) 2019-2020 Digital Bazaar, Inc. All rights reserved.\n */\nimport base64url from 'base64url';\nimport { TransformStream, stringToUint8Array } from './util';\nimport { DecryptTransformer } from './DecryptTransformer';\nimport { EncryptTransformer } from './EncryptTransformer';\nimport * as recAlgorithm from './algorithms/recommended';\n\nexport class Cipher {\n  public version: string;\n  public cipher: any;\n\n  /**\n   * Creates a new Cipher instance that can be used to encrypt or decrypt\n   * data. A version must be supplied for encrypting data; the version\n   * indicates whether a FIPS-compliant algorithm or the latest recommended\n   * algorithm will be used.\n   *\n   * @param {string} [version='recommended'] - `fips` to use a FIPS-compliant\n   *   algorithm, `recommended` to use the latest recommended algorithm when\n   *   encrypting.\n   *\n   * @returns {Cipher} A Cipher used to encrypt and decrypt data.\n   */\n  constructor(public KeyPairClass: any) {\n    this.version = 'recommended';\n    // only recommended... agility should be explicit.\n    this.cipher = recAlgorithm.cipher;\n  }\n\n  /**\n   * Creates a TransformStream that will encrypt some data for one or more\n   * recipients and output a stream of chunks, each containing an object\n   * with the property `jwe` with a JWE value.\n   *\n   * A list of recipients must be given in the `recipients` array, identified\n   * by key agreement keys. An ephemeral ECDH key will be generated and used to\n   * derive shared KEKs that will wrap a randomly generated CEK. Each recipient\n   * in the `recipients` array will be updated to include the generated\n   * ephemeral ECDH key.\n   *\n   * @param {object} options - The options for the stream.\n   * @param {Array} options.recipients - An array of recipients for the\n   *   encrypted content.\n   * @param {Function} options.keyResolver - A function that returns a Promise\n   *   that resolves a key ID to a DH public key.\n   * @param {number} [options.chunkSize=1048576] - The size, in bytes,\n   *   of the chunks to break the incoming data into.\n   *\n   * @returns {Promise<TransformStream>} Resolves to a TransformStream.\n   */\n  async createEncryptStream({ recipients, keyResolver, chunkSize }: any) {\n    const transformer = await this.createEncryptTransformer({\n      recipients,\n      keyResolver,\n      chunkSize,\n    });\n    return new TransformStream(transformer);\n  }\n\n  /**\n   * Creates a TransformStream that will decrypt one or more chunks, each one\n   * that is an object with a `jwe` property that has a JWE as a value. The\n   * stream will output chunks of Uint8Arrays consisting of the decrypted\n   * data from each chunk.\n   *\n   * The only JWEs currently supported use an `alg` of `ECDH-ES+A256KW` and\n   * `enc` of `A256GCM` or `XC20P`. These parameters refer to data that has been\n   * encrypted using a 256-bit AES-GCM or XChaCha20Poly1305 content encryption\n   * key (CEK) that has been wrapped using a 256-bit AES-KW key encryption key\n   * (KEK) generated via a shared secret between an ephemeral ECDH key and a\n   * static ECDH key (ECDH-ES).\n   *\n   * @param {object} options - Options for createDecryptStream.\n   * @param {object} options.keyAgreementKey - A key agreement key API with\n   *   `id` and deriveSecret`.\n   *\n   * @returns {Promise<TransformStream>} Resolves to the TransformStream.\n   */\n  async createDecryptStream({ keyAgreementKey }: any) {\n    const transformer = await this.createDecryptTransformer({\n      keyAgreementKey,\n    });\n    return new TransformStream(transformer);\n  }\n\n  /**\n   * Encrypts some data for one or more recipients and outputs a JWE. The\n   * data to encrypt can be given as a Uint8Array or a string.\n   *\n   * A list of recipients must be given in the `recipients` array, identified\n   * by key agreement keys. An ephemeral ECDH key will be generated and used to\n   * derive shared KEKs that will wrap a randomly generated CEK. Each recipient\n   * in the `recipients` array will be updated to include the generated\n   * ephemeral ECDH key.\n   *\n   * @param {object} options - Options for encrypt.\n   * @param {Uint8Array|string} [options.data] - The data to encrypt.\n   * @param {Array} options.recipients - An array of recipients for the\\\n   *   encrypted content.\n   * @param {Function} options.keyResolver - A function that returns a Promise\n   *   that resolves a key ID to a DH public key.\n   *\n   * @returns {Promise<object>} Resolves to a JWE.\n   */\n  async encrypt({ data, recipients, keyResolver }: any) {\n    if (!(data instanceof Uint8Array) && typeof data !== 'string') {\n      throw new TypeError('\"data\" must be a Uint8Array or a string.');\n    }\n    if (data) {\n      data = stringToUint8Array(data);\n    }\n    const transformer = await this.createEncryptTransformer({\n      recipients,\n      keyResolver,\n    });\n    return transformer.encrypt(data);\n  }\n\n  /**\n   * Encrypts an object. The object will be serialized to JSON and passed\n   * to `encrypt`. See `encrypt` for other parameters.\n   *\n   * @param {object} obj - The object to encrypt.\n   *\n   * @returns {Promise<object>} Resolves to a JWE.\n   */\n  async encryptObject({ obj, ...rest }: any) {\n    if (typeof obj !== 'object') {\n      throw new TypeError('\"obj\" must be an object.');\n    }\n    return this.encrypt({ data: JSON.stringify(obj), ...rest });\n  }\n\n  /**\n   * Decrypts a single JWE.\n   *\n   * The only JWEs currently supported use an `alg` of `ECDH-ES+A256KW` and\n   * `enc` of `A256GCM` or `XC20P`. These parameters refer to data that has been\n   * encrypted using a 256-bit AES-GCM or XChaCha20Poly1305 content encryption\n   * key (CEK) that has been wrapped using a 256-bit AES-KW key encryption key\n   * (KEK) generated via a shared secret between an ephemeral ECDH key and a\n   * static ECDH key (ECDH-ES).\n   *\n   * Note: This version also supports decrypting data that was encrypted using\n   * `C20P` (ChaCha20Poly1305) for backwards compatibility.\n   *\n   * @param {object} options - Options for decrypt.\n   * @param {object} options.jwe - The JWE to decrypt.\n   * @param {object} options.keyAgreementKey - A key agreement key API with\n   *   `id` and `deriveSecret`.\n   *\n   * @returns {Promise<Uint8Array>} - Resolves to the decrypted data\n   *   or `null` if the decryption failed.\n   */\n  async decrypt({ jwe, keyAgreementKey }: any) {\n    const transformer = await this.createDecryptTransformer({\n      keyAgreementKey,\n    });\n    return transformer.decrypt(jwe);\n  }\n\n  /**\n   * Decrypts a JWE that must contain an encrypted object. This method will\n   * call `decrypt` and then `JSON.parse` the resulting decrypted UTF-8 data.\n   *\n   * @param {object} options - Options.\n   * @param {object} options.jwe - The JWE to decrypt.\n   * @param {object} options.keyAgreementKey - A key agreement key API with\n   *   `id` and `deriveSecret`.\n   *\n   * @returns {Promise<object>} - Resolves to the decrypted object or `null`\n   *   if the decryption failed.\n   */\n  async decryptObject({ jwe, keyAgreementKey }: any) {\n    const data = await this.decrypt({ jwe, keyAgreementKey });\n    if (!data) {\n      // decryption failed\n      return null;\n    }\n\n    return JSON.parse(Buffer.from(data).toString());\n  }\n\n  /**\n   * Creates an EncryptTransformer that can be used to encrypt one or more\n   * chunks of data.\n   *\n   * A list of recipients must be given in the `recipients` array, identified\n   * by key agreement keys. An ephemeral ECDH key will be generated and used to\n   * derive shared KEKs that will wrap a randomly generated CEK. Each recipient\n   * in the `recipients` array will be updated to include the generated\n   * ephemeral ECDH key.\n   *\n   * @param {object} options - Options for the transformer.\n   * @param {Array} options.recipients - An array of recipients for the\n   *   encrypted content.\n   * @param {Function} options.keyResolver - A function that returns\n   *   a Promise that resolves a key ID to a DH public key.\n   * @param {number} [options.chunkSize=1048576] - The size, in bytes, of the\n   *   chunks to break the incoming data into (only applies if returning a\n   *   stream).\n   *\n   * @returns {Promise<EncryptTransformer>} - Resolves to an EncryptTransformer.\n   */\n  async createEncryptTransformer({ recipients, keyResolver, chunkSize }: any) {\n    if (!(Array.isArray(recipients) && recipients.length > 0)) {\n      throw new TypeError('\"recipients\" must be a non-empty array.');\n    }\n    // ensure all recipients use the supported key agreement algorithm\n\n    const alg = this.KeyPairClass.JWE_ALG;\n    if (!recipients.every((e) => e.header && e.header.alg === alg)) {\n      throw new Error(`All recipients must use the algorithm \"${alg}\".`);\n    }\n    const { cipher } = this;\n\n    // generate a CEK for encrypting the content\n    const cek = await cipher.generateKey();\n\n    // fetch all public DH keys\n    const publicKeys = await Promise.all(\n      recipients.map((e) => keyResolver({ id: e.header.kid }))\n    );\n\n    let epkArgs = undefined;\n    if (publicKeys[0].type === 'JsonWebKey2020') {\n      // agility ftw...\n      // TODO: ... tests with different keys...\n      epkArgs = { kty: 'EC', crvOrSize: publicKeys[0].publicKeyJwk.crv };\n    }\n\n    // derive ephemeral ECDH key pair to use with all recipients\n    const ephemeralKeyPair = await this.KeyPairClass.generateEphemeralKeyPair(\n      epkArgs\n    );\n\n    // derive KEKs for each recipient\n    const derivedResults = await Promise.all(\n      publicKeys.map((staticPublicKey) =>\n        this.KeyPairClass.kekFromStaticPeer({\n          ephemeralKeyPair,\n          staticPublicKey,\n        })\n      )\n    );\n\n    // update all recipients with ephemeral ECDH key and wrapped CEK\n    await Promise.all(\n      recipients.map(async (recipient, i) => {\n        const { kek, epk, apu, apv } = derivedResults[i];\n        recipients[i] = recipient = { header: { ...recipient.header } };\n        recipient.header.epk = epk;\n        recipient.header.apu = apu;\n        recipient.header.apv = apv;\n        recipient.encrypted_key = await kek.wrapKey({ unwrappedKey: cek });\n      })\n    );\n\n    // create shared protected header as associated authenticated data (aad)\n    // ASCII(BASE64URL(UTF8(JWE Protected Header)))\n    const enc = cipher.JWE_ENC;\n    const jweProtectedHeader = JSON.stringify({ enc });\n    const encodedProtectedHeader = base64url.encode(\n      Buffer.from(stringToUint8Array(jweProtectedHeader))\n    );\n    // UTF8-encoding a base64url-encoded string is the same as ASCII\n    const additionalData = stringToUint8Array(encodedProtectedHeader);\n\n    return new EncryptTransformer({\n      recipients,\n      encodedProtectedHeader,\n      cipher,\n      additionalData,\n      cek,\n      chunkSize,\n    });\n  }\n\n  /**\n   * Creates a DecryptTransformer.\n   *\n   * @param {object} keyAgreementKey - A key agreement key API with `id` and\n   *   `deriveSecret`.\n   *\n   * @returns {Promise<DecryptTransformer>} - Resolves to a DecryptTransformer.\n   */\n  async createDecryptTransformer({ keyAgreementKey }: any) {\n    return new DecryptTransformer({\n      KeyPairClass: this.KeyPairClass,\n      keyAgreementKey,\n    });\n  }\n}\n","import { types } from '@transmute/did-key-common';\n\nexport const getEpkGenerator = (KeyPair: types.KeyPairClass, opts: any) => {\n  const generateEphemeralKeyPair = async (): Promise<types.EpkResult> => {\n    const k0 = await KeyPair.generate(opts);\n    const keypair = await k0.toJsonWebKeyPair(true);\n\n    return {\n      keypair,\n      epk: keypair.publicKeyJwk,\n    };\n  };\n  return generateEphemeralKeyPair;\n};\n"],"names":["process","versions","node","Crypto","window","crypto","ALGORITHM_ID","Uint8Array","length","DataView","buffer","byteOffset","byteLength","setUint32","set","Buffer","from","HASH_ALGORITHM","name","KeyEncryptionKey","key","Error","aeskw","AESKW","algorithm","wrapKey","wrappedKey","this","unwrappedKey","bs64","encode","unwrapKey","_wrappedKey","toBuffer","e","console","error","stringToUint8Array","data","TypeError","keyData","ciphertext","iv","tag","additionalData","cek","cipher","XChaCha20Poly1305","encrypted","tagLength","open","getRandomValues","nonceLength","seal","subarray","KEY_LENGTH","CIPHER_ALGORITHMS","recAlgorithm","DecryptTransformer","keyAgreementKey","KeyPairClass","transform","chunk","controller","decrypt","jwe","enqueue","header","JSON","parse","base64url","toString","enc","Array","isArray","recipients","recipient","find","rec","kid","id","split","pop","log","encrypted_key","kekFromEphemeralPeer","epk","kek","_Pact","prototype","then","onFulfilled","onRejected","result","state","s","callback","_settle","v","o","_this","value","pact","bind","observer","_isSettledPact","thenable","Symbol","iterator","asyncIterator","EncryptTransformer","encodedProtectedHeader","chunkSize","offset","totalOffset","index","start","test","update","body","stage","shouldContinue","reject","_resumeAfterTest","_resumeAfterBody","updateValue","space","_this2","partial","flush","_this4","encrypt","_this6","version","createEncryptStream","keyResolver","createEncryptTransformer","transformer","TransformStream","createDecryptStream","createDecryptTransformer","encryptObject","obj","rest","stringify","decryptObject","alg","_this14","JWE_ALG","every","generateKey","Promise","all","map","publicKeys","epkArgs","undefined","type","kty","crvOrSize","publicKeyJwk","crv","generateEphemeralKeyPair","ephemeralKeyPair","staticPublicKey","kekFromStaticPeer","derivedResults","i","apu","apv","jweProtectedHeader","JWE_ENC","secret","producerInfo","consumerInfo","input","dv","subtle","digest","KeyPair","opts","generate","k0","toJsonWebKeyPair","keypair"],"mappings":"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"}