import base64url from 'base64url';
import canonicalize from 'canonicalize';

/* class decorator */
var staticImplements = function staticImplements() {
  return function (constructor) {
    return constructor;
  };
};

var index = {
  __proto__: null,
  staticImplements: staticImplements
};

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

var createJws = function createJws(signer, payload, header) {
  try {
    var encodedHeader = base64url.encode(canonicalize(header));
    var encodedPayload = base64url.encode(canonicalize(payload));
    var toBeSigned = encodedHeader + "." + encodedPayload;
    return Promise.resolve(signer.sign(Buffer.from(toBeSigned))).then(function (signature) {
      return toBeSigned + "." + base64url.encode(Buffer.from(signature));
    });
  } catch (e) {
    return Promise.reject(e);
  }
};
var verifyJws = function verifyJws(verifier, jws) {
  try {
    var _jws$split = jws.split('.'),
        header = _jws$split[0],
        payload = _jws$split[1],
        signature = _jws$split[2];

    var toBeVerified = header + "." + payload;
    return Promise.resolve(verifier.verify(Buffer.from(toBeVerified), base64url.toBuffer(signature)));
  } catch (e) {
    return Promise.reject(e);
  }
};
var createDetachedJws = function createDetachedJws(signer, payload, header) {
  try {
    var encodedHeader = base64url.encode(canonicalize(_extends({}, header, {
      b64: false,
      crit: ['b64']
    })));
    var toBeSigned = new Uint8Array(Buffer.concat([Buffer.from(encodedHeader, 'utf-8'), Buffer.from('.', 'utf-8'), payload]));
    return Promise.resolve(signer.sign(Buffer.from(toBeSigned))).then(function (signature) {
      var encodedSignature = base64url.encode(Buffer.from(signature));
      return encodedHeader + ".." + encodedSignature;
    });
  } catch (e) {
    return Promise.reject(e);
  }
};
var verifyDetachedJws = function verifyDetachedJws(verifier, payload, signature) {
  try {
    var _signature$split = signature.split('..'),
        encodedHeader = _signature$split[0],
        encodedSignature = _signature$split[1];

    var toBeVerified = new Uint8Array(Buffer.concat([Buffer.from(encodedHeader, 'utf-8'), Buffer.from('.', 'utf-8'), payload]));
    return Promise.resolve(verifier.verify(Buffer.from(toBeVerified), base64url.toBuffer(encodedSignature)));
  } catch (e) {
    return Promise.reject(e);
  }
};

var index$1 = {
  __proto__: null,
  createJws: createJws,
  verifyJws: verifyJws,
  createDetachedJws: createDetachedJws,
  verifyDetachedJws: verifyDetachedJws
};

var getVerificationMethod = function getVerificationMethod(didKeyPairInstance, contentType) {
  if (contentType === void 0) {
    contentType = 'application/did+ld+json';
  }

  var externalKeyRepresentation;

  switch (contentType) {
    case 'application/did+json':
      {
        externalKeyRepresentation = didKeyPairInstance.toJsonWebKeyPair();
        break;
      }

    case '*/*':
    case 'application/did+ld+json':
      {
        externalKeyRepresentation = didKeyPairInstance.toKeyPair();
        break;
      }

    default:
      {
        throw new Error('This implementation of did:key does not support: ' + contentType);
      }
  }

  return externalKeyRepresentation;
};
var keyToDidDoc = function keyToDidDoc(didKeyPairInstance, contentType) {
  if (contentType === void 0) {
    contentType = 'application/did+ld+json';
  }

  try {
    var _temp3 = function _temp3() {
      // imagine if people injected ads like this....
      // verificationRelationships = {
      //   ...verificationRelationships,
      //   service: [
      //     {
      //       id: '#provider',
      //       type: 'ServiceProvider',
      //       serviceEndpoint: 'https://transmute.industries',
      //     },
      //   ],
      // };
      var didDocument = _extends({
        '@context': ['https://www.w3.org/ns/did/v1', {
          '@base': did
        }],
        id: did
      }, verificationRelationships); // Here is were I would delete a property for JSON-only
      // If I wanted to conform to the DID Core JSON Production Rules.


      return didDocument;
    };

    var did = "did:key:" + didKeyPairInstance.fingerprint();
    var externalKeyRepresentation = getVerificationMethod(didKeyPairInstance, contentType);
    var verificationRelationships = {
      verificationMethod: [externalKeyRepresentation]
    };

    if (didKeyPairInstance.verifier) {
      verificationRelationships = _extends({}, verificationRelationships, {
        authentication: [externalKeyRepresentation.id],
        assertionMethod: [externalKeyRepresentation.id],
        capabilityInvocation: [externalKeyRepresentation.id],
        capabilityDelegation: [externalKeyRepresentation.id]
      });
    }

    if (didKeyPairInstance.deriveSecret) {
      verificationRelationships = _extends({}, verificationRelationships, {
        keyAgreement: [externalKeyRepresentation.id]
      });
    }

    var _temp4 = function () {
      if (didKeyPairInstance.type === 'Ed25519VerificationKey2018') {
        return Promise.resolve(didKeyPairInstance.toX25519KeyPair(false)).then(function (kek) {
          var externalKeyRepresentation2 = getVerificationMethod(kek, contentType);
          verificationRelationships = _extends({}, verificationRelationships, {
            verificationMethod: [].concat(verificationRelationships.verificationMethod, [externalKeyRepresentation2]),
            keyAgreement: [externalKeyRepresentation2.id]
          });
        });
      }
    }();

    return Promise.resolve(_temp4 && _temp4.then ? _temp4.then(_temp3) : _temp3(_temp4));
  } catch (e) {
    return Promise.reject(e);
  }
}; // resolve ( did, did-resolution-input-metadata )
//      -> ( did-resolution-metadata, did-document, did-document-metadata )

var getResolve = function getResolve(DidKeyPairClass) {
  var resolve = function resolve(didUri, resolutionMetaData) {
    if (resolutionMetaData === void 0) {
      resolutionMetaData = {
        accept: 'application/did+ld+json'
      };
    }

    try {
      var fingerprint = didUri.split('#')[0].split('did:key:').pop();
      return Promise.resolve(DidKeyPairClass.fromFingerprint({
        fingerprint: fingerprint
      })).then(function (publicKey) {
        return Promise.resolve(keyToDidDoc(publicKey, resolutionMetaData.accept)).then(function (_keyToDidDoc) {
          return {
            didDocument: _keyToDidDoc,
            didDocumentMetaData: {
              'content-type': resolutionMetaData.accept
            },
            didResolutionMetaData: {}
          };
        });
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  return resolve;
};

var getGet = function getGet(resolve) {
  var get = function get(_temp) {
    var _ref = _temp === void 0 ? {} : _temp,
        did = _ref.did,
        url = _ref.url;

    try {
      did = did || url;

      if (!did) {
        throw new TypeError('"did" must be a string.');
      }

      return Promise.resolve(resolve(did)).then(function (result) {
        return result.didDocument;
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  return get;
};

export { index$1 as Jws, getGet, getResolve, getVerificationMethod, keyToDidDoc, index as types };
//# sourceMappingURL=did-key-common.esm.js.map
