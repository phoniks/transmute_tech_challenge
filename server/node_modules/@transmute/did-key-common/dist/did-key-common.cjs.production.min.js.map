{"version":3,"file":"did-key-common.cjs.production.min.js","sources":["../src/Jws/index.ts","../src/getResolver.ts","../src/getGet.ts","../src/types/index.ts"],"sourcesContent":["import base64url from 'base64url';\nimport canonicalize from 'canonicalize';\n\nexport const createJws = async (signer: any, payload: any, header: object) => {\n  const encodedHeader = base64url.encode(canonicalize(header));\n  const encodedPayload = base64url.encode(canonicalize(payload));\n  const toBeSigned = `${encodedHeader}.${encodedPayload}`;\n  const signature = await signer.sign(Buffer.from(toBeSigned));\n  return `${toBeSigned}.${base64url.encode(Buffer.from(signature))}`;\n};\n\nexport const verifyJws = async (verifier: any, jws: string) => {\n  const [header, payload, signature] = jws.split('.');\n  const toBeVerified = `${header}.${payload}`;\n  const verified = await verifier.verify(\n    Buffer.from(toBeVerified),\n    base64url.toBuffer(signature)\n  );\n\n  return verified;\n};\n\nexport const createDetachedJws = async (\n  signer: any,\n  payload: Buffer,\n  header: object\n) => {\n  const encodedHeader = base64url.encode(\n    canonicalize({ ...header, b64: false, crit: ['b64'] })\n  );\n\n  const toBeSigned = new Uint8Array(\n    Buffer.concat([\n      Buffer.from(encodedHeader, 'utf-8'),\n      Buffer.from('.', 'utf-8'),\n      payload,\n    ])\n  );\n  const signature = await signer.sign(Buffer.from(toBeSigned));\n  const encodedSignature = base64url.encode(Buffer.from(signature));\n  return `${encodedHeader}..${encodedSignature}`;\n};\n\nexport const verifyDetachedJws = async (\n  verifier: any,\n  payload: Buffer,\n  signature: string\n) => {\n  const [encodedHeader, encodedSignature] = signature.split('..');\n\n  const toBeVerified = new Uint8Array(\n    Buffer.concat([\n      Buffer.from(encodedHeader, 'utf-8'),\n      Buffer.from('.', 'utf-8'),\n      payload,\n    ])\n  );\n\n  const verified = await verifier.verify(\n    Buffer.from(toBeVerified),\n    base64url.toBuffer(encodedSignature)\n  );\n\n  return verified;\n};\n","export const getVerificationMethod = (\n  didKeyPairInstance: any,\n  contentType: string = 'application/did+ld+json'\n) => {\n  let externalKeyRepresentation;\n  switch (contentType) {\n    case 'application/did+json': {\n      externalKeyRepresentation = didKeyPairInstance.toJsonWebKeyPair();\n      break;\n    }\n    case '*/*':\n    case 'application/did+ld+json': {\n      externalKeyRepresentation = didKeyPairInstance.toKeyPair();\n      break;\n    }\n    default: {\n      throw new Error(\n        'This implementation of did:key does not support: ' + contentType\n      );\n    }\n  }\n  return externalKeyRepresentation;\n};\n\nexport const keyToDidDoc = async (\n  didKeyPairInstance: any,\n  contentType: string = 'application/did+ld+json'\n) => {\n  const did = `did:key:${didKeyPairInstance.fingerprint()}`;\n  const externalKeyRepresentation = getVerificationMethod(\n    didKeyPairInstance,\n    contentType\n  );\n  let verificationRelationships: any = {\n    verificationMethod: [externalKeyRepresentation],\n  };\n\n  if (didKeyPairInstance.verifier) {\n    verificationRelationships = {\n      ...verificationRelationships,\n      authentication: [externalKeyRepresentation.id],\n      assertionMethod: [externalKeyRepresentation.id],\n      capabilityInvocation: [externalKeyRepresentation.id],\n      capabilityDelegation: [externalKeyRepresentation.id],\n    };\n  }\n\n  if (didKeyPairInstance.deriveSecret) {\n    verificationRelationships = {\n      ...verificationRelationships,\n      keyAgreement: [externalKeyRepresentation.id],\n    };\n  }\n\n  if (didKeyPairInstance.type === 'Ed25519VerificationKey2018') {\n    const kek = await didKeyPairInstance.toX25519KeyPair(false);\n    const externalKeyRepresentation2 = getVerificationMethod(kek, contentType);\n    verificationRelationships = {\n      ...verificationRelationships,\n      verificationMethod: [\n        ...verificationRelationships.verificationMethod,\n        externalKeyRepresentation2,\n      ],\n      keyAgreement: [externalKeyRepresentation2.id],\n    };\n  }\n\n  // imagine if people injected ads like this....\n  // verificationRelationships = {\n  //   ...verificationRelationships,\n  //   service: [\n  //     {\n  //       id: '#provider',\n  //       type: 'ServiceProvider',\n  //       serviceEndpoint: 'https://transmute.industries',\n  //     },\n  //   ],\n  // };\n\n  const didDocument = {\n    '@context': [\n      'https://www.w3.org/ns/did/v1',\n      {\n        '@base': did,\n      },\n    ],\n    id: did,\n    ...verificationRelationships,\n  };\n\n  // Here is were I would delete a property for JSON-only\n  // If I wanted to conform to the DID Core JSON Production Rules.\n  return didDocument;\n};\n\n// resolve ( did, did-resolution-input-metadata )\n//      -> ( did-resolution-metadata, did-document, did-document-metadata )\nexport const getResolve = (DidKeyPairClass: any) => {\n  const resolve = async (\n    didUri: string,\n    resolutionMetaData: any = { accept: 'application/did+ld+json' }\n  ) => {\n    const fingerprint = didUri\n      .split('#')[0]\n      .split('did:key:')\n      .pop();\n    const publicKey = await DidKeyPairClass.fromFingerprint({ fingerprint });\n    return {\n      didDocument: await keyToDidDoc(publicKey, resolutionMetaData.accept),\n      didDocumentMetaData: {\n        'content-type': resolutionMetaData.accept,\n      },\n      didResolutionMetaData: {},\n    };\n  };\n  return resolve;\n};\n","export const getGet = (resolve: any) => {\n  const get = async ({ did, url }: any = {}) => {\n    did = did || url;\n    if (!did) {\n      throw new TypeError('\"did\" must be a string.');\n    }\n    const result = await resolve(did);\n    return result.didDocument;\n  };\n  return get;\n};\n","/* class decorator */\nexport const staticImplements = <T>() => {\n  return <U extends T>(constructor: U) => {\n    return constructor;\n  };\n};\n\nexport * from './JWE_ALG';\nexport * from './JWS_ALG';\n\nexport * from './KeyPairClass';\nexport * from './KeyPairInstance';\nexport * from './KeyAgreementKeyPairClass';\nexport * from './KeyPairGenerateOptions';\nexport * from './EpkResult';\nexport * from './KeyEncryptionKeyFromEphemeralPublicKeyOptions';\nexport * from './KeyEncryptionKeyFromStaticPublicKeyOptions';\nexport * from './DeriveSecretOptions';\n\nexport * from './KeyPairBase';\n\nexport * from './KeyPairJwk';\nexport * from './JsonWebKeyPair';\n\nexport * from './KeyPairBase58';\nexport * from './LinkedDataKeyPair';\n\nexport * from './KeyAgreementKeyPairInstance';\n"],"names":["getVerificationMethod","didKeyPairInstance","contentType","externalKeyRepresentation","toJsonWebKeyPair","toKeyPair","Error","keyToDidDoc","did","id","verificationRelationships","fingerprint","verificationMethod","verifier","authentication","assertionMethod","capabilityInvocation","capabilityDelegation","deriveSecret","keyAgreement","type","toX25519KeyPair","kek","externalKeyRepresentation2","signer","payload","header","toBeSigned","base64url","encode","canonicalize","sign","Buffer","from","signature","jws","split","verify","toBuffer","encodedHeader","b64","crit","Uint8Array","concat","encodedSignature","toBeVerified","resolve","url","TypeError","result","didDocument","DidKeyPairClass","didUri","resolutionMetaData","accept","pop","fromFingerprint","publicKey","didDocumentMetaData","didResolutionMetaData","constructor"],"mappings":"oZAGO,ICHMA,EAAwB,SACnCC,EACAC,OAEIC,kBAFJD,IAAAA,EAAsB,2BAGdA,OACD,uBACHC,EAA4BF,EAAmBG,6BAG5C,UACA,0BACHD,EAA4BF,EAAmBI,gCAIzC,IAAIC,MACR,oDAAsDJ,UAIrDC,GAGII,WACXN,EACAC,YAAAA,IAAAA,EAAsB,qEAsDR,CACV,+BACA,SACWM,IAGbC,GAAID,GACDE,IA3DCF,aAAiBP,EAAmBU,cACpCR,EAA4BH,EAChCC,EACAC,GAEEQ,EAAiC,CACnCE,mBAAoB,CAACT,IAGnBF,EAAmBY,WACrBH,OACKA,GACHI,eAAgB,CAACX,EAA0BM,IAC3CM,gBAAiB,CAACZ,EAA0BM,IAC5CO,qBAAsB,CAACb,EAA0BM,IACjDQ,qBAAsB,CAACd,EAA0BM,OAIjDR,EAAmBiB,eACrBR,OACKA,GACHS,aAAc,CAAChB,EAA0BM,2BAIb,+BAA5BR,EAAmBmB,4BACHnB,EAAmBoB,iBAAgB,mBAA/CC,OACAC,EAA6BvB,EAAsBsB,EAAKpB,GAC9DQ,OACKA,GACHE,6BACKF,EAA0BE,oBAC7BW,IAEFJ,aAAc,CAACI,EAA2Bd,+ID5DhBe,EAAaC,EAAcC,WAGnDC,EAFgBC,EAAUC,OAAOC,EAAaJ,QAC7BE,EAAUC,OAAOC,EAAaL,2BAE7BD,EAAOO,KAAKC,OAAOC,KAAKN,oBAA1CO,UACIP,MAAcC,EAAUC,OAAOG,OAAOC,KAAKC,8DAGvBrB,EAAesB,aACRA,EAAIC,MAAM,KAAvBF,8BAEDrB,EAASwB,OAC9BL,OAAOC,oBACPL,EAAUU,SAASJ,oEAOrBV,EACAC,EACAC,WAEMa,EAAgBX,EAAUC,OAC9BC,OAAkBJ,GAAQc,KAAK,EAAOC,KAAM,CAAC,WAGzCd,EAAa,IAAIe,WACrBV,OAAOW,OAAO,CACZX,OAAOC,KAAKM,EAAe,SAC3BP,OAAOC,KAAK,IAAK,SACjBR,4BAGoBD,EAAOO,KAAKC,OAAOC,KAAKN,oBAA1CO,OACAU,EAAmBhB,EAAUC,OAAOG,OAAOC,KAAKC,WAC5CK,OAAkBK,oEAI5B/B,EACAY,EACAS,aAE0CA,EAAUE,MAAM,MAApCQ,OAEhBC,EAAe,IAAIH,WACvBV,OAAOW,OAAO,CACZX,OAAOC,UAAoB,SAC3BD,OAAOC,KAAK,IAAK,SACjBR,4BAImBZ,EAASwB,OAC9BL,OAAOC,KAAKY,GACZjB,EAAUU,SAASM,yDE5DD,SAACE,uCACkB,KAAlBtC,IAAAA,IAAKuC,IAAAA,aACxBvC,EAAMA,GAAOuC,SAEL,IAAIC,UAAU,kDAEDF,EAAQtC,mBAAvByC,UACCA,EAAOC,uED0FQ,SAACC,mBAEvBC,EACAC,YAAAA,IAAAA,EAA0B,CAAEC,OAAQ,oCAE9B3C,EAAcyC,EACjBhB,MAAM,KAAK,GACXA,MAAM,YACNmB,6BACqBJ,EAAgBK,gBAAgB,CAAE7C,YAAAA,oBAApD8C,0BAEelD,EAAYkD,EAAWJ,EAAmBC,iCADxD,CACLJ,cACAQ,oBAAqB,gBACHL,EAAmBC,QAErCK,sBAAuB,oJE/GG,kBACvB,SAAcC,UACZA"}