{"version":3,"file":"did-key-x25519.cjs.production.min.js","sources":["../src/keyUtils.ts","../src/X25519KeyPair.ts","../src/driver.ts"],"sourcesContent":["import bs58 from 'bs58';\nimport base64url from 'base64url';\nimport crypto from 'crypto';\nimport canonicalize from 'canonicalize';\n\nexport const getKid = (jwk: any) => {\n  const copy = { ...jwk } as any;\n  delete copy.d;\n  delete copy.kid;\n  delete copy.alg;\n  const digest = crypto\n    .createHash('sha256')\n    .update(canonicalize(copy))\n    .digest();\n  return base64url.encode(Buffer.from(digest));\n};\n\nexport const privateKeyJwkFromPrivateKeyBase58 = (\n  publicKeyBase58: string,\n  privateKeybase58: string\n) => {\n  const publicKeyBytes = bs58.decode(publicKeyBase58);\n  const privateKeyBytes = bs58.decode(privateKeybase58);\n  const _jwk = {\n    kty: 'OKP',\n    crv: 'X25519',\n    d: base64url.encode(privateKeyBytes),\n    x: base64url.encode(publicKeyBytes),\n  };\n  const kid = getKid(_jwk);\n  return {\n    ..._jwk,\n    kid,\n  };\n};\n\nexport const publicKeyJwkFromPublicKeyBase58 = (publicKeyBase58: string) => {\n  const _jwk = {\n    kty: 'OKP',\n    crv: 'X25519',\n    x: base64url.encode(bs58.decode(publicKeyBase58)),\n  };\n  const kid = getKid(_jwk);\n  return {\n    ..._jwk,\n    kid,\n  };\n};\n\nexport const privateKeyHexFromPrivateKeyBase58 = (privateKeyBase58: string) => {\n  return Buffer.from(bs58.decode(privateKeyBase58)).toString('hex');\n};\n\nexport const publicKeyHexFromPublicKeyBase58 = (publicKeyBase58: string) => {\n  return Buffer.from(bs58.decode(publicKeyBase58)).toString('hex');\n};\n\nexport const privateKeyBase58FromPrivateKeyJwk = (jwk: any) => {\n  return bs58.encode(base64url.toBuffer(jwk.d));\n};\n\nexport const publicKeyBase58FromPublicKeyJwk = (jwk: any) => {\n  return bs58.encode(base64url.toBuffer(jwk.x));\n};\n\nexport const privateKeyBase58FromPrivateKeyHex = (privateKeyHex: string) => {\n  return bs58.encode(Buffer.from(privateKeyHex, 'hex'));\n};\n\nexport const publicKeyBase58FromPublicKeyHex = (publicKeyHex: string) => {\n  return bs58.encode(Buffer.from(publicKeyHex, 'hex'));\n};\n","import bs58 from 'bs58';\n\nimport {\n  convertPublicKeyToX25519,\n  convertSecretKeyToX25519,\n} from '@stablelib/ed25519';\nimport * as x25519 from '@stablelib/x25519';\nimport * as keyUtils from './keyUtils';\n\nimport base64url from 'base64url';\nimport crypto from 'crypto';\n\nimport * as common from '@transmute/did-key-common';\n\nimport {\n  deriveKey,\n  getEpkGenerator,\n  KeyEncryptionKey,\n} from '@transmute/did-key-cipher';\n\nconst KEY_TYPE = 'X25519KeyAgreementKey2019';\n\n@common.types.staticImplements<common.types.KeyAgreementKeyPairClass>()\nexport class X25519KeyPair implements common.types.KeyPairInstance {\n  public id: string;\n  public type: string;\n  public controller: string;\n\n  public publicKeyBuffer: Buffer;\n  public privateKeyBuffer?: Buffer;\n\n  public static JWE_ALG: common.types.ECDH_ES_A256KW = 'ECDH-ES+A256KW';\n\n  static fingerprintFromPublicKey(\n    keypair: common.types.KeyPairJwk | common.types.KeyPairBase58\n  ) {\n    let pubkeyBytes: any;\n\n    if ((keypair as any).publicKeyBase58) {\n      pubkeyBytes = bs58.decode(\n        (keypair as common.types.KeyPairBase58).publicKeyBase58\n      );\n    }\n\n    if ((keypair as any).publicKeyJwk) {\n      pubkeyBytes = bs58.decode(\n        keyUtils.publicKeyBase58FromPublicKeyJwk(\n          (keypair as common.types.KeyPairJwk).publicKeyJwk\n        )\n      );\n    }\n\n    // https://github.com/multiformats/multicodec/blob/master/table.csv#L80\n\n    const buffer = new Uint8Array(2 + pubkeyBytes.length);\n    buffer[0] = 0xec;\n    buffer[1] = 0x01;\n    buffer.set(pubkeyBytes, 2);\n    // prefix with `z` to indicate multi-base base58btc encoding\n    return `z${bs58.encode(buffer)}`;\n  }\n\n  static async generate(options: common.types.KeyPairGenerateOptions) {\n    let key;\n\n    key = x25519.generateKeyPair({\n      isAvailable: true,\n      randomBytes: options.secureRandom,\n    });\n\n    if (!key) {\n      throw new Error('options.seed or options.secureRandom is required.');\n    }\n\n    const publicKeyBase58 = bs58.encode(key.publicKey);\n    const privateKeyBase58 = bs58.encode(key.secretKey);\n\n    const did = `did:key:${X25519KeyPair.fingerprintFromPublicKey({\n      publicKeyBase58,\n    } as any)}`;\n    const keyId = `#${X25519KeyPair.fingerprintFromPublicKey({\n      publicKeyBase58,\n    } as any)}`;\n    return new X25519KeyPair({\n      id: keyId,\n      controller: did,\n      publicKeyBase58,\n      privateKeyBase58,\n    } as common.types.KeyPairBase58);\n  }\n\n  static async generateEphemeralKeyPair(): Promise<common.types.EpkResult> {\n    return getEpkGenerator(X25519KeyPair, {\n      secureRandom: () => {\n        return crypto.randomBytes(32);\n      },\n    })();\n  }\n\n  static async kekFromEphemeralPeer({\n    keyAgreementKey,\n    epk,\n  }: common.types.KeyEncryptionKeyFromEphemeralPublicKeyOptions) {\n    if (!(epk && typeof epk === 'object')) {\n      throw new TypeError('\"epk\" must be an object.');\n    }\n\n    // decode public key material\n    const publicKey = base64url.toBuffer(epk.x);\n\n    // convert to LD key for Web KMS\n    const ephemeralPublicKey = {\n      type: KEY_TYPE,\n      publicKeyBase58: bs58.encode(publicKey),\n    };\n\n    // safe to use IDs like in rfc7518 or does\n    // https://tools.ietf.org/html/rfc7748#section-7 pose any issues?\n\n    // \"Party U Info\"\n    const producerInfo = publicKey;\n    // \"Party V Info\"\n    const consumerInfo = Buffer.from(keyAgreementKey.id);\n    // converts keys again....\n    // base58 encoding should only be used at the network / serialization boundary.\n    const secret = await (keyAgreementKey as common.types.KeyAgreementKeyPairInstance).deriveSecret(\n      {\n        publicKey: ephemeralPublicKey,\n      } as any\n    );\n    const keyData = await deriveKey({ secret, producerInfo, consumerInfo });\n    return {\n      kek: await KeyEncryptionKey.createKek({ keyData }),\n    };\n  }\n\n  static async kekFromStaticPeer({\n    ephemeralKeyPair,\n    staticPublicKey,\n  }: common.types.KeyEncryptionKeyFromStaticPublicKeyOptions) {\n    // TODO: consider accepting JWK format for `staticPublicKey` not just LD key\n    if (\n      !(\n        staticPublicKey.type === 'X25519KeyAgreementKey2019' ||\n        staticPublicKey.type === 'JsonWebKey2020'\n      )\n    ) {\n      throw new Error(\n        `\"staticPublicKey.type\" must be \"X25519KeyAgreementKey2019\".`\n      );\n    }\n\n    const epkPair = await X25519KeyPair.from(ephemeralKeyPair.keypair);\n\n    // \"Party U Info\"\n    const producerInfo = epkPair.publicKeyBuffer;\n    // \"Party V Info\"\n    const consumerInfo = Buffer.from(staticPublicKey.id);\n\n    const secret = await epkPair.deriveSecret({\n      publicKey: staticPublicKey,\n    } as any);\n    const keyData = await deriveKey({ secret, producerInfo, consumerInfo });\n    return {\n      kek: await KeyEncryptionKey.createKek({ keyData }),\n      epk: ephemeralKeyPair.epk,\n      apu: base64url.encode(producerInfo),\n      apv: base64url.encode(consumerInfo as any),\n    };\n  }\n\n  static fromFingerprint({ fingerprint }: any) {\n    // skip leading `z` that indicates base58 encoding\n    const buffer = bs58.decode(fingerprint.substr(1));\n    // https://github.com/multiformats/multicodec/blob/master/table.csv#L80\n    if (buffer[0] === 0xec && buffer[1] === 0x01) {\n      const publicKeyBase58 = bs58.encode(buffer.slice(2));\n      const did = `did:key:${X25519KeyPair.fingerprintFromPublicKey({\n        publicKeyBase58,\n      } as any)}`;\n      const keyId = `#${X25519KeyPair.fingerprintFromPublicKey({\n        publicKeyBase58,\n      } as any)}`;\n      return new X25519KeyPair({\n        id: keyId,\n        controller: did,\n        publicKeyBase58,\n      } as common.types.KeyPairBase58);\n    }\n\n    throw new Error(`Unsupported Fingerprint Type: ${fingerprint}`);\n  }\n\n  static fromEdKeyPair(ed25519KeyPair: common.types.KeyPairBase58) {\n    let publicKeyBase58;\n    let privateKeyBase58;\n\n    if (ed25519KeyPair.publicKeyBase58) {\n      publicKeyBase58 = bs58.encode(\n        convertPublicKeyToX25519(bs58.decode(ed25519KeyPair.publicKeyBase58))\n      );\n    }\n\n    if (ed25519KeyPair.privateKeyBase58) {\n      privateKeyBase58 = bs58.encode(\n        convertSecretKeyToX25519(bs58.decode(ed25519KeyPair.privateKeyBase58))\n      );\n    }\n\n    return new X25519KeyPair({\n      controller: ed25519KeyPair.controller,\n      publicKeyBase58,\n      privateKeyBase58,\n    } as common.types.KeyPairBase58);\n  }\n\n  static from(options: common.types.KeyPairBase58 | common.types.KeyPairJwk) {\n    let privateKeyBase58;\n    let publicKeyBase58;\n\n    if ((options as common.types.KeyPairBase58).publicKeyBase58) {\n      publicKeyBase58 = (options as common.types.KeyPairBase58).publicKeyBase58;\n    }\n\n    if ((options as common.types.KeyPairBase58).privateKeyBase58) {\n      privateKeyBase58 = (options as common.types.KeyPairBase58)\n        .privateKeyBase58;\n    }\n\n    if ((options as common.types.KeyPairJwk).privateKeyJwk) {\n      privateKeyBase58 = keyUtils.privateKeyBase58FromPrivateKeyJwk(\n        (options as common.types.KeyPairJwk).privateKeyJwk\n      );\n    }\n\n    if ((options as common.types.KeyPairJwk).publicKeyJwk) {\n      publicKeyBase58 = keyUtils.publicKeyBase58FromPublicKeyJwk(\n        (options as common.types.KeyPairJwk).publicKeyJwk\n      );\n    }\n\n    return new X25519KeyPair({\n      ...options,\n      privateKeyBase58,\n      publicKeyBase58,\n    });\n  }\n\n  constructor(options: common.types.KeyPairJwk | common.types.KeyPairBase58) {\n    this.type = 'X25519KeyAgreementKey2019';\n    this.id = options.id;\n    this.controller = options.controller;\n\n    if ((options as common.types.KeyPairBase58).publicKeyBase58) {\n      this.publicKeyBuffer = Buffer.from(\n        bs58.decode((options as common.types.KeyPairBase58).publicKeyBase58)\n      );\n    } else if ((options as common.types.JsonWebKeyPair).publicKeyJwk) {\n      this.publicKeyBuffer = Buffer.from(\n        bs58.decode(\n          keyUtils.publicKeyBase58FromPublicKeyJwk(\n            (options as common.types.JsonWebKeyPair).publicKeyJwk\n          )\n        )\n      );\n    } else {\n      throw new Error(\n        'X25519KeyPair requires publicKeyBase58 or publicKeyJwk, received none.'\n      );\n    }\n\n    if ((options as common.types.KeyPairBase58).privateKeyBase58) {\n      this.privateKeyBuffer = Buffer.from(\n        bs58.decode((options as common.types.KeyPairBase58).privateKeyBase58)\n      );\n    }\n\n    if ((options as common.types.JsonWebKeyPair).privateKeyJwk) {\n      this.privateKeyBuffer = Buffer.from(\n        bs58.decode(\n          keyUtils.privateKeyBase58FromPrivateKeyJwk(\n            (options as common.types.JsonWebKeyPair).privateKeyJwk\n          )\n        )\n      );\n    }\n\n    if (!this.id) {\n      this.id = `#${this.fingerprint()}`;\n    }\n  }\n\n  fingerprint() {\n    return X25519KeyPair.fingerprintFromPublicKey({\n      publicKeyBase58: bs58.encode(this.publicKeyBuffer),\n    } as any);\n  }\n\n  verifyFingerprint(fingerprint: any) {\n    // fingerprint should have `z` prefix indicating\n    // that it's multi-base encoded\n    if (!(typeof fingerprint === 'string' && fingerprint[0] === 'z')) {\n      return {\n        error: new Error('`fingerprint` must be a multibase encoded string.'),\n        valid: false,\n      };\n    }\n    let fingerprintBuffer;\n    try {\n      fingerprintBuffer = bs58.decode(fingerprint.slice(1));\n    } catch (e) {\n      return { error: e, valid: false };\n    }\n    let publicKeyBuffer = this.publicKeyBuffer;\n\n    // validate the first two multicodec bytes 0xec01\n    // https://github.com/multiformats/multicodec/blob/master/table.csv#L80\n    const valid =\n      fingerprintBuffer.slice(0, 2).toString('hex') === 'ec01' &&\n      publicKeyBuffer.equals(fingerprintBuffer.slice(2));\n    if (!valid) {\n      return {\n        error: new Error('The fingerprint does not match the public key.'),\n        valid: false,\n      };\n    }\n    return { valid };\n  }\n\n  toKeyPair(_private: boolean = false): common.types.LinkedDataKeyPair {\n    let kp: any = {\n      id: this.id,\n      type: this.type,\n      controller: this.controller,\n      publicKeyBase58: bs58.encode(this.publicKeyBuffer),\n    };\n    if (_private) {\n      kp.privateKeyBase58 = bs58.encode(this.privateKeyBuffer);\n    }\n    return kp;\n  }\n\n  toJsonWebKeyPair(_private: boolean = false): common.types.JsonWebKeyPair {\n    let kp: any = {\n      id: this.id,\n      type: 'JsonWebKey2020',\n      controller: this.controller,\n      publicKeyJwk: this.toJwk(),\n    };\n    delete kp.publicKeyJwk.kid;\n    if (_private) {\n      kp.privateKeyJwk = this.toJwk(true);\n      delete kp.privateKeyJwk.kid;\n    }\n\n    return kp;\n  }\n\n  toJwk(_private: boolean = false) {\n    const publicKeyBase58 = bs58.encode(this.publicKeyBuffer);\n    if (_private) {\n      return keyUtils.privateKeyJwkFromPrivateKeyBase58(\n        publicKeyBase58,\n        bs58.encode(this.privateKeyBuffer)\n      );\n    }\n    return keyUtils.publicKeyJwkFromPublicKeyBase58(publicKeyBase58);\n  }\n\n  deriveSecret(options: common.types.DeriveSecretOptions) {\n    let remotePubkeyBytes;\n\n    const { publicKey } = options;\n\n    if ((publicKey as any).publicKeyBase58) {\n      remotePubkeyBytes = bs58.decode(\n        (publicKey as common.types.LinkedDataKeyPair).publicKeyBase58\n      );\n    } else if ((publicKey as any).publicKeyJwk) {\n      remotePubkeyBytes = bs58.decode(\n        keyUtils.publicKeyBase58FromPublicKeyJwk(\n          (publicKey as common.types.JsonWebKeyPair).publicKeyJwk\n        )\n      );\n    }\n\n    const privateKeyBytes = this.privateKeyBuffer as Buffer;\n\n    const scalarMultipleResult = x25519.sharedKey(\n      new Uint8Array(privateKeyBytes),\n      new Uint8Array(remotePubkeyBytes),\n      true\n    );\n\n    return scalarMultipleResult;\n  }\n}\n","import { X25519KeyPair } from './X25519KeyPair';\nimport { getResolve, getGet } from '@transmute/did-key-common';\n\nexport const resolve = getResolve(X25519KeyPair);\nexport const get = getGet(resolve);\n"],"names":["getKid","jwk","copy","d","kid","alg","digest","crypto","createHash","update","canonicalize","base64url","encode","Buffer","from","privateKeyJwkFromPrivateKeyBase58","publicKeyBase58","privateKeybase58","publicKeyBytes","bs58","decode","privateKeyBytes","_jwk","kty","crv","x","publicKeyJwkFromPublicKeyBase58","privateKeyBase58FromPrivateKeyJwk","toBuffer","publicKeyBase58FromPublicKeyJwk","privateKeyBase58","toString","privateKeyHex","publicKeyHex","X25519KeyPair","options","type","id","controller","publicKeyBuffer","publicKeyJwk","Error","keyUtils","privateKeyBuffer","privateKeyJwk","this","fingerprint","fingerprintFromPublicKey","keypair","pubkeyBytes","buffer","Uint8Array","length","set","generate","key","x25519","isAvailable","randomBytes","secureRandom","publicKey","secretKey","did","X25519KeyPair_1","keyId","generateEphemeralKeyPair","getEpkGenerator","kekFromEphemeralPeer","keyAgreementKey","epk","TypeError","ephemeralPublicKey","producerInfo","consumerInfo","deriveSecret","secret","deriveKey","keyData","KeyEncryptionKey","createKek","kek","kekFromStaticPeer","ephemeralKeyPair","staticPublicKey","epkPair","apu","apv","fromFingerprint","substr","slice","fromEdKeyPair","ed25519KeyPair","convertPublicKeyToX25519","convertSecretKeyToX25519","verifyFingerprint","error","valid","fingerprintBuffer","e","equals","toKeyPair","_private","kp","toJsonWebKeyPair","toJwk","remotePubkeyBytes","common","staticImplements","resolve","getResolve","getGet"],"mappings":"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"}