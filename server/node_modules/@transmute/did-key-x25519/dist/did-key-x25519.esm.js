import bs58 from 'bs58';
import base64url from 'base64url';
import crypto from 'crypto';
import canonicalize from 'canonicalize';
import { __decorate } from 'tslib';
import { convertPublicKeyToX25519, convertSecretKeyToX25519 } from '@stablelib/ed25519';
import { sharedKey, generateKeyPair } from '@stablelib/x25519';
import { types, getResolve, getGet } from '@transmute/did-key-common';
import { getEpkGenerator, deriveKey, KeyEncryptionKey } from '@transmute/did-key-cipher';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

var getKid = function getKid(jwk) {
  var copy = _extends({}, jwk);

  delete copy.d;
  delete copy.kid;
  delete copy.alg;
  var digest = crypto.createHash('sha256').update(canonicalize(copy)).digest();
  return base64url.encode(Buffer.from(digest));
};
var privateKeyJwkFromPrivateKeyBase58 = function privateKeyJwkFromPrivateKeyBase58(publicKeyBase58, privateKeybase58) {
  var publicKeyBytes = bs58.decode(publicKeyBase58);
  var privateKeyBytes = bs58.decode(privateKeybase58);
  var _jwk = {
    kty: 'OKP',
    crv: 'X25519',
    d: base64url.encode(privateKeyBytes),
    x: base64url.encode(publicKeyBytes)
  };
  var kid = getKid(_jwk);
  return _extends({}, _jwk, {
    kid: kid
  });
};
var publicKeyJwkFromPublicKeyBase58 = function publicKeyJwkFromPublicKeyBase58(publicKeyBase58) {
  var _jwk = {
    kty: 'OKP',
    crv: 'X25519',
    x: base64url.encode(bs58.decode(publicKeyBase58))
  };
  var kid = getKid(_jwk);
  return _extends({}, _jwk, {
    kid: kid
  });
};
var privateKeyHexFromPrivateKeyBase58 = function privateKeyHexFromPrivateKeyBase58(privateKeyBase58) {
  return Buffer.from(bs58.decode(privateKeyBase58)).toString('hex');
};
var publicKeyHexFromPublicKeyBase58 = function publicKeyHexFromPublicKeyBase58(publicKeyBase58) {
  return Buffer.from(bs58.decode(publicKeyBase58)).toString('hex');
};
var privateKeyBase58FromPrivateKeyJwk = function privateKeyBase58FromPrivateKeyJwk(jwk) {
  return bs58.encode(base64url.toBuffer(jwk.d));
};
var publicKeyBase58FromPublicKeyJwk = function publicKeyBase58FromPublicKeyJwk(jwk) {
  return bs58.encode(base64url.toBuffer(jwk.x));
};
var privateKeyBase58FromPrivateKeyHex = function privateKeyBase58FromPrivateKeyHex(privateKeyHex) {
  return bs58.encode(Buffer.from(privateKeyHex, 'hex'));
};
var publicKeyBase58FromPublicKeyHex = function publicKeyBase58FromPublicKeyHex(publicKeyHex) {
  return bs58.encode(Buffer.from(publicKeyHex, 'hex'));
};

var keyUtils = {
  __proto__: null,
  getKid: getKid,
  privateKeyJwkFromPrivateKeyBase58: privateKeyJwkFromPrivateKeyBase58,
  publicKeyJwkFromPublicKeyBase58: publicKeyJwkFromPublicKeyBase58,
  privateKeyHexFromPrivateKeyBase58: privateKeyHexFromPrivateKeyBase58,
  publicKeyHexFromPublicKeyBase58: publicKeyHexFromPublicKeyBase58,
  privateKeyBase58FromPrivateKeyJwk: privateKeyBase58FromPrivateKeyJwk,
  publicKeyBase58FromPublicKeyJwk: publicKeyBase58FromPublicKeyJwk,
  privateKeyBase58FromPrivateKeyHex: privateKeyBase58FromPrivateKeyHex,
  publicKeyBase58FromPublicKeyHex: publicKeyBase58FromPublicKeyHex
};

var X25519KeyPair_1;
var KEY_TYPE = 'X25519KeyAgreementKey2019';

var X25519KeyPair = X25519KeyPair_1 = /*#__PURE__*/function () {
  function X25519KeyPair(options) {
    this.type = 'X25519KeyAgreementKey2019';
    this.id = options.id;
    this.controller = options.controller;

    if (options.publicKeyBase58) {
      this.publicKeyBuffer = Buffer.from(bs58.decode(options.publicKeyBase58));
    } else if (options.publicKeyJwk) {
      this.publicKeyBuffer = Buffer.from(bs58.decode(publicKeyBase58FromPublicKeyJwk(options.publicKeyJwk)));
    } else {
      throw new Error('X25519KeyPair requires publicKeyBase58 or publicKeyJwk, received none.');
    }

    if (options.privateKeyBase58) {
      this.privateKeyBuffer = Buffer.from(bs58.decode(options.privateKeyBase58));
    }

    if (options.privateKeyJwk) {
      this.privateKeyBuffer = Buffer.from(bs58.decode(privateKeyBase58FromPrivateKeyJwk(options.privateKeyJwk)));
    }

    if (!this.id) {
      this.id = "#" + this.fingerprint();
    }
  }

  X25519KeyPair.fingerprintFromPublicKey = function fingerprintFromPublicKey(keypair) {
    var pubkeyBytes;

    if (keypair.publicKeyBase58) {
      pubkeyBytes = bs58.decode(keypair.publicKeyBase58);
    }

    if (keypair.publicKeyJwk) {
      pubkeyBytes = bs58.decode(publicKeyBase58FromPublicKeyJwk(keypair.publicKeyJwk));
    } // https://github.com/multiformats/multicodec/blob/master/table.csv#L80


    var buffer = new Uint8Array(2 + pubkeyBytes.length);
    buffer[0] = 0xec;
    buffer[1] = 0x01;
    buffer.set(pubkeyBytes, 2); // prefix with `z` to indicate multi-base base58btc encoding

    return "z" + bs58.encode(buffer);
  };

  X25519KeyPair.generate = function generate(options) {
    try {
      var key;
      key = generateKeyPair({
        isAvailable: true,
        randomBytes: options.secureRandom
      });

      if (!key) {
        throw new Error('options.seed or options.secureRandom is required.');
      }

      var publicKeyBase58 = bs58.encode(key.publicKey);
      var privateKeyBase58 = bs58.encode(key.secretKey);
      var did = "did:key:" + X25519KeyPair_1.fingerprintFromPublicKey({
        publicKeyBase58: publicKeyBase58
      });
      var keyId = "#" + X25519KeyPair_1.fingerprintFromPublicKey({
        publicKeyBase58: publicKeyBase58
      });
      return Promise.resolve(new X25519KeyPair_1({
        id: keyId,
        controller: did,
        publicKeyBase58: publicKeyBase58,
        privateKeyBase58: privateKeyBase58
      }));
    } catch (e) {
      return Promise.reject(e);
    }
  };

  X25519KeyPair.generateEphemeralKeyPair = function generateEphemeralKeyPair() {
    try {
      return Promise.resolve(getEpkGenerator(X25519KeyPair_1, {
        secureRandom: function secureRandom() {
          return crypto.randomBytes(32);
        }
      })());
    } catch (e) {
      return Promise.reject(e);
    }
  };

  X25519KeyPair.kekFromEphemeralPeer = function kekFromEphemeralPeer(_ref) {
    var keyAgreementKey = _ref.keyAgreementKey,
        epk = _ref.epk;

    try {
      if (!(epk && typeof epk === 'object')) {
        throw new TypeError('"epk" must be an object.');
      } // decode public key material


      var publicKey = base64url.toBuffer(epk.x); // convert to LD key for Web KMS

      var ephemeralPublicKey = {
        type: KEY_TYPE,
        publicKeyBase58: bs58.encode(publicKey)
      }; // safe to use IDs like in rfc7518 or does
      // https://tools.ietf.org/html/rfc7748#section-7 pose any issues?
      // "Party U Info"

      var producerInfo = publicKey; // "Party V Info"

      var consumerInfo = Buffer.from(keyAgreementKey.id); // converts keys again....
      // base58 encoding should only be used at the network / serialization boundary.

      return Promise.resolve(keyAgreementKey.deriveSecret({
        publicKey: ephemeralPublicKey
      })).then(function (secret) {
        return Promise.resolve(deriveKey({
          secret: secret,
          producerInfo: producerInfo,
          consumerInfo: consumerInfo
        })).then(function (keyData) {
          return Promise.resolve(KeyEncryptionKey.createKek({
            keyData: keyData
          })).then(function (_KeyEncryptionKey$cre) {
            return {
              kek: _KeyEncryptionKey$cre
            };
          });
        });
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  X25519KeyPair.kekFromStaticPeer = function kekFromStaticPeer(_ref2) {
    var ephemeralKeyPair = _ref2.ephemeralKeyPair,
        staticPublicKey = _ref2.staticPublicKey;

    try {
      // TODO: consider accepting JWK format for `staticPublicKey` not just LD key
      if (!(staticPublicKey.type === 'X25519KeyAgreementKey2019' || staticPublicKey.type === 'JsonWebKey2020')) {
        throw new Error("\"staticPublicKey.type\" must be \"X25519KeyAgreementKey2019\".");
      }

      return Promise.resolve(X25519KeyPair_1.from(ephemeralKeyPair.keypair)).then(function (epkPair) {
        // "Party U Info"
        var producerInfo = epkPair.publicKeyBuffer; // "Party V Info"

        var consumerInfo = Buffer.from(staticPublicKey.id);
        return Promise.resolve(epkPair.deriveSecret({
          publicKey: staticPublicKey
        })).then(function (secret) {
          return Promise.resolve(deriveKey({
            secret: secret,
            producerInfo: producerInfo,
            consumerInfo: consumerInfo
          })).then(function (keyData) {
            return Promise.resolve(KeyEncryptionKey.createKek({
              keyData: keyData
            })).then(function (_KeyEncryptionKey$cre2) {
              return {
                kek: _KeyEncryptionKey$cre2,
                epk: ephemeralKeyPair.epk,
                apu: base64url.encode(producerInfo),
                apv: base64url.encode(consumerInfo)
              };
            });
          });
        });
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  X25519KeyPair.fromFingerprint = function fromFingerprint(_ref3) {
    var fingerprint = _ref3.fingerprint;
    // skip leading `z` that indicates base58 encoding
    var buffer = bs58.decode(fingerprint.substr(1)); // https://github.com/multiformats/multicodec/blob/master/table.csv#L80

    if (buffer[0] === 0xec && buffer[1] === 0x01) {
      var publicKeyBase58 = bs58.encode(buffer.slice(2));
      var did = "did:key:" + X25519KeyPair_1.fingerprintFromPublicKey({
        publicKeyBase58: publicKeyBase58
      });
      var keyId = "#" + X25519KeyPair_1.fingerprintFromPublicKey({
        publicKeyBase58: publicKeyBase58
      });
      return new X25519KeyPair_1({
        id: keyId,
        controller: did,
        publicKeyBase58: publicKeyBase58
      });
    }

    throw new Error("Unsupported Fingerprint Type: " + fingerprint);
  };

  X25519KeyPair.fromEdKeyPair = function fromEdKeyPair(ed25519KeyPair) {
    var publicKeyBase58;
    var privateKeyBase58;

    if (ed25519KeyPair.publicKeyBase58) {
      publicKeyBase58 = bs58.encode(convertPublicKeyToX25519(bs58.decode(ed25519KeyPair.publicKeyBase58)));
    }

    if (ed25519KeyPair.privateKeyBase58) {
      privateKeyBase58 = bs58.encode(convertSecretKeyToX25519(bs58.decode(ed25519KeyPair.privateKeyBase58)));
    }

    return new X25519KeyPair_1({
      controller: ed25519KeyPair.controller,
      publicKeyBase58: publicKeyBase58,
      privateKeyBase58: privateKeyBase58
    });
  };

  X25519KeyPair.from = function from(options) {
    var privateKeyBase58;
    var publicKeyBase58;

    if (options.publicKeyBase58) {
      publicKeyBase58 = options.publicKeyBase58;
    }

    if (options.privateKeyBase58) {
      privateKeyBase58 = options.privateKeyBase58;
    }

    if (options.privateKeyJwk) {
      privateKeyBase58 = privateKeyBase58FromPrivateKeyJwk(options.privateKeyJwk);
    }

    if (options.publicKeyJwk) {
      publicKeyBase58 = publicKeyBase58FromPublicKeyJwk(options.publicKeyJwk);
    }

    return new X25519KeyPair_1(_extends({}, options, {
      privateKeyBase58: privateKeyBase58,
      publicKeyBase58: publicKeyBase58
    }));
  };

  var _proto = X25519KeyPair.prototype;

  _proto.fingerprint = function fingerprint() {
    return X25519KeyPair_1.fingerprintFromPublicKey({
      publicKeyBase58: bs58.encode(this.publicKeyBuffer)
    });
  };

  _proto.verifyFingerprint = function verifyFingerprint(fingerprint) {
    // fingerprint should have `z` prefix indicating
    // that it's multi-base encoded
    if (!(typeof fingerprint === 'string' && fingerprint[0] === 'z')) {
      return {
        error: new Error('`fingerprint` must be a multibase encoded string.'),
        valid: false
      };
    }

    var fingerprintBuffer;

    try {
      fingerprintBuffer = bs58.decode(fingerprint.slice(1));
    } catch (e) {
      return {
        error: e,
        valid: false
      };
    }

    var publicKeyBuffer = this.publicKeyBuffer; // validate the first two multicodec bytes 0xec01
    // https://github.com/multiformats/multicodec/blob/master/table.csv#L80

    var valid = fingerprintBuffer.slice(0, 2).toString('hex') === 'ec01' && publicKeyBuffer.equals(fingerprintBuffer.slice(2));

    if (!valid) {
      return {
        error: new Error('The fingerprint does not match the public key.'),
        valid: false
      };
    }

    return {
      valid: valid
    };
  };

  _proto.toKeyPair = function toKeyPair(_private) {
    if (_private === void 0) {
      _private = false;
    }

    var kp = {
      id: this.id,
      type: this.type,
      controller: this.controller,
      publicKeyBase58: bs58.encode(this.publicKeyBuffer)
    };

    if (_private) {
      kp.privateKeyBase58 = bs58.encode(this.privateKeyBuffer);
    }

    return kp;
  };

  _proto.toJsonWebKeyPair = function toJsonWebKeyPair(_private) {
    if (_private === void 0) {
      _private = false;
    }

    var kp = {
      id: this.id,
      type: 'JsonWebKey2020',
      controller: this.controller,
      publicKeyJwk: this.toJwk()
    };
    delete kp.publicKeyJwk.kid;

    if (_private) {
      kp.privateKeyJwk = this.toJwk(true);
      delete kp.privateKeyJwk.kid;
    }

    return kp;
  };

  _proto.toJwk = function toJwk(_private) {
    if (_private === void 0) {
      _private = false;
    }

    var publicKeyBase58 = bs58.encode(this.publicKeyBuffer);

    if (_private) {
      return privateKeyJwkFromPrivateKeyBase58(publicKeyBase58, bs58.encode(this.privateKeyBuffer));
    }

    return publicKeyJwkFromPublicKeyBase58(publicKeyBase58);
  };

  _proto.deriveSecret = function deriveSecret(options) {
    var remotePubkeyBytes;
    var publicKey = options.publicKey;

    if (publicKey.publicKeyBase58) {
      remotePubkeyBytes = bs58.decode(publicKey.publicKeyBase58);
    } else if (publicKey.publicKeyJwk) {
      remotePubkeyBytes = bs58.decode(publicKeyBase58FromPublicKeyJwk(publicKey.publicKeyJwk));
    }

    var privateKeyBytes = this.privateKeyBuffer;
    var scalarMultipleResult = sharedKey(new Uint8Array(privateKeyBytes), new Uint8Array(remotePubkeyBytes), true);
    return scalarMultipleResult;
  };

  return X25519KeyPair;
}();

X25519KeyPair.JWE_ALG = 'ECDH-ES+A256KW';
X25519KeyPair = X25519KeyPair_1 = /*#__PURE__*/__decorate([/*#__PURE__*/types.staticImplements()], X25519KeyPair);

var resolve = /*#__PURE__*/getResolve(X25519KeyPair);
var get = /*#__PURE__*/getGet(resolve);

var driver = {
  __proto__: null,
  resolve: resolve,
  get: get
};

export { X25519KeyPair, driver, keyUtils };
//# sourceMappingURL=did-key-x25519.esm.js.map
