{"version":3,"file":"did-key-secp256k1.cjs.production.min.js","sources":["../src/keyUtils.ts","../src/ES256K.ts","../src/Secp256k1KeyPair.ts","../src/driver.ts"],"sourcesContent":["import keyto from '@trust/keyto';\nimport base64url from 'base64url';\nimport crypto from 'crypto';\nimport bs58 from 'bs58';\nimport secp256k1 from 'secp256k1';\n\nimport canonicalize from 'canonicalize';\n\nconst compressedHexEncodedPublicKeyLength = 66;\n\n/** Secp256k1 Private Key  */\nexport interface ISecp256k1PrivateKeyJwk {\n  /** key type */\n  kty: string;\n\n  /** curve */\n  crv: string;\n\n  /** private point */\n  d: string;\n\n  /** public point */\n  x: string;\n\n  /** public point */\n  y: string;\n\n  /** key id */\n  kid: string;\n}\n\n/** Secp256k1 Public Key  */\nexport interface ISecp256k1PublicKeyJwk {\n  /** key type */\n  kty: string;\n\n  /** curve */\n  crv: string;\n\n  /** public point */\n  x: string;\n\n  /** public point */\n  y: string;\n\n  /** key id */\n  kid: string;\n}\n\n/**\n * Example\n * ```js\n * {\n *  kty: 'EC',\n *  crv: 'secp256k1',\n *  d: 'rhYFsBPF9q3-uZThy7B3c4LDF_8wnozFUAEm5LLC4Zw',\n *  x: 'dWCvM4fTdeM0KmloF57zxtBPXTOythHPMm1HCLrdd3A',\n *  y: '36uMVGM7hnw-N6GnjFcihWE3SkrhMLzzLCdPMXPEXlA',\n *  kid: 'JUvpllMEYUZ2joO59UNui_XYDqxVqiFLLAJ8klWuPBw'\n * }\n * ```\n * See [rfc7638](https://tools.ietf.org/html/rfc7638) for more details on Jwk.\n */\nexport const getKid = (\n  jwk: ISecp256k1PrivateKeyJwk | ISecp256k1PublicKeyJwk\n) => {\n  const copy = { ...jwk } as any;\n  delete copy.d;\n  delete copy.kid;\n  delete copy.alg;\n  const digest = crypto\n    .createHash('sha256')\n    .update(canonicalize(copy))\n    .digest();\n\n  return base64url.encode(Buffer.from(digest));\n};\n\n/** convert compressed hex encoded private key to jwk */\nexport const privateKeyJwkFromPrivateKeyHex = (privateKeyHex: string) => {\n  const jwk = {\n    ...keyto.from(privateKeyHex, 'blk').toJwk('private'),\n    crv: 'secp256k1',\n  };\n  const kid = getKid(jwk);\n  return {\n    ...jwk,\n    kid,\n  };\n};\n\n/** convert compressed hex encoded public key to jwk */\nexport const publicKeyJwkFromPublicKeyHex = (publicKeyHex: string) => {\n  let key = publicKeyHex;\n  if (publicKeyHex.length === compressedHexEncodedPublicKeyLength) {\n    const keyBin = secp256k1.publicKeyConvert(\n      Buffer.from(publicKeyHex, 'hex'),\n      false\n    );\n    key = Buffer.from(keyBin).toString('hex');\n  }\n  const jwk = {\n    ...keyto.from(key, 'blk').toJwk('public'),\n    crv: 'secp256k1',\n  };\n  const kid = getKid(jwk);\n\n  return {\n    ...jwk,\n    kid,\n  };\n};\n\n/** convert pem encoded private key to jwk */\nexport const privateKeyJwkFromPrivateKeyPem = (privateKeyPem: string) => {\n  const jwk = {\n    ...keyto.from(privateKeyPem, 'pem').toJwk('private'),\n    crv: 'secp256k1',\n  };\n  // console.log(jwk);\n  const kid = getKid(jwk);\n\n  return {\n    ...jwk,\n    kid,\n  };\n};\n\n/** convert pem encoded public key to jwk */\nexport const publicKeyJwkFromPublicKeyPem = (publicKeyPem: string) => {\n  const jwk = {\n    ...keyto.from(publicKeyPem, 'pem').toJwk('public'),\n    crv: 'secp256k1',\n  };\n  const kid = getKid(jwk);\n\n  return {\n    ...jwk,\n    kid,\n  };\n};\n\n/** convert jwk to hex encoded private key */\nexport const privateKeyHexFromJwk = (jwk: ISecp256k1PrivateKeyJwk) =>\n  keyto\n    .from(\n      {\n        ...jwk,\n        crv: 'K-256',\n      },\n      'jwk'\n    )\n    .toString('blk', 'private');\n\n/** convert jwk to hex encoded public key */\nexport const publicKeyHexFromJwk = (jwk: ISecp256k1PublicKeyJwk) => {\n  const uncompressedPublicKey = keyto\n    .from(\n      {\n        ...jwk,\n        crv: 'K-256',\n      },\n      'jwk'\n    )\n    .toString('blk', 'public');\n\n  const compressed = secp256k1.publicKeyConvert(\n    Buffer.from(uncompressedPublicKey, 'hex'),\n    true\n  );\n  return Buffer.from(compressed).toString('hex');\n};\n\n/** convert jwk to binary encoded private key */\nexport const privateKeyUInt8ArrayFromJwk = (jwk: ISecp256k1PrivateKeyJwk) => {\n  const privateKeyHex = privateKeyHexFromJwk(jwk);\n  return Buffer.from(privateKeyHex, 'hex');\n};\n\n/** convert jwk to binary encoded public key */\nexport const publicKeyUInt8ArrayFromJwk = (jwk: ISecp256k1PublicKeyJwk) => {\n  const publicKeyHex = publicKeyHexFromJwk(jwk);\n  return Buffer.from(publicKeyHex, 'hex');\n};\n\n/** convert publicKeyHex to base58 */\nexport const publicKeyBase58FromPublicKeyHex = (publicKeyHex: string) => {\n  return bs58.encode(Buffer.from(publicKeyHex, 'hex'));\n};\n\n/** convert publicKeyHex to base58 */\nexport const privateKeyBase58FromPrivateKeyHex = (privateKeyHex: string) => {\n  return bs58.encode(Buffer.from(privateKeyHex, 'hex'));\n};\n\nexport const privateKeyUInt8ArrayFromPrivateKeyBase58 = (\n  privateKeyBase58: string\n) => {\n  return bs58.decode(privateKeyBase58);\n};\n\nexport const publicKeyUInt8ArrayFromPublicKeyBase58 = (\n  publicKeyBase58: string\n) => {\n  return bs58.decode(publicKeyBase58);\n};\n\nexport const publicKeyHexFromPrivateKeyHex = (privateKeyHex: string) => {\n  const publicKey = secp256k1.publicKeyCreate(\n    new Uint8Array(Buffer.from(privateKeyHex, 'hex'))\n  );\n  return Buffer.from(publicKey).toString('hex');\n};\n","import base64url from 'base64url';\n\nimport crypto from 'crypto';\nimport secp256k1 from 'secp256k1';\n\nimport {\n  ISecp256k1PrivateKeyJwk,\n  ISecp256k1PublicKeyJwk,\n  privateKeyUInt8ArrayFromJwk,\n  publicKeyUInt8ArrayFromJwk,\n} from './keyUtils';\n\n/** error matching @panva/jose for JWS verification failure. */\nclass JWSVerificationFailed extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'JWSVerificationFailed';\n  }\n}\n\n/** JWS Header */\nexport interface IJWSHeader {\n  /** algorithm, ES256K */\n  alg: string;\n\n  /** type, JWT */\n  typ?: string;\n  /** signing key id, ... */\n  kid?: string;\n}\n\n/** Produce a JWS Unencoded Payload per https://tools.ietf.org/html/rfc7797#section-6 */\nexport const signDetached = async (\n  // in the case of EcdsaSecp256k1Signature2019 this is the result of createVerifyData\n  payload: Buffer,\n  privateKeyJwk: ISecp256k1PrivateKeyJwk,\n  header = {\n    alg: 'ES256K',\n    b64: false,\n    crit: ['b64'],\n  }\n) => {\n  const privateKeyUInt8Array = await privateKeyUInt8ArrayFromJwk(privateKeyJwk);\n\n  const encodedHeader = base64url.encode(JSON.stringify(header));\n\n  const toBeSignedBuffer = Buffer.concat([\n    Buffer.from(encodedHeader + '.', 'utf8'),\n    Buffer.from(payload.buffer, payload.byteOffset, payload.length),\n  ]);\n\n  const message = Buffer.from(toBeSignedBuffer);\n\n  const digest = crypto\n    .createHash('sha256')\n    .update(message)\n    .digest();\n\n  const messageHashUInt8Array = digest;\n  const sigObj: any = secp256k1.ecdsaSign(\n    messageHashUInt8Array,\n    privateKeyUInt8Array\n  );\n\n  const encodedSignature = base64url.encode(Buffer.from(sigObj.signature));\n\n  return `${encodedHeader}..${encodedSignature}`;\n};\n\n/** Verify a JWS Unencoded Payload per https://tools.ietf.org/html/rfc7797#section-6 */\nexport const verifyDetached = async (\n  jws: string,\n  payload: Buffer,\n  publicKeyJwk: ISecp256k1PublicKeyJwk\n) => {\n  if (jws.indexOf('..') === -1) {\n    throw new JWSVerificationFailed('not a valid rfc7797 jws.');\n  }\n  const [encodedHeader, encodedSignature] = jws.split('..');\n  const header = JSON.parse(base64url.decode(encodedHeader));\n  if (header.alg !== 'ES256K') {\n    throw new Error('JWS alg is not signed with ES256K.');\n  }\n  if (\n    header.b64 !== false ||\n    !header.crit ||\n    !header.crit.length ||\n    header.crit[0] !== 'b64'\n  ) {\n    throw new Error('JWS Header is not in rfc7797 format (not detached).');\n  }\n  const publicKeyUInt8Array = await publicKeyUInt8ArrayFromJwk(publicKeyJwk);\n  const toBeSignedBuffer = Buffer.concat([\n    Buffer.from(encodedHeader + '.', 'utf8'),\n    Buffer.from(payload.buffer, payload.byteOffset, payload.length),\n  ]);\n  const message = Buffer.from(toBeSignedBuffer);\n  const digest = crypto\n    .createHash('sha256')\n    .update(message)\n    .digest();\n\n  const messageHashUInt8Array = digest;\n  const signatureUInt8Array = base64url.toBuffer(encodedSignature);\n  let signatureLowerS = secp256k1.signatureNormalize(signatureUInt8Array);\n  const verified = secp256k1.ecdsaVerify(\n    signatureLowerS,\n    messageHashUInt8Array,\n    publicKeyUInt8Array\n  );\n\n  if (verified) {\n    return true;\n  }\n  const erroObject = {\n    signature: signatureUInt8Array.toString('hex'),\n    // message: messageHashUInt8Array.toString('hex'),\n    // publicKey: publicKeyUInt8Array.toString('hex'),\n  };\n  throw new JWSVerificationFailed(\n    'ECDSA Verify Failed: ' + JSON.stringify(erroObject, null, 2)\n  );\n};\n\n/** Produce a normal ES256K JWS */\nexport const sign = async (\n  payload: any,\n  privateKeyJwk: ISecp256k1PrivateKeyJwk,\n  header: IJWSHeader = { alg: 'ES256K' }\n) => {\n  const privateKeyUInt8Array = await privateKeyUInt8ArrayFromJwk(privateKeyJwk);\n\n  const encodedHeader = base64url.encode(JSON.stringify(header));\n  const encodedPayload = base64url.encode(JSON.stringify(payload));\n  const toBeSigned = `${encodedHeader}.${encodedPayload}`;\n  const message = Buffer.from(toBeSigned);\n\n  const digest = crypto\n    .createHash('sha256')\n    .update(message)\n    .digest();\n\n  const messageHashUInt8Array = digest;\n\n  const sigObj: any = secp256k1.ecdsaSign(\n    messageHashUInt8Array,\n    privateKeyUInt8Array\n  );\n\n  const encodedSignature = base64url.encode(sigObj.signature);\n  return `${encodedHeader}.${encodedPayload}.${encodedSignature}`;\n};\n\n/** Verify an ES256K JWS, returns the decoded object if successful, throws otherwise. */\nexport const verify = async (\n  jws: string,\n  publicKeyJwk: ISecp256k1PublicKeyJwk\n) => {\n  const publicKeyUInt8Array = await publicKeyUInt8ArrayFromJwk(publicKeyJwk);\n  const [encodedHeader, encodedPayload, encodedSignature] = jws.split('.');\n  const toBeSigned = `${encodedHeader}.${encodedPayload}`;\n\n  const message = Buffer.from(toBeSigned);\n  const digest = crypto\n    .createHash('sha256')\n    .update(message)\n    .digest();\n\n  const messageHashUInt8Array = digest;\n\n  const signatureUInt8Array = base64url.toBuffer(encodedSignature);\n  let signatureLowerS = secp256k1.signatureNormalize(signatureUInt8Array);\n\n  const verified = secp256k1.ecdsaVerify(\n    signatureLowerS,\n    messageHashUInt8Array,\n    publicKeyUInt8Array\n  );\n  if (verified) {\n    return JSON.parse(base64url.decode(encodedPayload));\n  }\n  const erroObject = {\n    signature: signatureUInt8Array.toString('hex'),\n    message: messageHashUInt8Array.toString('hex'),\n    publicKey: publicKeyUInt8Array.toString('hex'),\n  };\n  throw new JWSVerificationFailed(\n    'ECDSA Verify Failed: ' + JSON.stringify(erroObject, null, 2)\n  );\n};\n\n/** decode a JWS (without verifying it) */\nexport const decode = (jws: string, options = { complete: false }) => {\n  const [encodedHeader, encodedPayload, encodedSignature] = jws.split('.');\n\n  if (options.complete) {\n    return {\n      header: JSON.parse(base64url.decode(encodedHeader)),\n      payload: JSON.parse(base64url.decode(encodedPayload)),\n      signature: encodedSignature,\n    };\n  }\n  return JSON.parse(base64url.decode(encodedPayload));\n};\n","import crypto from 'crypto';\n\nimport * as keyUtils from './keyUtils';\nimport bs58 from 'bs58';\nimport secp256k1 from 'secp256k1';\n\nimport * as common from '@transmute/did-key-common';\n\nconst _generate = (secureRandom: any) => {\n  let privateKey;\n  do {\n    privateKey = secureRandom();\n  } while (!secp256k1.privateKeyVerify(privateKey));\n\n  const publicKey = secp256k1.publicKeyCreate(privateKey);\n  return { publicKey, privateKey };\n};\n\n@common.types.staticImplements<common.types.KeyPairClass>()\nexport class Secp256k1KeyPair {\n  public id: string;\n  public type: string;\n  public controller: string;\n\n  public publicKeyBuffer: Buffer;\n  public privateKeyBuffer?: Buffer;\n\n  static fingerprintFromPublicKey(\n    keypair: common.types.KeyPairJwk | common.types.KeyPairBase58\n  ) {\n    let pubkeyBytes: any;\n\n    if ((keypair as any).publicKeyBase58) {\n      pubkeyBytes = bs58.decode(\n        (keypair as common.types.KeyPairBase58).publicKeyBase58\n      );\n    }\n\n    if ((keypair as any).publicKeyJwk) {\n      pubkeyBytes = new Uint8Array(\n        Buffer.from(\n          keyUtils.publicKeyHexFromJwk(\n            (keypair as common.types.KeyPairJwk).publicKeyJwk\n          )\n        )\n      );\n    }\n\n    const buffer = new Uint8Array(2 + pubkeyBytes.length);\n    // See https://github.com/multiformats/multicodec/blob/master/table.csv\n    // 0xe7 is Secp256k1 public key\n    buffer[0] = 0xe7; //\n    buffer[1] = 0x01;\n    buffer.set(pubkeyBytes, 2);\n    // prefix with `z` to indicate multi-base base58btc encoding\n    return `z${bs58.encode(buffer)}`;\n  }\n\n  static async generate(options: any = {}) {\n    let privateKey;\n    let publicKey;\n    if (options.secureRandom) {\n      ({ privateKey, publicKey } = _generate(options.secureRandom));\n    }\n\n    if (!privateKey) {\n      throw new Error('Cannot generate private key.');\n    }\n\n    const publicKeyBase58 = keyUtils.publicKeyBase58FromPublicKeyHex(\n      Buffer.from(publicKey).toString('hex')\n    );\n    const privateKeyBase58 = keyUtils.privateKeyBase58FromPrivateKeyHex(\n      Buffer.from(privateKey).toString('hex')\n    );\n\n    const did = `did:key:${Secp256k1KeyPair.fingerprintFromPublicKey({\n      publicKeyBase58,\n    } as any)}`;\n    const keyId = `#${Secp256k1KeyPair.fingerprintFromPublicKey({\n      publicKeyBase58,\n    } as any)}`;\n\n    return new Secp256k1KeyPair({\n      id: keyId,\n      controller: did,\n      publicKeyBase58,\n      privateKeyBase58,\n    });\n  }\n\n  static async from(options: any) {\n    let privateKeyBase58 = options.privateKeyBase58;\n    let publicKeyBase58 = options.publicKeyBase58;\n\n    if (options.privateKeyHex) {\n      privateKeyBase58 = await keyUtils.privateKeyBase58FromPrivateKeyHex(\n        options.privateKeyHex\n      );\n    }\n\n    if (options.publicKeyHex) {\n      publicKeyBase58 = await keyUtils.publicKeyBase58FromPublicKeyHex(\n        options.publicKeyHex\n      );\n    }\n\n    if (options.privateKeyJwk) {\n      privateKeyBase58 = keyUtils.privateKeyBase58FromPrivateKeyHex(\n        await keyUtils.privateKeyHexFromJwk(options.privateKeyJwk)\n      );\n    }\n\n    if (options.publicKeyJwk) {\n      publicKeyBase58 = keyUtils.privateKeyBase58FromPrivateKeyHex(\n        await keyUtils.publicKeyHexFromJwk(options.publicKeyJwk)\n      );\n    }\n\n    return new Secp256k1KeyPair({\n      ...options,\n      privateKeyBase58,\n      publicKeyBase58,\n    });\n  }\n\n  static fromFingerprint({ fingerprint }: any) {\n    // skip leading `z` that indicates base58 encoding\n    const buffer = bs58.decode(fingerprint.substr(1));\n\n    // https://github.com/multiformats/multicodec/blob/master/table.csv#L77\n    if (buffer[0] === 0xe7 && buffer[1] === 0x01) {\n      const publicKeyBase58 = bs58.encode(buffer.slice(2));\n      const did = `did:key:${Secp256k1KeyPair.fingerprintFromPublicKey({\n        publicKeyBase58,\n      } as any)}`;\n      const keyId = `#${Secp256k1KeyPair.fingerprintFromPublicKey({\n        publicKeyBase58,\n      } as any)}`;\n      return new Secp256k1KeyPair({\n        id: keyId,\n        controller: did,\n        publicKeyBase58,\n      });\n    }\n\n    throw new Error(`Unsupported Fingerprint Type: ${fingerprint}`);\n  }\n\n  constructor(options: any = {}) {\n    this.type = 'EcdsaSecp256k1VerificationKey2019';\n    this.id = options.id;\n    this.controller = options.controller;\n\n    if (options.publicKeyBase58) {\n      this.publicKeyBuffer = bs58.decode(options.publicKeyBase58);\n    } else if (options.publicKeyJwk) {\n      this.publicKeyBuffer = Buffer.from(\n        keyUtils.publicKeyHexFromJwk(options.publicKeyJwk),\n        'hex'\n      );\n    } else {\n      throw new Error(\n        'Secp256k1KeyPair requires publicKeyBase58 or publicKeyJwk, recieved neither.'\n      );\n    }\n\n    if (options.privateKeyBase58) {\n      this.privateKeyBuffer = bs58.decode(options.privateKeyBase58);\n    }\n\n    if (options.privateKeyJwk) {\n      this.privateKeyBuffer = Buffer.from(\n        keyUtils.privateKeyHexFromJwk(options.privateKeyJwk),\n        'hex'\n      );\n    }\n\n    if (this.controller && !this.id) {\n      this.id = `${this.controller}#${this.fingerprint()}`;\n    }\n  }\n\n  publicNode() {\n    return this.toKeyPair(false);\n  }\n\n  signer() {\n    if (!this.privateKeyBuffer) {\n      throw new Error('No private key to sign with.');\n    }\n    let { privateKeyBuffer } = this;\n    return {\n      async sign({ data }: any) {\n        const messageHashUInt8Array = crypto\n          .createHash('sha256')\n          .update(data)\n          .digest();\n\n        const sigObj: any = secp256k1.ecdsaSign(\n          messageHashUInt8Array,\n          new Uint8Array(privateKeyBuffer)\n        );\n\n        return sigObj.signature;\n      },\n    };\n  }\n\n  verifier() {\n    if (!this.publicKeyBuffer) {\n      throw new Error('No public key to verify with.');\n    }\n    let { publicKeyBuffer } = this;\n    return {\n      async verify({ data, signature }: any) {\n        const messageHashUInt8Array = crypto\n          .createHash('sha256')\n          .update(data)\n          .digest();\n\n        let verified = false;\n        try {\n          verified = secp256k1.ecdsaVerify(\n            signature,\n            messageHashUInt8Array,\n            new Uint8Array(publicKeyBuffer)\n          );\n        } catch (e) {\n          console.error('An error occurred when verifying signature: ', e);\n        }\n        return verified;\n      },\n    };\n  }\n\n  fingerprint() {\n    return Secp256k1KeyPair.fingerprintFromPublicKey({\n      publicKeyBase58: bs58.encode(this.publicKeyBuffer),\n    } as any);\n  }\n\n  verifyFingerprint(fingerprint: string) {\n    // fingerprint should have `z` prefix indicating\n    // that it's multi-base encoded\n    if (!(typeof fingerprint === 'string' && fingerprint[0] === 'z')) {\n      return {\n        error: new Error('`fingerprint` must be a multibase encoded string.'),\n        valid: false,\n      };\n    }\n    let fingerprintBuffer;\n    try {\n      fingerprintBuffer = bs58.decode(fingerprint.slice(1));\n    } catch (e) {\n      return { error: e, valid: false };\n    }\n    let { publicKeyBuffer } = this;\n\n    // validate the first two multicodec bytes 0xe701\n    const valid =\n      fingerprintBuffer.slice(0, 2).toString('hex') === 'e701' &&\n      publicKeyBuffer.equals(fingerprintBuffer.slice(2));\n    if (!valid) {\n      return {\n        error: new Error('The fingerprint does not match the public key.'),\n        valid: false,\n      };\n    }\n    return { valid };\n  }\n\n  toJwk(_private: boolean = false) {\n    if (_private) {\n      if (!this.privateKeyBuffer) {\n        throw new Error('No private key to export');\n      }\n      return keyUtils.privateKeyJwkFromPrivateKeyHex(\n        this.privateKeyBuffer.toString('hex')\n      );\n    }\n    return keyUtils.publicKeyJwkFromPublicKeyHex(\n      this.publicKeyBuffer.toString('hex')\n    );\n  }\n\n  async toHex(_private: boolean = false) {\n    if (_private) {\n      if (!this.privateKeyBuffer) {\n        throw new Error('No private key to export');\n      }\n      return keyUtils.privateKeyHexFromJwk(\n        await keyUtils.privateKeyJwkFromPrivateKeyHex(\n          this.privateKeyBuffer.toString('hex')\n        )\n      );\n    }\n    return keyUtils.publicKeyHexFromJwk(\n      await keyUtils.publicKeyJwkFromPublicKeyHex(\n        this.publicKeyBuffer.toString('hex')\n      )\n    );\n  }\n\n  toKeyPair(exportPrivate = false) {\n    const kp: any = {\n      id: this.id,\n      type: this.type,\n      controller: this.controller,\n      publicKeyBase58: bs58.encode(this.publicKeyBuffer),\n    };\n    if (exportPrivate) {\n      kp.privateKeyBase58 = bs58.encode(this.privateKeyBuffer);\n    }\n    return kp;\n  }\n\n  toJsonWebKeyPair(exportPrivate: boolean = false): any {\n    let kp: any = {\n      id: this.id,\n      type: 'JsonWebKey2020',\n      controller: this.controller,\n      publicKeyJwk: this.toJwk(),\n    };\n    delete kp.publicKeyJwk.kid;\n    if (exportPrivate) {\n      kp.privateKeyJwk = this.toJwk(true);\n      delete kp.privateKeyJwk.kid;\n    }\n\n    return kp;\n  }\n}\n","import { Secp256k1KeyPair } from './Secp256k1KeyPair';\nimport { getResolve, getGet } from '@transmute/did-key-common';\n\nexport const resolve = getResolve(Secp256k1KeyPair);\nexport const get = getGet(resolve);\n"],"names":["getKid","jwk","copy","d","kid","alg","digest","crypto","createHash","update","canonicalize","base64url","encode","Buffer","from","privateKeyJwkFromPrivateKeyHex","privateKeyHex","keyto","toJwk","crv","publicKeyJwkFromPublicKeyHex","publicKeyHex","key","length","keyBin","secp256k1","publicKeyConvert","toString","privateKeyHexFromJwk","publicKeyHexFromJwk","uncompressedPublicKey","compressed","privateKeyUInt8ArrayFromJwk","publicKeyUInt8ArrayFromJwk","publicKeyBase58FromPublicKeyHex","bs58","privateKeyBase58FromPrivateKeyHex","privateKeyPem","publicKeyPem","privateKeyBase58","decode","publicKeyBase58","publicKey","publicKeyCreate","Uint8Array","JWSVerificationFailed","message","name","Error","payload","privateKeyJwk","header","b64","crit","privateKeyUInt8Array","encodedHeader","JSON","stringify","toBeSignedBuffer","concat","buffer","byteOffset","sigObj","ecdsaSign","signature","jws","publicKeyJwk","indexOf","split","encodedSignature","parse","publicKeyUInt8Array","messageHashUInt8Array","signatureUInt8Array","toBuffer","signatureLowerS","signatureNormalize","ecdsaVerify","erroObject","encodedPayload","options","complete","Secp256k1KeyPair","type","id","controller","publicKeyBuffer","keyUtils","privateKeyBuffer","this","fingerprint","fingerprintFromPublicKey","keypair","pubkeyBytes","set","generate","privateKey","secureRandom","privateKeyVerify","_generate","did","Secp256k1KeyPair_1","keyId","fromFingerprint","substr","slice","publicNode","toKeyPair","signer","sign","data","verifier","verify","verified","e","console","error","verifyFingerprint","valid","fingerprintBuffer","equals","_private","toHex","_this2","exportPrivate","kp","toJsonWebKeyPair","common","staticImplements","resolve","getResolve","getGet"],"mappings":"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"}