'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var keyto = _interopDefault(require('@trust/keyto'));
var base64url = _interopDefault(require('base64url'));
var crypto = _interopDefault(require('crypto'));
var bs58 = _interopDefault(require('bs58'));
var secp256k1 = _interopDefault(require('secp256k1'));
var canonicalize = _interopDefault(require('canonicalize'));
var tslib = require('tslib');
var common = require('@transmute/did-key-common');

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}

var compressedHexEncodedPublicKeyLength = 66;
/**
 * Example
 * ```js
 * {
 *  kty: 'EC',
 *  crv: 'secp256k1',
 *  d: 'rhYFsBPF9q3-uZThy7B3c4LDF_8wnozFUAEm5LLC4Zw',
 *  x: 'dWCvM4fTdeM0KmloF57zxtBPXTOythHPMm1HCLrdd3A',
 *  y: '36uMVGM7hnw-N6GnjFcihWE3SkrhMLzzLCdPMXPEXlA',
 *  kid: 'JUvpllMEYUZ2joO59UNui_XYDqxVqiFLLAJ8klWuPBw'
 * }
 * ```
 * See [rfc7638](https://tools.ietf.org/html/rfc7638) for more details on Jwk.
 */

var getKid = function getKid(jwk) {
  var copy = _extends({}, jwk);

  delete copy.d;
  delete copy.kid;
  delete copy.alg;
  var digest = crypto.createHash('sha256').update(canonicalize(copy)).digest();
  return base64url.encode(Buffer.from(digest));
};
/** convert compressed hex encoded private key to jwk */

var privateKeyJwkFromPrivateKeyHex = function privateKeyJwkFromPrivateKeyHex(privateKeyHex) {
  var jwk = _extends({}, keyto.from(privateKeyHex, 'blk').toJwk('private'), {
    crv: 'secp256k1'
  });

  var kid = getKid(jwk);
  return _extends({}, jwk, {
    kid: kid
  });
};
/** convert compressed hex encoded public key to jwk */

var publicKeyJwkFromPublicKeyHex = function publicKeyJwkFromPublicKeyHex(publicKeyHex) {
  var key = publicKeyHex;

  if (publicKeyHex.length === compressedHexEncodedPublicKeyLength) {
    var keyBin = secp256k1.publicKeyConvert(Buffer.from(publicKeyHex, 'hex'), false);
    key = Buffer.from(keyBin).toString('hex');
  }

  var jwk = _extends({}, keyto.from(key, 'blk').toJwk('public'), {
    crv: 'secp256k1'
  });

  var kid = getKid(jwk);
  return _extends({}, jwk, {
    kid: kid
  });
};
/** convert pem encoded private key to jwk */

var privateKeyJwkFromPrivateKeyPem = function privateKeyJwkFromPrivateKeyPem(privateKeyPem) {
  var jwk = _extends({}, keyto.from(privateKeyPem, 'pem').toJwk('private'), {
    crv: 'secp256k1'
  }); // console.log(jwk);


  var kid = getKid(jwk);
  return _extends({}, jwk, {
    kid: kid
  });
};
/** convert pem encoded public key to jwk */

var publicKeyJwkFromPublicKeyPem = function publicKeyJwkFromPublicKeyPem(publicKeyPem) {
  var jwk = _extends({}, keyto.from(publicKeyPem, 'pem').toJwk('public'), {
    crv: 'secp256k1'
  });

  var kid = getKid(jwk);
  return _extends({}, jwk, {
    kid: kid
  });
};
/** convert jwk to hex encoded private key */

var privateKeyHexFromJwk = function privateKeyHexFromJwk(jwk) {
  return keyto.from(_extends({}, jwk, {
    crv: 'K-256'
  }), 'jwk').toString('blk', 'private');
};
/** convert jwk to hex encoded public key */

var publicKeyHexFromJwk = function publicKeyHexFromJwk(jwk) {
  var uncompressedPublicKey = keyto.from(_extends({}, jwk, {
    crv: 'K-256'
  }), 'jwk').toString('blk', 'public');
  var compressed = secp256k1.publicKeyConvert(Buffer.from(uncompressedPublicKey, 'hex'), true);
  return Buffer.from(compressed).toString('hex');
};
/** convert jwk to binary encoded private key */

var privateKeyUInt8ArrayFromJwk = function privateKeyUInt8ArrayFromJwk(jwk) {
  var privateKeyHex = privateKeyHexFromJwk(jwk);
  return Buffer.from(privateKeyHex, 'hex');
};
/** convert jwk to binary encoded public key */

var publicKeyUInt8ArrayFromJwk = function publicKeyUInt8ArrayFromJwk(jwk) {
  var publicKeyHex = publicKeyHexFromJwk(jwk);
  return Buffer.from(publicKeyHex, 'hex');
};
/** convert publicKeyHex to base58 */

var publicKeyBase58FromPublicKeyHex = function publicKeyBase58FromPublicKeyHex(publicKeyHex) {
  return bs58.encode(Buffer.from(publicKeyHex, 'hex'));
};
/** convert publicKeyHex to base58 */

var privateKeyBase58FromPrivateKeyHex = function privateKeyBase58FromPrivateKeyHex(privateKeyHex) {
  return bs58.encode(Buffer.from(privateKeyHex, 'hex'));
};
var privateKeyUInt8ArrayFromPrivateKeyBase58 = function privateKeyUInt8ArrayFromPrivateKeyBase58(privateKeyBase58) {
  return bs58.decode(privateKeyBase58);
};
var publicKeyUInt8ArrayFromPublicKeyBase58 = function publicKeyUInt8ArrayFromPublicKeyBase58(publicKeyBase58) {
  return bs58.decode(publicKeyBase58);
};
var publicKeyHexFromPrivateKeyHex = function publicKeyHexFromPrivateKeyHex(privateKeyHex) {
  var publicKey = secp256k1.publicKeyCreate(new Uint8Array(Buffer.from(privateKeyHex, 'hex')));
  return Buffer.from(publicKey).toString('hex');
};

var keyUtils = {
  __proto__: null,
  getKid: getKid,
  privateKeyJwkFromPrivateKeyHex: privateKeyJwkFromPrivateKeyHex,
  publicKeyJwkFromPublicKeyHex: publicKeyJwkFromPublicKeyHex,
  privateKeyJwkFromPrivateKeyPem: privateKeyJwkFromPrivateKeyPem,
  publicKeyJwkFromPublicKeyPem: publicKeyJwkFromPublicKeyPem,
  privateKeyHexFromJwk: privateKeyHexFromJwk,
  publicKeyHexFromJwk: publicKeyHexFromJwk,
  privateKeyUInt8ArrayFromJwk: privateKeyUInt8ArrayFromJwk,
  publicKeyUInt8ArrayFromJwk: publicKeyUInt8ArrayFromJwk,
  publicKeyBase58FromPublicKeyHex: publicKeyBase58FromPublicKeyHex,
  privateKeyBase58FromPrivateKeyHex: privateKeyBase58FromPrivateKeyHex,
  privateKeyUInt8ArrayFromPrivateKeyBase58: privateKeyUInt8ArrayFromPrivateKeyBase58,
  publicKeyUInt8ArrayFromPublicKeyBase58: publicKeyUInt8ArrayFromPublicKeyBase58,
  publicKeyHexFromPrivateKeyHex: publicKeyHexFromPrivateKeyHex
};

/** error matching @panva/jose for JWS verification failure. */

var JWSVerificationFailed = /*#__PURE__*/function (_Error) {
  _inheritsLoose(JWSVerificationFailed, _Error);

  function JWSVerificationFailed(message) {
    var _this;

    _this = _Error.call(this, message) || this;
    _this.name = 'JWSVerificationFailed';
    return _this;
  }

  return JWSVerificationFailed;
}( /*#__PURE__*/_wrapNativeSuper(Error));
/** Produce a JWS Unencoded Payload per https://tools.ietf.org/html/rfc7797#section-6 */


var signDetached = function signDetached( // in the case of EcdsaSecp256k1Signature2019 this is the result of createVerifyData
payload, privateKeyJwk, header) {
  if (header === void 0) {
    header = {
      alg: 'ES256K',
      b64: false,
      crit: ['b64']
    };
  }

  try {
    return Promise.resolve(privateKeyUInt8ArrayFromJwk(privateKeyJwk)).then(function (privateKeyUInt8Array) {
      var encodedHeader = base64url.encode(JSON.stringify(header));
      var toBeSignedBuffer = Buffer.concat([Buffer.from(encodedHeader + '.', 'utf8'), Buffer.from(payload.buffer, payload.byteOffset, payload.length)]);
      var message = Buffer.from(toBeSignedBuffer);
      var digest = crypto.createHash('sha256').update(message).digest();
      var messageHashUInt8Array = digest;
      var sigObj = secp256k1.ecdsaSign(messageHashUInt8Array, privateKeyUInt8Array);
      var encodedSignature = base64url.encode(Buffer.from(sigObj.signature));
      return encodedHeader + ".." + encodedSignature;
    });
  } catch (e) {
    return Promise.reject(e);
  }
};
/** Verify a JWS Unencoded Payload per https://tools.ietf.org/html/rfc7797#section-6 */

var verifyDetached = function verifyDetached(jws, payload, publicKeyJwk) {
  try {
    if (jws.indexOf('..') === -1) {
      throw new JWSVerificationFailed('not a valid rfc7797 jws.');
    }

    var _jws$split = jws.split('..'),
        encodedHeader = _jws$split[0],
        encodedSignature = _jws$split[1];

    var header = JSON.parse(base64url.decode(encodedHeader));

    if (header.alg !== 'ES256K') {
      throw new Error('JWS alg is not signed with ES256K.');
    }

    if (header.b64 !== false || !header.crit || !header.crit.length || header.crit[0] !== 'b64') {
      throw new Error('JWS Header is not in rfc7797 format (not detached).');
    }

    return Promise.resolve(publicKeyUInt8ArrayFromJwk(publicKeyJwk)).then(function (publicKeyUInt8Array) {
      var toBeSignedBuffer = Buffer.concat([Buffer.from(encodedHeader + '.', 'utf8'), Buffer.from(payload.buffer, payload.byteOffset, payload.length)]);
      var message = Buffer.from(toBeSignedBuffer);
      var digest = crypto.createHash('sha256').update(message).digest();
      var messageHashUInt8Array = digest;
      var signatureUInt8Array = base64url.toBuffer(encodedSignature);
      var signatureLowerS = secp256k1.signatureNormalize(signatureUInt8Array);
      var verified = secp256k1.ecdsaVerify(signatureLowerS, messageHashUInt8Array, publicKeyUInt8Array);

      if (verified) {
        return true;
      }

      var erroObject = {
        signature: signatureUInt8Array.toString('hex')
      };
      throw new JWSVerificationFailed('ECDSA Verify Failed: ' + JSON.stringify(erroObject, null, 2));
    });
  } catch (e) {
    return Promise.reject(e);
  }
};
/** Produce a normal ES256K JWS */

var sign = function sign(payload, privateKeyJwk, header) {
  if (header === void 0) {
    header = {
      alg: 'ES256K'
    };
  }

  try {
    return Promise.resolve(privateKeyUInt8ArrayFromJwk(privateKeyJwk)).then(function (privateKeyUInt8Array) {
      var encodedHeader = base64url.encode(JSON.stringify(header));
      var encodedPayload = base64url.encode(JSON.stringify(payload));
      var toBeSigned = encodedHeader + "." + encodedPayload;
      var message = Buffer.from(toBeSigned);
      var digest = crypto.createHash('sha256').update(message).digest();
      var messageHashUInt8Array = digest;
      var sigObj = secp256k1.ecdsaSign(messageHashUInt8Array, privateKeyUInt8Array);
      var encodedSignature = base64url.encode(sigObj.signature);
      return encodedHeader + "." + encodedPayload + "." + encodedSignature;
    });
  } catch (e) {
    return Promise.reject(e);
  }
};
/** Verify an ES256K JWS, returns the decoded object if successful, throws otherwise. */

var verify = function verify(jws, publicKeyJwk) {
  try {
    return Promise.resolve(publicKeyUInt8ArrayFromJwk(publicKeyJwk)).then(function (publicKeyUInt8Array) {
      var _jws$split2 = jws.split('.'),
          encodedHeader = _jws$split2[0],
          encodedPayload = _jws$split2[1],
          encodedSignature = _jws$split2[2];

      var toBeSigned = encodedHeader + "." + encodedPayload;
      var message = Buffer.from(toBeSigned);
      var digest = crypto.createHash('sha256').update(message).digest();
      var messageHashUInt8Array = digest;
      var signatureUInt8Array = base64url.toBuffer(encodedSignature);
      var signatureLowerS = secp256k1.signatureNormalize(signatureUInt8Array);
      var verified = secp256k1.ecdsaVerify(signatureLowerS, messageHashUInt8Array, publicKeyUInt8Array);

      if (verified) {
        return JSON.parse(base64url.decode(encodedPayload));
      }

      var erroObject = {
        signature: signatureUInt8Array.toString('hex'),
        message: messageHashUInt8Array.toString('hex'),
        publicKey: publicKeyUInt8Array.toString('hex')
      };
      throw new JWSVerificationFailed('ECDSA Verify Failed: ' + JSON.stringify(erroObject, null, 2));
    });
  } catch (e) {
    return Promise.reject(e);
  }
};
/** decode a JWS (without verifying it) */

var decode = function decode(jws, options) {
  if (options === void 0) {
    options = {
      complete: false
    };
  }

  var _jws$split3 = jws.split('.'),
      encodedHeader = _jws$split3[0],
      encodedPayload = _jws$split3[1],
      encodedSignature = _jws$split3[2];

  if (options.complete) {
    return {
      header: JSON.parse(base64url.decode(encodedHeader)),
      payload: JSON.parse(base64url.decode(encodedPayload)),
      signature: encodedSignature
    };
  }

  return JSON.parse(base64url.decode(encodedPayload));
};

var ES256K = {
  __proto__: null,
  signDetached: signDetached,
  verifyDetached: verifyDetached,
  sign: sign,
  verify: verify,
  decode: decode
};

var Secp256k1KeyPair_1;

var _generate = function _generate(secureRandom) {
  var privateKey;

  do {
    privateKey = secureRandom();
  } while (!secp256k1.privateKeyVerify(privateKey));

  var publicKey = secp256k1.publicKeyCreate(privateKey);
  return {
    publicKey: publicKey,
    privateKey: privateKey
  };
};

exports.Secp256k1KeyPair = Secp256k1KeyPair_1 = /*#__PURE__*/function () {
  function Secp256k1KeyPair(options) {
    if (options === void 0) {
      options = {};
    }

    this.type = 'EcdsaSecp256k1VerificationKey2019';
    this.id = options.id;
    this.controller = options.controller;

    if (options.publicKeyBase58) {
      this.publicKeyBuffer = bs58.decode(options.publicKeyBase58);
    } else if (options.publicKeyJwk) {
      this.publicKeyBuffer = Buffer.from(publicKeyHexFromJwk(options.publicKeyJwk), 'hex');
    } else {
      throw new Error('Secp256k1KeyPair requires publicKeyBase58 or publicKeyJwk, recieved neither.');
    }

    if (options.privateKeyBase58) {
      this.privateKeyBuffer = bs58.decode(options.privateKeyBase58);
    }

    if (options.privateKeyJwk) {
      this.privateKeyBuffer = Buffer.from(privateKeyHexFromJwk(options.privateKeyJwk), 'hex');
    }

    if (this.controller && !this.id) {
      this.id = this.controller + "#" + this.fingerprint();
    }
  }

  Secp256k1KeyPair.fingerprintFromPublicKey = function fingerprintFromPublicKey(keypair) {
    var pubkeyBytes;

    if (keypair.publicKeyBase58) {
      pubkeyBytes = bs58.decode(keypair.publicKeyBase58);
    }

    if (keypair.publicKeyJwk) {
      pubkeyBytes = new Uint8Array(Buffer.from(publicKeyHexFromJwk(keypair.publicKeyJwk)));
    }

    var buffer = new Uint8Array(2 + pubkeyBytes.length); // See https://github.com/multiformats/multicodec/blob/master/table.csv
    // 0xe7 is Secp256k1 public key

    buffer[0] = 0xe7; //

    buffer[1] = 0x01;
    buffer.set(pubkeyBytes, 2); // prefix with `z` to indicate multi-base base58btc encoding

    return "z" + bs58.encode(buffer);
  };

  Secp256k1KeyPair.generate = function generate(options) {
    if (options === void 0) {
      options = {};
    }

    try {
      var privateKey;
      var publicKey;

      if (options.secureRandom) {
        var _generate2 = _generate(options.secureRandom);

        privateKey = _generate2.privateKey;
        publicKey = _generate2.publicKey;
      }

      if (!privateKey) {
        throw new Error('Cannot generate private key.');
      }

      var publicKeyBase58 = publicKeyBase58FromPublicKeyHex(Buffer.from(publicKey).toString('hex'));
      var privateKeyBase58 = privateKeyBase58FromPrivateKeyHex(Buffer.from(privateKey).toString('hex'));
      var did = "did:key:" + Secp256k1KeyPair_1.fingerprintFromPublicKey({
        publicKeyBase58: publicKeyBase58
      });
      var keyId = "#" + Secp256k1KeyPair_1.fingerprintFromPublicKey({
        publicKeyBase58: publicKeyBase58
      });
      return Promise.resolve(new Secp256k1KeyPair_1({
        id: keyId,
        controller: did,
        publicKeyBase58: publicKeyBase58,
        privateKeyBase58: privateKeyBase58
      }));
    } catch (e) {
      return Promise.reject(e);
    }
  };

  Secp256k1KeyPair.from = function from(options) {
    try {
      var _temp9 = function _temp9() {
        function _temp6() {
          function _temp4() {
            function _temp2() {
              return new Secp256k1KeyPair_1(_extends({}, options, {
                privateKeyBase58: privateKeyBase58,
                publicKeyBase58: publicKeyBase58
              }));
            }

            var _temp = function () {
              if (options.publicKeyJwk) {
                var _privateKeyBase58From3 = privateKeyBase58FromPrivateKeyHex;
                return Promise.resolve(publicKeyHexFromJwk(options.publicKeyJwk)).then(function (_keyUtils$publicKeyHe) {
                  publicKeyBase58 = _privateKeyBase58From3.call(keyUtils, _keyUtils$publicKeyHe);
                });
              }
            }();

            return _temp && _temp.then ? _temp.then(_temp2) : _temp2(_temp);
          }

          var _temp3 = function () {
            if (options.privateKeyJwk) {
              var _privateKeyBase58From4 = privateKeyBase58FromPrivateKeyHex;
              return Promise.resolve(privateKeyHexFromJwk(options.privateKeyJwk)).then(function (_keyUtils$privateKeyH) {
                privateKeyBase58 = _privateKeyBase58From4.call(keyUtils, _keyUtils$privateKeyH);
              });
            }
          }();

          return _temp3 && _temp3.then ? _temp3.then(_temp4) : _temp4(_temp3);
        }

        var _temp5 = function () {
          if (options.publicKeyHex) {
            return Promise.resolve(publicKeyBase58FromPublicKeyHex(options.publicKeyHex)).then(function (_keyUtils$publicKeyBa) {
              publicKeyBase58 = _keyUtils$publicKeyBa;
            });
          }
        }();

        return _temp5 && _temp5.then ? _temp5.then(_temp6) : _temp6(_temp5);
      };

      var privateKeyBase58 = options.privateKeyBase58;
      var publicKeyBase58 = options.publicKeyBase58;

      var _temp10 = function () {
        if (options.privateKeyHex) {
          return Promise.resolve(privateKeyBase58FromPrivateKeyHex(options.privateKeyHex)).then(function (_keyUtils$privateKeyB) {
            privateKeyBase58 = _keyUtils$privateKeyB;
          });
        }
      }();

      return Promise.resolve(_temp10 && _temp10.then ? _temp10.then(_temp9) : _temp9(_temp10));
    } catch (e) {
      return Promise.reject(e);
    }
  };

  Secp256k1KeyPair.fromFingerprint = function fromFingerprint(_ref) {
    var fingerprint = _ref.fingerprint;
    // skip leading `z` that indicates base58 encoding
    var buffer = bs58.decode(fingerprint.substr(1)); // https://github.com/multiformats/multicodec/blob/master/table.csv#L77

    if (buffer[0] === 0xe7 && buffer[1] === 0x01) {
      var publicKeyBase58 = bs58.encode(buffer.slice(2));
      var did = "did:key:" + Secp256k1KeyPair_1.fingerprintFromPublicKey({
        publicKeyBase58: publicKeyBase58
      });
      var keyId = "#" + Secp256k1KeyPair_1.fingerprintFromPublicKey({
        publicKeyBase58: publicKeyBase58
      });
      return new Secp256k1KeyPair_1({
        id: keyId,
        controller: did,
        publicKeyBase58: publicKeyBase58
      });
    }

    throw new Error("Unsupported Fingerprint Type: " + fingerprint);
  };

  var _proto = Secp256k1KeyPair.prototype;

  _proto.publicNode = function publicNode() {
    return this.toKeyPair(false);
  };

  _proto.signer = function signer() {
    if (!this.privateKeyBuffer) {
      throw new Error('No private key to sign with.');
    }

    var privateKeyBuffer = this.privateKeyBuffer;
    return {
      sign: function sign(_ref2) {
        var data = _ref2.data;

        try {
          var messageHashUInt8Array = crypto.createHash('sha256').update(data).digest();
          var sigObj = secp256k1.ecdsaSign(messageHashUInt8Array, new Uint8Array(privateKeyBuffer));
          return Promise.resolve(sigObj.signature);
        } catch (e) {
          return Promise.reject(e);
        }
      }
    };
  };

  _proto.verifier = function verifier() {
    if (!this.publicKeyBuffer) {
      throw new Error('No public key to verify with.');
    }

    var publicKeyBuffer = this.publicKeyBuffer;
    return {
      verify: function verify(_ref3) {
        var data = _ref3.data,
            signature = _ref3.signature;

        try {
          var messageHashUInt8Array = crypto.createHash('sha256').update(data).digest();
          var verified = false;

          try {
            verified = secp256k1.ecdsaVerify(signature, messageHashUInt8Array, new Uint8Array(publicKeyBuffer));
          } catch (e) {
            console.error('An error occurred when verifying signature: ', e);
          }

          return Promise.resolve(verified);
        } catch (e) {
          return Promise.reject(e);
        }
      }
    };
  };

  _proto.fingerprint = function fingerprint() {
    return Secp256k1KeyPair_1.fingerprintFromPublicKey({
      publicKeyBase58: bs58.encode(this.publicKeyBuffer)
    });
  };

  _proto.verifyFingerprint = function verifyFingerprint(fingerprint) {
    // fingerprint should have `z` prefix indicating
    // that it's multi-base encoded
    if (!(typeof fingerprint === 'string' && fingerprint[0] === 'z')) {
      return {
        error: new Error('`fingerprint` must be a multibase encoded string.'),
        valid: false
      };
    }

    var fingerprintBuffer;

    try {
      fingerprintBuffer = bs58.decode(fingerprint.slice(1));
    } catch (e) {
      return {
        error: e,
        valid: false
      };
    }

    var publicKeyBuffer = this.publicKeyBuffer; // validate the first two multicodec bytes 0xe701

    var valid = fingerprintBuffer.slice(0, 2).toString('hex') === 'e701' && publicKeyBuffer.equals(fingerprintBuffer.slice(2));

    if (!valid) {
      return {
        error: new Error('The fingerprint does not match the public key.'),
        valid: false
      };
    }

    return {
      valid: valid
    };
  };

  _proto.toJwk = function toJwk(_private) {
    if (_private === void 0) {
      _private = false;
    }

    if (_private) {
      if (!this.privateKeyBuffer) {
        throw new Error('No private key to export');
      }

      return privateKeyJwkFromPrivateKeyHex(this.privateKeyBuffer.toString('hex'));
    }

    return publicKeyJwkFromPublicKeyHex(this.publicKeyBuffer.toString('hex'));
  };

  _proto.toHex = function toHex(_private) {
    if (_private === void 0) {
      _private = false;
    }

    try {
      var _temp13 = function _temp13(_result) {
        if (_exit2) return _result;
        var _publicKeyHexFromJwk = publicKeyHexFromJwk;
        return Promise.resolve(publicKeyJwkFromPublicKeyHex(_this2.publicKeyBuffer.toString('hex'))).then(function (_keyUtils$publicKeyJw) {
          return _publicKeyHexFromJwk.call(keyUtils, _keyUtils$publicKeyJw);
        });
      };

      var _exit2 = false;

      var _this2 = this;

      var _temp14 = function () {
        if (_private) {
          if (!_this2.privateKeyBuffer) {
            throw new Error('No private key to export');
          }

          _exit2 = true;
          var _privateKeyHexFromJwk2 = privateKeyHexFromJwk;
          return Promise.resolve(privateKeyJwkFromPrivateKeyHex(_this2.privateKeyBuffer.toString('hex'))).then(function (_keyUtils$privateKeyJ) {
            return _privateKeyHexFromJwk2.call(keyUtils, _keyUtils$privateKeyJ);
          });
        }
      }();

      return Promise.resolve(_temp14 && _temp14.then ? _temp14.then(_temp13) : _temp13(_temp14));
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.toKeyPair = function toKeyPair(exportPrivate) {
    if (exportPrivate === void 0) {
      exportPrivate = false;
    }

    var kp = {
      id: this.id,
      type: this.type,
      controller: this.controller,
      publicKeyBase58: bs58.encode(this.publicKeyBuffer)
    };

    if (exportPrivate) {
      kp.privateKeyBase58 = bs58.encode(this.privateKeyBuffer);
    }

    return kp;
  };

  _proto.toJsonWebKeyPair = function toJsonWebKeyPair(exportPrivate) {
    if (exportPrivate === void 0) {
      exportPrivate = false;
    }

    var kp = {
      id: this.id,
      type: 'JsonWebKey2020',
      controller: this.controller,
      publicKeyJwk: this.toJwk()
    };
    delete kp.publicKeyJwk.kid;

    if (exportPrivate) {
      kp.privateKeyJwk = this.toJwk(true);
      delete kp.privateKeyJwk.kid;
    }

    return kp;
  };

  return Secp256k1KeyPair;
}();

exports.Secp256k1KeyPair = Secp256k1KeyPair_1 = /*#__PURE__*/tslib.__decorate([/*#__PURE__*/common.types.staticImplements()], exports.Secp256k1KeyPair);

var resolve = /*#__PURE__*/common.getResolve(exports.Secp256k1KeyPair);
var get = /*#__PURE__*/common.getGet(resolve);

var driver = {
  __proto__: null,
  resolve: resolve,
  get: get
};

exports.ES256K = ES256K;
exports.driver = driver;
exports.keyUtils = keyUtils;
//# sourceMappingURL=did-key-secp256k1.cjs.development.js.map
